using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using CatalogueLibrary.Data;
using CatalogueLibrary.Repositories;
using DataExportLibrary.Data.DataTables;
using DataExportLibrary.Interfaces.Data.DataTables;

namespace DataExportLibrary.DataRelease
{
    /// <summary>
    /// Determines whether a given ExtractableDataSet in an ExtractionConfiguration, as generated by a Flat File extraction configuration is ready for Release. 
    /// This includes making sure that the current configuration
    /// in the database matches the extracted flat files that are destined for release.  It also checks that the user hasn't snuck some additional files into
    /// the extract directory etc.
    /// </summary>
    public class FlatFileReleasePotential : ReleasePotential
    {
        public FlatFileReleasePotential(IRDMPPlatformRepositoryServiceLocator repositoryLocator, IExtractionConfiguration configuration, IExtractableDataSet dataSet) : base(repositoryLocator, configuration, dataSet)
        {
        }

        protected override Releaseability GetSupplementalSpecificAssessment(ISupplementalExtractionResults supplementalExtractionResults)
        {
            if (File.Exists(supplementalExtractionResults.DestinationDescription))
                return Releaseability.Undefined;

            return Releaseability.ExtractFilesMissing;
        }

        protected override Releaseability GetSpecificAssessment(ICumulativeExtractionResults extractionResults)
        {
            ExtractDirectory = new FileInfo(extractionResults.DestinationDescription).Directory;
            if (FilesAreMissing(extractionResults))
                return Releaseability.ExtractFilesMissing;
            
            ThrowIfPollutionFoundInConfigurationRootExtractionFolder();
            return Releaseability.Undefined;// Assesment = SqlDifferencesVsLiveCatalogue() ? Releaseability.ColumnDifferencesVsCatalogue : Releaseability.Releaseable;
        }

        private bool FilesAreMissing(ICumulativeExtractionResults extractionResults)
        {
            ExtractFile = new FileInfo(extractionResults.DestinationDescription);
            var metadataFile = new FileInfo(extractionResults.DestinationDescription.Replace(".csv", ".docx"));

            if (!ExtractFile.Exists)
                return true;//extract is missing

            if (!ExtractFile.Extension.Equals(".csv"))
                throw new Exception("Extraction file had extension '" + ExtractFile.Extension + "' (expected .csv)");

            if (!metadataFile.Exists)
                return true;

            //see if there is any other polution in the extract directory
            FileInfo unexpectedFile = ExtractFile.Directory.EnumerateFiles().FirstOrDefault(f =>
                !(f.Name.Equals(ExtractFile.Name) || f.Name.Equals(metadataFile.Name)));

            if (unexpectedFile != null)
                throw new Exception("Unexpected file found in extract directory " + unexpectedFile.FullName + " (pollution of extract directory is not permitted)");

            DirectoryInfo unexpectedDirectory = ExtractFile.Directory.EnumerateDirectories().FirstOrDefault(d =>
                !(d.Name.Equals("Lookups") || d.Name.Equals("SupportingDocuments") || d.Name.Equals(SupportingSQLTable.ExtractionFolderName)));

            if (unexpectedDirectory != null)
                throw new Exception("Unexpected directory found in extraction directory " + unexpectedDirectory.FullName + " (pollution of extract directory is not permitted)");

            return false;
        }

        private void ThrowIfPollutionFoundInConfigurationRootExtractionFolder()
        {
            Debug.Assert(ExtractDirectory.Parent != null, "Dont call this method until you have determined that an extracted file was actually produced!");

            if (ExtractDirectory.Parent.GetFiles().Any())
                throw new Exception("The following pollutants were found in the extraction directory\" " +
                                    ExtractDirectory.Parent.FullName +
                                    "\" pollutants were:" +
                                    ExtractDirectory.Parent.GetFiles().Aggregate("", (s, n) => s + "\"" + n + "\""));
        }
    }
}