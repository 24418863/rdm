using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CatalogueLibrary.Repositories;
using MapsDirectlyToDatabaseTable;
using Microsoft.Office.Interop.Excel;
using MySql.Data.MySqlClient;
using ReusableLibraryCode;

namespace CatalogueLibrary.Data.Aggregation
{
    /// <summary>
    /// Each AggregateDimension in an AggregateConfiguration can have a defined date axis, this specifies the start/end and increment of the aggregate e.g.
    /// PrescribedDate dimension may have an axis defining it as running from 2001-2009 in increments of 1 month.  
    /// 
    /// For this to work the AggregateDimension output data should be of type a date also.
    /// </summary>
    public class AggregateContinuousDateAxis: DatabaseEntity
    {
    

        #region Database Properties
        private int _aggregateDimensionID;
        private string _startDate;
        private string _endDate;
        private AxisIncrement _axisIncrement;

        public int AggregateDimension_ID
        {
            get { return _aggregateDimensionID; }
            set { SetField(ref  _aggregateDimensionID, value); }
        }

        public string StartDate
        {
            get { return _startDate; }
            set { SetField(ref  _startDate, value); }
        }

        public string EndDate
        {
            get { return _endDate; }
            set { SetField(ref  _endDate, value); }
        }

        public AxisIncrement AxisIncrement
        {
            get { return _axisIncrement; }
            set { SetField(ref  _axisIncrement, value); }
        }

        #endregion

        #region Relationships
        [NoMappingToDatabase]
        public AggregateDimension AggregateDimension { get{return Repository.GetObjectByID<AggregateDimension>(AggregateDimension_ID);}}
        #endregion


        public AggregateContinuousDateAxis(ICatalogueRepository repository,AggregateDimension dimension)
        {
            repository.InsertAndHydrate(this, 
                new Dictionary<string, object>()
                {
                    {"AggregateDimension_ID",dimension.ID}
                });
        }


        public AggregateContinuousDateAxis(ICatalogueRepository repository,DbDataReader r) : base(repository,r)
        {
            AggregateDimension_ID = int.Parse(r["AggregateDimension_ID"].ToString());
            StartDate = r["StartDate"].ToString();
            EndDate = r["EndDate"].ToString();
            AxisIncrement = (AxisIncrement) r["AxisIncrement"];
        }

        
        /// <summary>
        /// Takes the fieldname/transform from the dataset and wraps it with the date adjustment function specified by the AxisIncrement
        /// </summary>
        /// <param name="thingToWrap"></param>
        /// <returns></returns>
        public string WrapWithIntervalFunction(string thingToWrap)
        {
            switch (AxisIncrement)
            {
                case AxisIncrement.Day:
                    return " Convert(date, " + thingToWrap + ") "; //Handles when there are times in the field by always converting to date
                case AxisIncrement.Month:
                    return " CONVERT(nvarchar(7)," + thingToWrap + ",126)"; //returns 2015-01
                case AxisIncrement.Year:
                    return " YEAR(" + thingToWrap + ")"; //returns 2015
                case AxisIncrement.Quarter:
                    return " DATENAME(year, " + thingToWrap + ") +'Q' + DATENAME(quarter," + thingToWrap + ")"; //returns 2015Q1
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        /// <summary>
        /// Gives you the equivalency check for the given axis joined to column1 column.  Use this in the JOIN SQL generated by AggregateBuilder 
        /// </summary>
        /// <param name="column1">The column name or transform from the dataset</param>
        /// <param name="column2">The axis column e.g. axis.dt</param>
        /// <returns></returns>
        public string GetJOINSqlWithIntervalFunction(string column1, string column2)
        {
            switch (AxisIncrement)
            {
                case AxisIncrement.Day:
                    return WrapWithIntervalFunction(column1) + "=" + column2;//truncate any time off column1, column2 is the axis column which never has time anyway
                case AxisIncrement.Month:
                    return string.Format("YEAR({0}) = YEAR({1}) AND MONTH({0}) = MONTH({1})", column1,column2);
                case AxisIncrement.Year:
                    return WrapWithIntervalFunction(column1) + "=" + WrapWithIntervalFunction(column2);
                case AxisIncrement.Quarter:
                    return string.Format("YEAR({0}) = YEAR({1}) AND DATEPART(QUARTER, {0}) = DATEPART(QUARTER, {1})",column1, column2);
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

    }

    public enum AxisIncrement
    {
        Day = 1,
        Month = 2,
        Year = 3,
        Quarter=4
    }
}
