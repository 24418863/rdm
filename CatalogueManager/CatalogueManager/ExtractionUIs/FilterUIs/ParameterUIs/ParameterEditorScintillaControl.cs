using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using CatalogueLibrary.Checks;
using CatalogueLibrary.Checks.SyntaxChecking;
using CatalogueLibrary.Data;
using CatalogueLibrary.DataHelper;
using CatalogueLibrary.QueryBuilding;
using CatalogueLibrary.QueryBuilding.Parameters;
using CatalogueManager.ExtractionUIs.FilterUIs.ParameterUIs.Options;
using CatalogueManager.TestsAndSetup.ServicePropogation;
using MapsDirectlyToDatabaseTable;
using RDMPObjectVisualisation.Copying;
using ReusableLibraryCode;
using ReusableLibraryCode.Checks;
using ReusableUIComponents;
using ReusableUIComponents.ScintillaHelper;
using ScintillaNET;

namespace CatalogueManager.ExtractionUIs.FilterUIs.ParameterUIs
{
    public delegate void ParameterEventHandler(object sender, ISqlParameter parameter);

    /// <summary>
    /// Part of ParameterCollectionUI, this control shows the SQL generated by the current configuration of SQL parameters.  You can edit the SQL in areas that do not have a grey background
    /// (these reflect locked parameters - see ParameterCollectionUI).  editing the SQL changes the corresponding SQL parameter in ParameterCollectionUI.  You cannot add new Parameters by
    /// directly typing in new SQL or change the line number of in the control (basically you should stick to editing the name/declaration and the value text.
    /// </summary>
    public partial class ParameterEditorScintillaControl : RDMPUserControl
    {
        private Scintilla QueryEditor;

        public event ParameterEventHandler ParameterSelected = delegate { };
        public event ParameterEventHandler ParameterChanged = delegate { };
        public event Action ProblemObjectsFound = delegate { };

        public ParameterCollectionUIOptions Options { get; set; }

        public Dictionary<ISqlParameter,Exception> ProblemObjects { get; private set; }

        public ParameterEditorScintillaControl()
        {
            InitializeComponent();

            if (VisualStudioDesignMode) //dont add the QueryEditor if we are in design time (visual studio) because it breaks
                return;

            QueryEditor = new ScintillaTextEditorFactory().Create(new RDMPCommandFactory());
            gbCompiledView.Controls.Add(QueryEditor);

            QueryEditor.KeyDown += new KeyEventHandler(QueryEditor_KeyDown);
            QueryEditor.KeyUp += new KeyEventHandler(QueryEditor_KeyUp);
            QueryEditor.MouseUp += new MouseEventHandler(QueryEditor_MouseUp);

            QueryEditor.Leave += (s,e)=>RegenerateSQL();
            ProblemObjects = new Dictionary<ISqlParameter, Exception>();
        }


        private void QueryEditor_MouseUp(object sender, MouseEventArgs e)
        {
            UpdateEditability();
        }
        private void QueryEditor_KeyUp(object sender, KeyEventArgs e)
        {
            UpdateEditability();
        }
        private void QueryEditor_KeyDown(object sender, KeyEventArgs e)
        {
            UpdateEditability();
        }

        private void UpdateEditability()
        {
            var section = GetParameterOnLine(QueryEditor.CurrentLine);

            if (section == null)
                return;

            QueryEditor.ReadOnly = !section.Editable;
            ParameterSelected(this, section.Parameter);

            CheckForChanges();
        }


        private void CheckForChanges()
        {
            lblError.Visible = false;

            //for each parameter text section
            foreach (var section in Sections)
            {
                string sql = "";

                //get the lines that make up the selection (freetext sql)
                for (int i = section.LineStart; i <= section.LineEnd; i++)
                    sql += QueryEditor.Lines[i].Text;
                
                //pass the section it's sql text an it will tell us if it is borked or changed or unchanged
                FreeTextParameterChangeResult changed = section.CheckForChanges(sql);

                if (changed == FreeTextParameterChangeResult.ChangeRejected)
                {
                    lblError.Visible = true;
                    lblError.Text = "User tried to make illegal change to SQL";
                    RegenerateSQL();
                    return;
                }

                if (changed == FreeTextParameterChangeResult.ChangeAccepted)
                    ParameterChanged(this,section.Parameter);
            }
        }

        private ParameterEditorScintillaSection GetParameterOnLine(int lineNumber)
        {
            return Sections.SingleOrDefault(s=>s.IncludesLine(lineNumber));
        }
        
        List<ParameterEditorScintillaSection> Sections = new List<ParameterEditorScintillaSection>();
        

        public void RegenerateSQL()
        {
            ProblemObjects = new Dictionary<ISqlParameter, Exception>();

            var parameterManager = Options.ParameterManager;
            Sections.Clear();

            try
            {
                QueryEditor.ReadOnly = false;
                string sql = "";
                var finalParameters = parameterManager.GetFinalResolvedParametersList().ToArray();

                int currentLine = 0;

                foreach (ISqlParameter parameter in finalParameters)
                {
                    //if it's a user one
                    if(parameter is IMapsDirectlyToDatabaseTable)
                        //and it has a name that could conflict with RDMP constant parameters
                        if(Options.ProhibitedParameterNames.Any(n=>n.Equals(parameter.ParameterName,StringComparison.CurrentCultureIgnoreCase)))
                            if(!ProblemObjects.ContainsKey(parameter))
                                ProblemObjects.Add(parameter,new Exception("Parameter name " + parameter.ParameterName + " is a reserved name for the RDMP software"));//advise them

                    try
                    {
                        parameter.Check(new ThrowImmediatelyCheckNotifier());
                    }
                    catch (SyntaxErrorException errorException)
                    {
                        if(!ProblemObjects.ContainsKey(parameter))
                            ProblemObjects.Add(parameter,errorException);
                    }
                    

                    string toAdd = QueryBuilder.GetParameterDeclarationSQL(parameter);

                    int lineCount = GetLineCount(toAdd);

                    Sections.Add(new ParameterEditorScintillaSection(Options.Refactorer,currentLine, currentLine += (lineCount - 1), parameter, 
                        
                        !Options.ShouldBeReadOnly(parameter),
                        
                        toAdd));

                    sql += toAdd;
                    currentLine++;
                }

                QueryEditor.Text = sql.TrimEnd();

            }
            catch (Exception ex)
            {
                QueryEditor.Text = ex.ToString();

                var exception = ex as QueryBuildingException;
                if (exception != null)
                {
                    foreach (ISqlParameter p in exception.ProblemObjects.OfType<ISqlParameter>())
                        if(!ProblemObjects .ContainsKey(p))//might have already added it up above
                            ProblemObjects.Add(p, ex);

                    ProblemObjectsFound();
                }
            }
            QueryEditor.ReadOnly = true;

            var highlighter = new ScintillaLineHighlightingHelper();
            highlighter.ClearAll(QueryEditor);

            foreach (ParameterEditorScintillaSection section in Sections)
                if (!section.Editable)
                    for (int i = section.LineStart; i <= section.LineEnd; i++)
                        highlighter.HighlightLine(QueryEditor, i, Color.LightGray);
        }

        private int GetLineCount(string s)
        {
            return s.Count(c => c.Equals('\n'));
        }


    }
}
