<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rdmp.Core</name>
    </assembly>
    <members>
        <member name="T:Rdmp.Core.AmbiguousDatabaseTypeException">
            <summary>
            Thrown when a piece of code needs to know what <see cref="T:FAnsi.DatabaseType"/> is being targetted but no determination
            can be made either because there are no objects of a known <see cref="T:FAnsi.DatabaseType"/> or because there are objects
            of multiple different <see cref="T:FAnsi.DatabaseType"/>.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.CachingHost">
            <summary>
            The CachingHost has two public interfaces: 'Start' and 'StartDaemon'. 
            'Start' is a one-shot mode where any available CacheProgress records are cached until completion (this could be a very long 'one-shot').
            'StartDaemon' continually attempt to cache available CacheProgress records until cancelled. This mode will keep the caches up-to-date.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.CachingPreExecutionChecker">
            <summary>
            Determines whether a given CacheProgress can be run.  This includes checking if there is a data time period to process, whether it is Locked, whether the classes required in the Pipeline
            can be constructed etc.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.CustomDateCaching">
            <summary>
            Executes a caching configuration (ICacheProgress) for the specified arbitrary date/time range using either a SingleDayCacheFetchRequestProvider or a
            MultiDayCacheFetchRequestProvider.  Note that this uses a BackfillCacheFetchRequest which should mean that the actual progress head pointer (how far
            we think we have cached up to) does not change.  The reason we use a BackfillCacheFetchRequest is to allow us to run a given day/week again without
            reseting our entire progress back to that date. 
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Layouts.BasicCacheLayout">
            <summary>
            Specifies how files are laid out by date.  This is the default implementation in which the cache root directory (usually .\Data\Cache) is populated with folders
            yyyy-MM-dd which contains unzipped lists of files for that day.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Layouts.CacheLayout">
            <summary>
            Abstract base ICacheLayout, see ICacheLayout for description or BasicCacheLayout for example of how to use this class.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Caching.Layouts.CacheLayout.GetLoadCacheDirectory(ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            The cache sub-directory for a particular load schedule within a load metadata. Uses a resolver for dataset-specific cache layout knowledge
            </summary>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Caching.Layouts.CacheLayoutFactory">
            <summary>
            Creates <see cref="T:Rdmp.Core.Caching.Layouts.ICacheLayout"/> instances based on the <see cref="T:Rdmp.Core.DataLoad.Engine.DataProvider.FromCache.ICachedDataProvider"/>s declared in the load <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata"/>.  There
            can be multiple <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress"/> in a load (e.g. Tayside / Fife) so you will also need to provide which <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress"/> you are 
            trying to execute.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Layouts.ICacheLayout">
             <summary>
            'static' information about the cache layout, as opposed to the resolver which will give information for specific cache configurations
             Cache layout is effectively based on date with load schedule-specific sub directories with dataset-specific layout information provided through the Resolver
             </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Layouts.ILoadCachePathResolver">
            <summary>
            Translates a root cache directory (usually .\Data\Cache e.g. C:\temp\DemographyLoading\Data\Cache) into a subdirectory based on arbitrary logic. For example
            you might have CacheProgress that are tied to specific healthboards and you want subdirectories T and F in your Cache directory.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Layouts.NoSubdirectoriesCachePathResolver">
            <summary>
            Basic case of <see cref="T:Rdmp.Core.Caching.Layouts.ILoadCachePathResolver"/> in which the path .\Data\Cache is what is returned unchanged i.e. no subdirectories
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Layouts.ZipCacheLayoutOnePerDay">
            <summary>
            Alternative cache layout to BasicCacheLayout in which files are expected to be in a zip file instead of a directory (e.g. in .\Data\Cache\2001-01-01.zip, .\Data\Cache\2001-01-02.zip etc)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.PermissionWindowCacheDownloader">
            <summary>
            Responsible for executing the caching pipeline(s) for a given PermissionWindow and/or set of CacheProgress items.
            If a PermissionWindow is set, either all CacheProgresses attached to that window can be downloaded (by calling Download) or a subset may be specified (by calling overloaded Download).
            If no PermissionWindow is set, either all CacheProgresses which have no PermissionWindow can be downloaded (by calling Download) or a subset may be specified (by calling overloaded Download).
            </summary>
        </member>
        <member name="M:Rdmp.Core.Caching.PermissionWindowCacheDownloader.#ctor(Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow,Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.Caching.Pipeline.IMultiPipelineEngineExecutionStrategy)">
            <summary>
            
            </summary>
            <param name="permissionWindow">May be null, then allows downloading of CacheProgress with no associated PermissionWindow</param>
            <param name="repository"></param>
            <param name="pipelineEngineExecutionStrategy">Multiple CacheProgresses will result in multiple PipelineEngines, this strategy determines how these should be run, e.g. Round-robin, Async</param>
        </member>
        <member name="M:Rdmp.Core.Caching.PermissionWindowCacheDownloader.#ctor(Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow,System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress},Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.Caching.Pipeline.IMultiPipelineEngineExecutionStrategy)">
            <summary>
            Overload with specific cache items to download for this permission window
            </summary>
            <param name="permissionWindow"></param>
            <param name="cacheProgressItems"></param>
            <param name="repository"></param>
            <param name="pipelineEngineExecutionStrategy"></param>
        </member>
        <member name="M:Rdmp.Core.Caching.PermissionWindowCacheDownloader.Download(ReusableLibraryCode.Progress.IDataLoadEventListener,Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <summary>
            Single-shot, will either exit immediately if not in the permission window or run until either:
            - the permission window expires, or 
            - all engines successfully complete execution.
            </summary>
            <param name="listener"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Rdmp.Core.Caching.PermissionWindowCacheDownloader.RunOnce(Rdmp.Core.DataFlowPipeline.GracefulCancellationToken,System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine})">
            <summary>
            Blocking call which runs a set of DataFlowPipelineEngines according to the execution strategy whilst observing the PermissionWindow.
            Stops the task and returns if the PermissionWindow closes.
            </summary>
            <param name="cancellationToken"></param>
            <param name="cachingEngines"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Caching.Pipeline.CachingPipelineUseCase">
            <summary>
            Describes the use case under which a caching is attempted for a given ICacheProgress.  This involves working out the ICacheFetchRequestProvider, 
            PermissionWindow etc.  Since the use case is used both for creating an engine for execution and for determining which IPipelines are compatible
            with the use case the class can be used at execution and design time.  Therefore it is legal to define the use case even when the ICacheProgress does
            not have a configured caching pipeline e.g. to facilitate the user selecting/creating an appropriate pipeline in the first place (set throwIfNoPipeline 
            to false under such circumstances).
            </summary>
        </member>
        <member name="M:Rdmp.Core.Caching.Pipeline.CachingPipelineUseCase.#ctor(Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress,System.Boolean,Rdmp.Core.Caching.Requests.FetchRequestProvider.ICacheFetchRequestProvider,System.Boolean)">
            <summary>
            Class for helping you to construct a caching pipeline engine instance with the correct context and initialization objects
            </summary>
            <param name="cacheProgress">The cache that will be run</param>
            <param name="ignorePermissionWindow">Set to true to ignore the CacheProgress.PermissionWindow (if any)</param>
            <param name="providerIfAny">The strategy for figuring out what dates to load the cache with e.g. failed cache fetches or new jobs from head of que?</param>
        </member>
        <member name="M:Rdmp.Core.Caching.Pipeline.CachingPipelineUseCase.#ctor">
            <summary>
            Design time types
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Pipeline.Destinations.CacheFileGranularity">
            <summary>
            Time period for which cache chunks are stored / fetched.  Some caching tasks produce so many file system entries it is nessesary to subdivide the cache by Hour.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Pipeline.Destinations.CacheFilesystemDestination">
            <summary>
            Abstract implementation of ICacheFileSystemDestination. Includes checks for CacheLayout construction and read/write permissions to Cache directory.  To implement
            this class you should implement an ICacheLayout (or use an existing one) and then use ProcessPipelineData to populate the CacheDirectory with data according to the
            ICacheLayout
            </summary>
        </member>
        <member name="M:Rdmp.Core.Caching.Pipeline.Destinations.CacheFilesystemDestination.CreateCacheLayout">
            <summary>
            Use CacheDirectory to create a new layout, this method should only be called after PreInitialize
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Caching.Pipeline.Destinations.ICacheFileSystemDestination">
            <summary>
            Interface for minimum requirements of a cache destination pipeline component.  See abstract base class CacheFilesystemDestination for details on what this is.  This
            interface exists so that DLE (and other) processes can process the pipeline destination (e.g. to read files out of it again) without having to know the exact caching
            context etc.  Any ICacheFileSystemDestination must be able to CreateCacheLayout based solely on an ILoadDirectory
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Pipeline.IMultiPipelineEngineExecutionStrategy">
            <summary>
            Logic for locking and executing multiple IDataFlowPipelineEngine at once (single threaded loop is valid, it doesn't have to be async)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Pipeline.RoundRobinPipelineExecution">
            <summary>
            Strategy for executing several IDataFlowPipelineEngines one chunk at a time in serial.  The difference between this and SerialPipelineExecution
            is that only one ChunkPeriod is read at once from each engine.  If there is more data available to fetch in any engine they are all run again until
            all caches are up to date or the cancellation token is set
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Pipeline.SerialPipelineExecution">
            <summary>
            Strategy for executing several IDataFlowPipelineEngines one after the other in serial.  This will fully exhaust each IDataFlowPipelineEngine one 
            after the other.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Pipeline.Sources.CacheSource`1">
            <summary>
            Abstract base class for a pipeline component which makes time based fetch requests to produce time specific packets of data which will be packaged into files
            and stored further down the caching pipeline.  Use the Request property to determine which dates/times you are supposed to handle within DoGetChunk.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Rdmp.Core.Caching.Pipeline.Sources.CacheSource`1.GetChunk(ReusableLibraryCode.Progress.IDataLoadEventListener,Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <summary>
            Enforces behaviour required for logging unsuccessful cache requests and providing implementation-independent checks, so that the plugin author
            doesn't need to remember to call Request[Succeeded|Failed] or do general checks.  Plugin author provides implementation-specific caching in 
            the 'DoGetChunk' function.
            </summary>
            <param name="listener"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Caching.Pipeline.Sources.CacheSource`1.DoGetChunk(Rdmp.Core.Caching.Requests.ICacheFetchRequest,ReusableLibraryCode.Progress.IDataLoadEventListener,Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <summary>
            Handles the current <paramref name="request"/> returning an appropriate <see cref="T:Rdmp.Core.Caching.Requests.ICacheChunk"/> for the time range specified.
            </summary>
            <param name="request">The period of time we want to fetch</param>
            <param name="listener">For auditing progress during the fetch</param>
            <param name="cancellationToken">Indicates if user is trying to cancel the process</param>
        </member>
        <member name="T:Rdmp.Core.Caching.Pipeline.Sources.ICacheSource">
            <summary>
            Interface for abstract base CacheSource (See CacheSource for description).  All CacheSources should be exposed to and consider both the ICacheFetchRequestProvider
            (which tells you what date/time you are supposed to be fetching) and IPermissionWindow (which tells you what real time window you can make requests during e.g. only
            attempt to cache data between 9am and 5pm at night)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Requests.BackfillCacheFetchRequest">
            <summary>
            ICacheFetchRequest representing an 'out of order' fetch for a specific time/date range.  This will not affect the head of an ICacheProgress (how far we think we
            have loaded) and is intended to back fill gaps in a cache that is already populated.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Caching.Requests.BackfillCacheFetchRequest.GetNext">
            <summary>
            Factory method which creates the 'next' logical fetch request using the request's chunk period
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Caching.Requests.CacheFetchRequest">
            <summary>
            Describes a normal caching request for a period of days/hours for an ICacheSource to request.  This includes start / end date which will be the next logical period
            of time to fetch to advance the head of an ICacheProgress (fetch the next date range and update the progress pointer).
            </summary>
        </member>
        <member name="P:Rdmp.Core.Caching.Requests.CacheFetchRequest.IsRetry">
            <summary>
            Is this CacheFetchRequest a retry of a previously failed fetch request?
            </summary>
        </member>
        <member name="M:Rdmp.Core.Caching.Requests.CacheFetchRequest.#ctor(Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure,Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress)">
            <summary>
            Creates a CacheFetchRequest from a previous failure.
            </summary>
            <param name="cacheFetchFailure"></param>
            <param name="cacheProgress"></param>
        </member>
        <member name="M:Rdmp.Core.Caching.Requests.CacheFetchRequest.GetNext">
            <summary>
            Factory method which creates the 'next' logical fetch request using the request's chunk period
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Caching.Requests.DoNothingCacheChunk">
            <summary>
            Cache Chunk used with the other DoNothing classes to test operations
            </summary>
        </member>
        <member name="M:Rdmp.Core.Caching.Requests.FetchRequestProvider.CacheFetchRequestProvider.#ctor(Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress)">
            <summary>
            Sets up the class to generate <see cref="T:Rdmp.Core.Caching.Requests.ICacheFetchRequest"/> for the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress"/>
            </summary>
            <param name="cacheProgress">The cache which the request is for, this must have either an <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheFillProgress"/> or it's
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress"/> parent must have a populated <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress.OriginDate"/></param>
        </member>
        <member name="M:Rdmp.Core.Caching.Requests.FetchRequestProvider.CacheFetchRequestProvider.CreateInitialRequest">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.Caching.Requests.ICacheFetchRequest"/> with a valid start date but no End.  To hydrate end you should use a <see cref="T:Rdmp.Core.Caching.Requests.FetchRequestProvider.ICacheFetchRequestProvider"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Caching.Requests.FetchRequestProvider.CacheFetchRequestProvider.GetNext(ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Returns the next <see cref="T:Rdmp.Core.Caching.Requests.ICacheFetchRequest"/> based on the <see cref="P:Rdmp.Core.Caching.Requests.FetchRequestProvider.CacheFetchRequestProvider.Current"/>
            </summary>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Caching.Requests.FetchRequestProvider.FailedCacheFetchRequestProvider">
            <summary>
            Sometimes during caching you will identify a period of time that cannot be fetched because of problems outwith your control (the remote server data is missing etc).  
            These periods are modeled by ICacheFetchFailure.  This Provider allows you to load a batch of failures and re try them.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Caching.Requests.FetchRequestProvider.FailedCacheFetchRequestProvider.GetNext(ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            
            </summary>
            <returns>Next CacheFetchRequest or null if there are no further request failures to process</returns>
        </member>
        <member name="T:Rdmp.Core.Caching.Requests.FetchRequestProvider.ICacheFetchRequestProvider">
            <summary>
            Interface for classes that make descisions about which time periods to request and in what order when caching.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Requests.FetchRequestProvider.MultiDayCacheFetchRequestProvider">
            <summary>
            Generates ICacheFetchRequest incrementally until the given end date.  You must provide an initial request. 
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Requests.FetchRequestProvider.SingleDayCacheFetchRequestProvider">
            <summary>
            Generates ICacheFetchRequests until the end of the day.  Day is based on the initial request.  This can be still be multiple requests if the ICacheProgress
            ChunkPeriod is, for example, 1 hour at a time.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Requests.ICacheChunk">
            <summary>
            Base interface for templated Cache pipelines, you should inherit from this class and add whatever properties you will use in your data classes e.g FileInfo[] property if your
            cache involves downloading lots of files to fulfil the request
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Requests.ICacheFetchRequest">
            <summary>
            An instruction for an ICacheSource to request a specific date/time range of data.  The ICacheFetchRequest will also be available in the ICacheChunk which is the T 
            flow object of a caching pipeline (See CachingPipelineUseCase) this means that the destination can ensure that the data read goes into the correct sections of the 
            file system.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.Requests.ICacheRebuilder">
            <summary>
            Interface for attempting to rebuild the .\Data\Cache (or alternative) Cache directory based on files currently in the ForArchiving directory.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Caching.RetrievalResult">
            <summary>
            The results of an attempt to start a Caching action.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.ANOEngineering.ColumnInfoANOPlan">
            <summary>
            Records all ANO descisions made about a single ColumnInfo (e.g. whether to ANO it, Drop it, Dillute it etc)
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.ANOEngineering.ColumnInfoANOPlan.#ctor(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo)">
            <summary>
            Json deserialization constructor <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.ANOEngineering.ColumnInfoANOPlan.Initialize(Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation[],Rdmp.Core.CatalogueLibrary.Data.CatalogueItem[],System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.JoinInfo},System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.Lookup},Rdmp.Core.CatalogueLibrary.Data.ColumnInfo[],Rdmp.Core.CatalogueLibrary.ANOEngineering.ForwardEngineerANOCataloguePlanManager)">
            <summary>
            Make up ANOTable plans based on existing ANOTable/column usages.  For example if the column chi is being migrated and there is at least one column
            called chi or ANOchi already existing (probably from another table) then we should suggest using ANOTable ANOchi.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.ANOEngineering.ForwardEngineerANOCatalogueEngine">
            <summary>
            Creates a new 'anonymous' version of a Catalogue based on a configuration the user has set up in a ForwardEngineerANOCataloguePlanManager.  This involves creating
            a new empty data table in the destination database (adjusted to accomodate anonymous datatypes / dropped columns etc), importing the empty table as a new
            TableInfo(s) and creating a new Catalogue entry.  Since Catalogues can have multiple underlying tables (e.g. lookup tables shared join tables etc) the engine
            supports migrating only a subset of tables across (the remaining tables must have already been migrated and exist in the destination database).
            
            <para>Finally the engine creates a LoadMetadata which when run will migrate (copy) the data from the old table into the new table.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.ANOEngineering.ForwardEngineerANOCatalogueEngine.GetNewColumnInfoForOld(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,System.Boolean)">
            <summary>
            Returns the newly created / already existing NEW ANO column info when passed the old (identifiable original) ColumnInfo
            </summary>
            <param name="col"></param>
            <param name="isOptional"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.ANOEngineering.ForwardEngineerANOCatalogueEngine.FindNewColumnNamed(FAnsi.Discovery.QuerySyntax.IQuerySyntaxHelper,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,System.String,System.Boolean)">
            <summary>
            Here we are migrating a Catalogue but some of the TableInfos have already been migrated e.g. lookup tables as part of migrating another Catalogue.  We are
            now trying to find one of those 'not migrated' ColumnInfos by name without knowing whether the user has since deleted the reference or worse introduced 
            duplicate references to the same TableInfo/ColumnInfos.
            </summary>
            <param name="syntaxHelper"></param>
            <param name="col"></param>
            <param name="expectedName"></param>
            <param name="isOptional"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.ANOEngineering.ForwardEngineerANOCataloguePlanManager">
            <summary>
            Configuration class for ForwardEngineerANOCatalogueEngine (See ForwardEngineerANOCatalogueEngine).  This class stores which anonymisation transforms/dilutions
            etc to apply to which columns, which TableInfos are to be mirated etc.  Also stores whether the LoadMetadata that is to be created should be a single one off
            load or should load in date based batches (e.g. 1 year at a time - use this option if you have too much data in the source table to be migrated in one go - e.g.
            tens of millions of records). 
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.ANOEngineering.ForwardEngineerANOCataloguePlanManager.#ctor(Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator)">
            <summary>
            This constructor is primarily intended for deserialization via <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.JsonConvertExtensions.DeserializeObject(System.String,System.Type,Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator,System.Object[])"/>.  You should 
            instead use the overload. 
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.ANOEngineering.ForwardEngineerANOCataloguePlanManager.RefreshTableInfos">
            <summary>
            Re checks the TableInfos associated with the Catalogue incase some have changed
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.ANOEngineering.IDilutionOperation">
            <summary>
            Describes a way of anonymising a field (ColumnToDilute) by dilution (making data less granular) e.g. rounding dates to the nearest quarter.  Implementation 
            must be based on running an SQL query in AdjustStaging.  See Dilution for more information.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Checks.BadAssembliesChecker">
            <summary>
            Lists all plugin/dll load exceptions generated during Startup (when MEF is processed).  Also checks that all Types declared as ICheckable
            can be constructed
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Checks.BadAssembliesChecker.#ctor(Rdmp.Core.Repositories.MEF)">
            <summary>
            Prepares to check the currently loaded assemblies defined in the MEF (Call CatalogueRepository.MEF to get the MEF), call Check to start the checking process
            </summary>
            <param name="mefPlugins"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Checks.BadAssembliesChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Lists assembly load errors and attempts to construct instances of all Types declared as Exports (which are ICheckable)
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Checks.ClonedFilterChecker">
            <summary>
            Checks whether a given IFilter which was known to be cloned is still identical to its parent ExtractionFilter.  Also confirms that it's parent still exists.
            It is legal to modify an IFilter after cloning into a subfilter (e.g. AggregateFilter) therefore this class only provides Warning level events
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Checks.ClonedFilterChecker.#ctor(Rdmp.Core.CatalogueLibrary.Data.IFilter,System.Nullable{System.Int32},MapsDirectlyToDatabaseTable.IRepository)">
            <summary>
            Prepares to check the supplied IFilter which must be of a lower filter type to it's parent ExtractionFilter
            </summary>
            <param name="child"></param>
            <param name="allegedParentExtractionFilterID">ExtractionFilter from which the IFilter was derrived</param>
            <param name="catalogueDatabaseRepository"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Checks.ClonedFilterChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the alleged parent of the cloned IFilter still exists and issues a warning if the SQL has changed vs the master (might not
             be a problem since user customisation is allowed)
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Checks.MEFChecker">
            <summary>
            This class checks for the existence of a given MEF export e.g. [Export(typeof(IDataFlowSource))].  The class to find should be a fully expressed path to the class
            e.g. "DataExportLibrary.ExtractionTime.ExtractionPipeline.Sources.ExecuteDatasetExtractionSource" The class will not only check at runtime that the class
            exists but it will (via the ICheckNotifier) interface look for namespace changes that is classes with the same name as the missing MEF but in a different namespace
            
            <para>If the Check method finds a namespace change and the ICheckNotifier accepts the substitution then the Action userAcceptedSubstitution is called with the new class name</para>
            
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Checks.MEFChecker.#ctor(Rdmp.Core.Repositories.MEF,System.String,System.Action{System.String})">
            <summary>
            Setup the checker to look for a specific class within the defined Types in all assemblies loaded in MEF.  The Action will be called if the class name is found
            in a different namespace/assembly and the check handler accepts the proposed fix.  It is up to you to decide what to do with this information.
            </summary>
            <param name="mefPlugins"></param>
            <param name="classToFind"></param>
            <param name="userAcceptedSubstitution"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Checks.MEFChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Looks for the class name within the defined Types in all assemblies loaded in MEF.  If you pass an ICheckNotifier which responds to ProposedFixes and the class
            is found under a different namespace (e.g. due to the coder of the plugin refactoring the class to a new location in his assembly) then the callback 
            userAcceptedSubstitution will be invoked.  Use AcceptAllCheckNotifier if you want the callback to always be called.
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Checks.PipelineChecker">
            <summary>
            Checks an IPipeline (persisted data flow pipeline configuration) to see if all it's components are constructable (using MEFChecker)
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Checks.PipelineChecker.#ctor(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline)">
            <summary>
            Sets up the checker to check the supplied pipeline
            </summary>
            <param name="pipeline"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Checks.PipelineChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that all the components defined in the pipeline are found using a MEFChecker.  This will also handle classes changing namespaces by updating
            class name reference.
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.DataHelper.ITableInfoImporter">
            <summary>
            Shared interface for the two classes which create TableInfos from tables (namely TableInfoImporter and TableValuedFunctionImporter).  A TableInfo the RDMP class that
            documents a persistent reference to a querable table (See TableInfo).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.ITableInfoImporter.DoImport(Rdmp.Core.CatalogueLibrary.Data.TableInfo@,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo[]@)">
            <summary>
            Creates references to all columns/tables found on the live database in the RDMP persistence database.
            </summary>
            <param name="tableInfoCreated"></param>
            <param name="columnInfosCreated"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.ITableInfoImporter.CreateNewColumnInfo(Rdmp.Core.CatalogueLibrary.Data.TableInfo,FAnsi.Discovery.DiscoveredColumn)">
            <summary>
            For when a <paramref name="discoveredColumn"/> is not currently documented by an existing <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/>
            in the <paramref name="parent"/>.  This method creates one.
            </summary>
            <param name="parent"></param>
            <param name="discoveredColumn"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.DataHelper.JoinHelper">
            <summary>
            Generates ANSI Sql for joining tables together in the FROM line of an SQL query
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.JoinHelper.GetJoinSQL(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,System.Nullable{Rdmp.Core.CatalogueLibrary.Data.ExtractionJoinType},System.String)">
            <summary>
            Static version lets you preview what the Lookup will look like without actually having to 
            create one ( note that this method will not let you view Supplemental joins, these require 
            GetJoinSQL(IJoin) to be used instead
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.JoinHelper.GetJoinSQL(Rdmp.Core.CatalogueLibrary.Data.IJoin)">
            <summary>
            Assembles ANSI Sql for the JOIN section of a query including any supplemental join columns (e.g. T1 LEFT JOIN T2 on T1.A = T2.A AND T1.B = T2.B)
            </summary>
            <param name="join"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.JoinHelper.GetJoinSQLForeignKeySideOnly(Rdmp.Core.CatalogueLibrary.Data.IJoin)">
            <summary>
            Returns the first half of the join with an inverted join type
            
            <para>Explanation:joins are defined as FK table JOIN_TYPE PK table so if you are requesting a join to the FK table it is assumed you are coming from the pk table therefore the join type is INVERTED i.e. LEFT becomes RIGHT</para>
            
            </summary>
            <param name="join"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.JoinHelper.GetJoinSQLPrimaryKeySideOnly(Rdmp.Core.CatalogueLibrary.Data.IJoin,System.Int32)">
            <summary>
            Gets the JOIN Sql for the JoinInfo as foreign key JOIN primary key on fk.col1 = pk.col2.  Pass in a number
            in order to have the primary key table be assigned an alias e.g. 1 to give it t1
            
            <para>Because join type refers to FK join PK and you are requesting "X" + " JOIN PK table on x" then the join is inverted e.g. LEFT => RIGHT and RIGHT => LEFT
            unless it is a lookup join which is always LEFT</para>
            </summary>
            <param name="aliasNumber"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.JoinHelper.GetLookupTableAlias(System.Int32,System.Boolean)">
            <summary>
            Gets the suffix for a given lookup table number
            </summary>
            <param name="aliasNumber">the lookup number e.g. 1 gives lookup_1</param>
            <param name="requirePrefix">pass in true if you require the prefix " AS " (may vary depending on database context in future e.g. perhaps MySql refers to tables by different alias syntax)</param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.DataHelper.RDMPQuerySyntaxHelper">
            <summary>
            Legacy helper functions for manipulating Sql.  Many methods are Microsoft Sql Server specific.  If possible you should use IQuerySyntaxHelper instead since that is
            DatabaseType specific.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.DataHelper.RDMPQuerySyntaxHelper.ParameterSQLRegex">
            <summary>
            Regex pattern used for validating Sql Parameter names e.g. @MyParam
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.RDMPQuerySyntaxHelper.ParityCheckCharacterPairs(System.Char[],System.Char[],System.String)">
            <summary>
            Checks to see if there is a closing bracket for every opening bracket (or any other characters that come in open/close pairs.  Throws SyntaxErrorException if there
            is a mismatch in the number of opening/closing of any of the character pairs passed into the method.
            </summary>
            <param name="openingCharacters">An array of opening characters which start a condition e.g. '['</param>
            <param name="closingCharacters">An array of closing characters which must be in the same order (semantically) and size as openingCharacters e.g. if open array element 0 is '[' then closing array element 0 must be ']' </param>
            <param name="sql">The string of text to check for equal numbers of opening/closing characters in</param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.DataHelper.TableInfoImporter">
            <summary>
            Generates TableInfo entries in the ICatalogueRepository based the table/view specified on the live database server.  Can also be used to import new ColumnInfos into existing
            TableInfos (See TableInfoSynchronizer).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.TableInfoImporter.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String,System.String,System.String,FAnsi.DatabaseType,System.String,System.String,ReusableLibraryCode.DataAccess.DataAccessContext,System.String)">
            <summary>
            Prepares to import the named table as a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/>
            </summary>
            <param name="repository">Repository to create the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/>/<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> in</param>
            <param name="importFromServer"></param>
            <param name="importDatabaseName"></param>
            <param name="importTableName"></param>
            <param name="type"></param>
            <param name="username"></param>
            <param name="password"></param>
            <param name="usageContext"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.TableInfoImporter.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,FAnsi.Discovery.DiscoveredTable,ReusableLibraryCode.DataAccess.DataAccessContext)">
            <summary>
            Prepares to import a reference to the <paramref name="table"/> as <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> and <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> in the RDMP <paramref name="catalogueRepository"/>
            </summary>
            <param name="catalogueRepository"></param>
            <param name="table"></param>
            <param name="usageContext"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.TableInfoImporter.DoImport(Rdmp.Core.CatalogueLibrary.Data.TableInfo@,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo[]@)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.TableInfoImporter.CreateNewColumnInfo(Rdmp.Core.CatalogueLibrary.Data.TableInfo,FAnsi.Discovery.DiscoveredColumn)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.TableInfoImporter.DoImport">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.DataHelper.TableInfoImporter.DoImport(Rdmp.Core.CatalogueLibrary.Data.TableInfo@,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo[]@)"/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.DataHelper.TableValuedFunctionImporter">
            <summary>
            Generates TableInfo entries in the ICatalogueRepository based the Table Valued Function specified on the live database server.  Table Valued Functions are Microsoft
            Sql Server specific, they are like Scalar functions except they return data tables.  RDMP supports building Catalogues that refer to Table Valued Functions.  These
            act just like regular tables when it comes to aggregates, data extraction etc except that they can have ISqlParameters declared for them.  Table Valued Functions are
            really not nice, especailly if they are non deterministic (return different results when given the same parameters), therefore really you should just avoid using them 
            if at all possible.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.DataHelper.TableValuedFunctionImporter.ParametersCreated">
            <summary>
            List of parameters belonging to the <see cref="T:FAnsi.Discovery.DiscoveredTableValuedFunction"/> being imported.  Each parameter will result in an RDMP object <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter"/> 
            which records the default value to send when fetching data etc as well as to facilitate the population of parameters in data extract / cohort generation etc.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.TableValuedFunctionImporter.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,FAnsi.Discovery.DiscoveredTableValuedFunction,ReusableLibraryCode.DataAccess.DataAccessContext)">
            <summary>
            Prepares to import the given table valued function <paramref name="tableValuedFunction"/> as <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> / <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> references in the
            <paramref name="repository"/>.
            </summary>
            <param name="repository"></param>
            <param name="tableValuedFunction"></param>
            <param name="usageContext"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.TableValuedFunctionImporter.DoImport(Rdmp.Core.CatalogueLibrary.Data.TableInfo@,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo[]@)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.TableValuedFunctionImporter.CreateNewColumnInfo(Rdmp.Core.CatalogueLibrary.Data.TableInfo,FAnsi.Discovery.DiscoveredColumn)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.TableValuedFunctionImporter.CreateParameter(Rdmp.Core.CatalogueLibrary.Data.TableInfo,FAnsi.Discovery.DiscoveredParameter)">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter"/> for describing a parameter of the table valued function <paramref name="parent"/>.  This is public so that
            it can be used for later synchronization as well as initial import.
            </summary>
            <param name="parent"></param>
            <param name="discoveredParameter"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.DataHelper.TableValuedFunctionImporter.GetParamaterDeclarationSQL(FAnsi.Discovery.DiscoveredParameter)">
            <summary>
            Creates a parameter declaration SQL for the given <paramref name="parameter"/> e.g. if the parameter is @myVar varchar(10) then the declare SQL might be
            DECLARE @myVar as varchar(10);.  
            
            <para><seealso cref="M:FAnsi.Discovery.QuerySyntax.IQuerySyntaxHelper.GetParameterDeclaration(System.String,System.String)"/></para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX">
            <summary>
            Allows you to limit the number of rows returned by an aggregate graph built by AggregateBuilder (or the number of PIVOT lines in a graph).  If your AggregateConfiguration has no pivot
            (and no axis) then the SELECT query that is generated will have a 'TOP X' and it's 'ORDER BY' will be decided by this class.  The most common use of this is to limit the results according
            to the count column e.g. 'Only graph the top 10 most prescribed drugs'.  You can change the direction of the TopX to turn it into 'Only graph the 10 LEAST prescribed drugs' or you can
            change your count(*) SQL on the Aggregate to AVERAGE(dose) and then you would have 'Top 10 most prescribed drugs by average prescription amount... or something like that anyway'.
            
            <para>Also if you have a very strange requirement you can pick an AggregateDimension for the TopX to apply to other than the count column e.g. top 10 drug names by ascending would give
             Asprin, Aardvarksprin, A... etc</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX.AggregateConfiguration_ID">
            <summary>
            ID of the aggregate graph that this topX applies to
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX.TopX">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX.OrderByDimensionIfAny_ID">
            <summary>
            The dimension which the top X applies to, if null it will be the count / sum etc column (The AggregateCountColumn)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX.OrderByDirection">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX.OrderByDimensionIfAny">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX.OrderByDimensionIfAny_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX.OrderByColumn">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX.OrderByDimensionIfAny_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.Data.Common.DbDataReader)">
            <summary>
            Creates an instance by reading it out of the database for the provided reader
            </summary>
            <param name="repository"></param>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,System.Int32)">
            <summary>
            Defines that the given AggregateConfiguration should only return the top X records / pivot categories.  You can only have a single AggregateTopX declared
            for a given AggregateConfiguration (enforced with database constraints).
            </summary>
            <param name="repository"></param>
            <param name="forConfiguration"></param>
            <param name="topX"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.AggregateTopXOrderByDirection">
            <summary>
            The direction to sort the results of an Aggregate Graph
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.AggregateTopXOrderByDirection.Ascending">
            <summary>
            Alphabetically A->Z numerically 0->99999
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.AggregateTopXOrderByDirection.Descending">
            <summary>
            Alphabetically Z->A numerically 99999->0
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration">
            <summary>
            Entry point for the aggregation system.  This class describes what a given aggregation is supposed to achieve (e.g. summarise the number of records in a 
            dataset by region over time since 2001 to present).  An AggregateConfiguration belongs to a given Catalogue and is the hanging-off point for the rest of
            the configuration (e.g. AggregateDimension / AggregateFilter)
            
            <para>AggregateConfigurations can be used with an AggregateBuilder to produce runnable SQL which will return a DataTable containing results appropriate to the
            query being built.</para>
            
            <para>There are Three types of AggregateConfiguration (these are configurations - not seperate classes):</para>
            <para>1. 'Aggregate Graph' - Produce summary information about a dataset designed to be displayed in a graph e.g. number of records each year by healthboard</para>
            <para>2. 'Cohort Aggregate' - Produce a list of unique patient identifiers from a dataset (e.g. 'all patients with HBA1c test code > 50 in biochemistry')</para>
            <para>3. 'Joinable PatientIndex Table' - Produce a patient identifier fact table for joining to other Cohort Aggregates during cohort building (See JoinableCohortAggregateConfiguration)</para>
            <para>The above labels are informal terms.  Use IsCohortIdentificationAggregate and IsJoinablePatientIndexTable to determine what type a given
            AggregateConfiguration is. </para>
            
            <para>If your Aggregate is part of cohort identification (Identifier List or Patient Index Table) then its name will start with cic_X_ where X is the ID of the cohort identification 
            configuration.  Depending on the user interface though this might not appear (See ToString implementation).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.CountSQL">
            <summary>
            The count(*) or sum(*) or count(distinct chi) etc column of an AggregateConfiguration group by 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.Catalogue_ID">
            <summary>
            The ID of the Catalogue (dataset) that the AggregateConfiguration belongs to.  This determines which tables/server it will be run on in addition to what filters/columns are 
            importable etc.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.Name">
            <summary>
            The unique name of the aggregate e.g. 'Biochemistry records by year divided by healthboard'
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.Description">
            <summary>
            A human readable description of what the AggregateConfiguration is trying to depict or represent
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.dtCreated">
            <summary>
            Automatically populated field indicating when the AggregateConfiguration was created in the database (you really shouldn't change this field)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.PivotOnDimensionID">
            <summary>
            Indicates the AggregateDimension (if any) that will result in a pivot graph being generated.  E.g. if your AggregateConfiguration is a graph of records by year between
            2001 and 2018 then specifying a pivot on healthboard would result in 1 line in the graph per healthboard instead of a single line for the count of all (the default).
            
            <para>If an AggregateConfiguration is a Cohort or Patient index table then it cannot have a Pivot</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.IsExtractable">
            <summary>
            Flag that indicates whether an AggregateConfiguration which is functioning as a graph can be exposed to users without worrying about governance.  This manifests as whether
            you can use the aggregate graph to supply information about an extraction etc.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.HavingSQL">
            <summary>
            Specifies that HAVING section of the GROUP BY statement represented by this AggregateConfiguration.  For example you could specify patients on drug X HAVING count(*) > 2 to
            indicate that they must have had 2+ of the drug (ever or in the month being looked at if it is a graph).  This can have unexpected consequences if you have a pivot and axis
            etc since the having will apply only to the specific bucket (date section and pivot value) being evaluated at each step.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.RootFilterContainer_ID">
            <summary>
            ID of the AND/OR container of filters (which might be empty) that will restrict the records matched by the AggregateConfiguration GROUP by.  All filters/containers will
            be processed recursively and built up into appropriate WHERE sql at query building time.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.OverrideFiltersByUsingParentAggregateConfigurationInstead_ID">
            <summary>
            Specify instead of RootFilterContainer_ID to indicate that this AggregateConfiguration should instead use the filters of a different AggregateConfiguration.  This is 
            generally only useful if you have an AggregateConfiguration which you are using in cohort generation (e.g. prescriptions for drug x) and you want to generate another 
            AggregateConfiguration which is a graph of those results by year and you don't want to duplicate the filter configuration.  
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.IsDisabled">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.Catalogue">
            <summary>
            Fetches the Catalogue referenced by Catalogue_ID
            <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.Catalogue_ID"/>
             </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.RootFilterContainer">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.RootFilterContainer_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.Parameters">
            <summary>
            Gets all parameters (e.g. @studyStartDate ) associated with this AggregateConfiguration (there might not be any).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.GetAllParameters">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.Parameters"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.ForcedJoins">
            <summary>
            An AggregateConfiguration is a Group By statement.  This will involve using at least one Table in the FROM section of the query.  The descision on which tables
            to join is made by the AggregateBuilder based on the AggregateDimensions (columns).  If there are no column mapped AggregateDimensions (e.g. there is only a count(*))
            or there are other tables you want joined in addition the user can specify them in this property Populated via <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateForcedJoin"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.PatientIndexJoinablesUsed">
            <summary>
            When an AggregateConfiguration is used in a cohort identification capacity it can have one or more 'patient index tables' defined e.g. 
            'Give me all prescriptions for morphine' (Prescribing) 'within 6 months of patient being discharged from hospital' (SMR01).  In this case
            a join is done against the secondary dataset. 
            
            <para>This property returns all such 'patient index table' AggregateConfigurations which are currently being used by this AggregateConfiguration
            for building it's join.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.JoinableCohortAggregateConfiguration">
            <summary>
            Only populated if the AggregateConfiguration is acting as a patient index table.  Returns the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.JoinableCohortAggregateConfiguration"/> object
            which makes this a fact.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.AggregateDimensions">
            <summary>
            An AggregateConfiguration is a Group By statement.  This will return all the SELECT columns for the query (including any count(*) / sum(*) etc columns).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.PivotDimension">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.PivotOnDimensionID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.OverrideFiltersByUsingParentAggregateConfigurationInstead">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.OverrideFiltersByUsingParentAggregateConfigurationInstead_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.Order">
            <summary>
            Only relevant for AggregateConfigurations that are being used in a cohort identification capacity (See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.IsCohortIdentificationAggregate"/>).
            
            <para>The order location of an AggregateConfiguration within it's parent <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer"/> (if it has one).  This is mostly irrelevant for UNION /
            INTERSECT operations (other than helping the user viewing the system) but is vital for EXCEPT containers where the first AggregateConfiguration in the container is
            run producing a dataset and all subsequent AggregateConfigurations are then removed from that patient set.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.IsCohortIdentificationAggregate">
            <summary>
            True if the AggregateConfiguration is part of a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> and is intended to produce list of patient identifiers (optionally
            with other data if it is a 'patient index table'.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.ICatalogue,System.String)">
            <summary>
            Creates a new AggregateConfiguration (graph, cohort set or patient index table) in the ICatalogueRepository
            . database associated with the provided Catalogue (dataset).
            </summary>
            <param name="repository"></param>
            <param name="catalogue"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.ReFetchOrder">
            <summary>
            Updates <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.Order"/> from the database
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration)">
            <summary>
            All AggregateConfigurations have the potential a'Joinable Patient Index Table' (see AggregateConfiguration class documentation).  This method injects
            what fact that the AggregateConfiguration is definetly one by passing the JoinableCohortAggregateConfiguration that makes it one.  Pass null in to 
            indicate that the AggregateConfiguration is definetly NOT ONE.  See also the method <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.IsJoinablePatientIndexTable"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.ToString">
            <summary>
            Returns the Name.  If the AggregateConfiguration is a cohort identification aggregate (distinguished by <see cref="F:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.CICPrefix"/>)
            then the prefix is removed from the return value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.GetQuerySyntaxHelper">
            <summary>
            Gets an IQuerySyntaxHelper from the Catalogue powering this AggregateConfiguration (<see cref="M:FAnsi.Discovery.QuerySyntax.IHasQuerySyntaxHelper.GetQuerySyntaxHelper"/>)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.AddDimension(Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation)">
            <summary>
            Specifies that that given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> should become a new SELECT column in the GROUP BY of this AggregateConfiguration.  This
            column will also appear in the ORDER BY and GROUP BY sections of the query when built by <see cref="T:Rdmp.Core.QueryBuilding.AggregateBuilder"/>.  Finally if the column comes 
            from a novel underlying TableInfo then that new table will also be included in the FROM section of the query (e.g. with a join).
            </summary>
            <param name="basedOnColumn"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.GetQueryBuilder(System.Nullable{System.Int32})">
            <summary>
            Sets up a new <see cref="T:Rdmp.Core.QueryBuilding.AggregateBuilder"/> with all the columns (See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.AggregateDimensions"/>), WHERE logic (See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.RootFilterContainer"/>, Pivot
            etc.
            </summary>
            <remarks>Note that some elements e.g. axis are automatically handles at query generation time and therefore do not have to be injected into the <see cref="T:Rdmp.Core.QueryBuilding.AggregateBuilder"/></remarks>
            <param name="topX">Maximum number of rows to return, the proper way to do this is via <see cref="T:Rdmp.Core.CatalogueLibrary.Data.AggregateTopX"/></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.GetAxisIfAny">
            <summary>
            If an AggregateConfiguration is set up as a graph (i.e. it isn't a cohort identification set) then it can have a single <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension"/> defined
            as an axis dimension (e.g. DatePrescribed).  This method returns the  <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis"/> if there is one or null if there isn't one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.GetTopXIfAny">
            <summary>
            Returns the AggregateTopX defined for limiting the number of rows returned by the AggregateConfiguration or null if there isn't one defined.  This is only applicable
            on non cohort identification AggregateConfigurations
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.IsAcceptableAsCohortGenerationSource(System.String@)">
            <summary>
            Determines whether the AggregateConfiguration could be used in a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> to identify a list of patients.  This will be true
            if there are no pivot/axis dimensions and one of the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.AggregateDimensions"/> is marked <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.IsExtractionIdentifier"/>
            </summary>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the AggregateConfiguration can be resolved into a runnable SQL quer <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.GetQueryBuilder(System.Nullable{System.Int32})"/>
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.GetCohortAggregateContainerIfAny">
            <summary>
            If the AggregateConfiguration is set up as a cohort identification set in a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> then this method will return the set container
            (e.g. UNION / INTERSECT / EXCEPT) that it is in.  Returns null if it is not in a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.IsJoinablePatientIndexTable">
            <summary>
            All AggregateConfigurations have the potential a'Joinable Patient Index Table' (see AggregateConfiguration class documentation).  This method returns
            true if there is an associated JoinableCohortAggregateConfiguration that would make an ordinary AggregateConfiguration into a 'Patient Index Table'.
            </summary>
            <returns>true if the AggregateConfiguration is part of a cic fulfilling the role of 'Patient Index Table' as defined by the existence of a 
             JoinableCohortAggregateConfiguration object</returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.GetCohortIdentificationConfigurationIfAny">
            <summary>
            If the AggregateConfiguration is set up as a cohort identification set or patient index table then this method will return the associated 
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> that it is a part of.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.CreateClone">
            <summary>
            Creates a complete clone copy of the current AggregateConfiguration.  The clone will include all new AggregateDimensions, IFilters, IContainers etc.
            IMPORTANT: This method is designed for cohort identifying AggregateConfigurations only and therefore does not support Axis / TopX / Pivot.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.SetKnownOrder(System.Int32)">
            <summary>
            Using the set; on Order property changes the Order. if you want to informt his object of it's Order because you already know what it is but this object doesn't know yet
            then you can use this method to force a specific known order onto the object in memory.
            </summary>
            <param name="currentOrder"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.DeleteInDatabase">
            <summary>
            Deletes the AggregateConfiguration.  This includes removing it from it's <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer"/> if it is part of one.  Also includes deleting it's 
            <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.JoinableCohortAggregateConfiguration"/> if it is a 'patient index table'.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if the AggregateConfiguration is a patient index table that is being used by other AggregateConfigurations</exception>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.WhatIsThis">
            <summary>
            Returns a description of the role of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> based on whether it is set up as a cohort, patient index table or cohort identification aggregate.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis">
            <summary>
            Each AggregateConfiguration graph can have a single AggregateDimension defined as a date axis, this specifies the start/end and increment of the aggregate e.g.
            PrescribedDate dimension may have an axis defining it as running from 2001-2009 in increments of 1 month.  
            
            <para>For this to work the AggregateDimension output data should be of type a date also.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.AggregateDimension_ID">
            <summary>
            The column (<see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.AggregateDimension"/> in the AggregateConfiguration which this axis is defined on.  The AggregateContinuousDateAxis defines 
            the axis (e.g.  2001-01-01 to GetDate() by Month ) while the AggregateDimension_ID is the pointer to the column on which the axis applies within the
            query. 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.StartDate">
            <summary>
            The date or scalar function determining what date the graph axis should start at.  This could be as simple as '2001-01-01' or complex like dateadd(yy, -1, GetDate())
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.EndDate">
            <summary>
            The date or scalar function determining what date the graph axis should end at.  This could be as simple as '2001-01-01' or complex GetDate()
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.AxisIncrement">
            <summary>
            Defines the increment of the axis which will be continuous buckets between <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.StartDate"/> and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.EndDate"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.AggregateDimension">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.AggregateDimension_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension)">
            <summary>
            Defines that the specified column (<see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.AggregateDimension"/>) should function as the continuous axis of an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> graph. 
            For example if you are graphing the number of prescriptions given out each month then the axis would be applied to the 'PrescribedDate' <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.AggregateDimension"/>
             </summary>
            <remarks>To use this you will first have to create an AggregateConfiguration and setup the count(*)/sum(*) etc stuff and then add a new AggregateDimension <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.AddDimension(Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation)"/> </remarks>
            <param name="repository"></param>
            <param name="dimension"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.Data.Common.DbDataReader)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension">
            <summary>
            This class allows you to associate a specific extractioninformation for use in aggregate generation.  For example a dataset might have a date field AdmissionDate which you
            want to create an aggregate configuration (when patients were admitted) over time.  However the class also allows you to specify new SelectSQL which can change how the field
            is extracted e.g. you might want to change "[MyDatabase].[MyTable].[AdmissionDate]" into "YEAR([MyDatabase].[MyTable].[AdmissionDate]) as AdmissionDate" 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateConfiguration_ID">
            <summary>
            An <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension"/> is a column in the SELECT, GROUP BY and ORDER BY sections of an <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateConfiguration"/>.  This property returns
            the ID of the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateConfiguration"/> that this column is declared on.  
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.ExtractionInformation_ID">
            <summary>
            An <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension"/> is a column in the SELECT, GROUP BY and/or ORDER BY sections of an <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateConfiguration"/>.  The column must have
            come from an extractable column in the parent <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>.  The Catalogue column definition is an <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.ExtractionInformation"/> and documents the
            master SELECT Sql (which can be overriden in the current AggregateDimension) as well as what the underlying <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.ColumnInfo"/> / <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/>. 
            
            <para>This property is the ID of the associated Catalogue master <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.ExtractionInformation"/>.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.Alias">
            <summary>
            Specifies the column alias section of the SELECT statement.  When building the query (See AggregateBuilder) the Alias will be added in the SELECT section
            of the query generated e.g. if the Alias is 'Bob' and the SelectSQL is 'GetDate()' then the resultant line of SELECT in the query will be 'GetDate() as Bob'.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.SelectSQL">
            <summary>
            An <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension"/> is a column in the SELECT, GROUP BY and/or ORDER BY sections of an <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateConfiguration"/>.  This property defines
            the Sql that should appear in SELECT, GROUP BY and/or ORDER BY sections of the query when it is built by the AggregateBuilder.  This will start out
            with the exact same string as the parent <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.ExtractionInformation_ID"/> but can be changed as needed e.g. wrapping in UPPER.  If you change the SelectSQL
            to a scalar function you should add an <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.Alias"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.Order">
            <summary>
            An <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension"/> is a column in the SELECT, GROUP BY and/or ORDER BY sections of an <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateConfiguration"/>.  The Order property determines
            where in the SELECT, GROUP BY and/or ORDER BY list the current <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension"/> will appear relative to the other AggregateDimensions in the
             <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateConfiguration"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.HashOnDataRelease">
            <inheritdoc cref="P:Rdmp.Core.QueryBuilding.IColumn.HashOnDataRelease"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.IsExtractionIdentifier">
            <inheritdoc cref="P:Rdmp.Core.QueryBuilding.IColumn.IsExtractionIdentifier"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.IsPrimaryKey">
            <inheritdoc cref="P:Rdmp.Core.QueryBuilding.IColumn.IsPrimaryKey"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.ColumnInfo">
            <inheritdoc cref="P:Rdmp.Core.QueryBuilding.IColumn.ColumnInfo"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateContinuousDateAxis">
            <summary>
            An <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateConfiguration"/> can have a single <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateContinuousDateAxis"/> declared on it (if it is not functioning in a cohort identification
            capacity).  This property will return the axis if this AggregateDimension has one declared on it.
            </summary>
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis.AggregateDimension_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.ExtractionInformation">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.ExtractionInformation_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateConfiguration">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateConfiguration_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Declares a new column in an <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.AggregateConfiguration"/> (GROUP BY query).  The new column will be based on the master Catalogue column
            (<see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.ExtractionInformation"/>).
            </summary>
            <param name="repository"></param>
            <param name="basedOnColumn"></param>
            <param name="configuration"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.GetRuntimeName">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <inheritdoc cref="T:Rdmp.Core.QueryBuilding.SyntaxChecking.ColumnSyntaxChecker"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter">
            <summary>
            Sometimes you want to restrict the data that is Aggregated as part of an AggregateConfiguration.  E.g. you might want to only aggregate records loaded
            in the last 6 months.  To do this you would need to set a root AggregateFilterContainer on the AggregateConfiguration and then put in an appropriate
            AggregateFilter.  Each AggregateFilter can be associated with a given ColumnInfo this will ensure that it is included when it comes to JoinInfo time
            in QueryBuilding even if it is not a selected dimension (this allows you to for example aggregate the drug codes but filter by drug prescribed date even
            when the two fields are in different tables - that will be joined at Query Time).
            
            <para>Each AggregateFilter can have a collection of AggregateFilterParameters which store SQL paramater values (along with descriptions for the user) that let you
            paramaterise (for the user) your AggregateFilter</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.ClonedFromExtractionFilter_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.FilterContainer_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.AssociatedColumnInfo_ID">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.IsDisabled">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.AggregateFilterParameters">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.GetAllParameters"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.GetAllParameters">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.FilterContainer">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterContainer)">
            <summary>
            Defines a new filter (line of WHERE SQL) in the specified AggregateFilterContainer (AND / OR).  Calling this constructor creates a new object in the database
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
            <param name="container"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.GetColumnInfoIfExists">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.GetFilterFactory">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.GetCatalogue">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Checks.ClonedFilterChecker"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.MakeIntoAnOrphan">
            <summary>
            Removes the AggregateFilter from any AggregateFilterContainer (AND/OR) that it might be a part of 
            effectively turning it into a disconnected orphan.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter.GetAggregate">
            <summary>
            Gets the parent <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> that this AggregateFilter is part of by ascending it's AggregateFilterContainer hierarchy.
            If the AggregateFilter is an orphan or one of the parental containers is an orphan then null will be returned.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterContainer">
            <summary>
            All AggregateFilters must be contained within an AggregateFilterContainer at Query Generation time.  This tells QueryBuilder how to use brackets and whether to AND / OR 
            the various filter lines.  The AggregateFilterContainer serves the same purpose as the FilterContainer in Data Export Manager but for AggregateConfigurations (GROUP BY queries)
            
            <para>FilterContainers are fully hierarchical and must be fetched from the database via recursion from the SubContainer table (AggregateFilterSubContainer). 
            The class deals with all this transparently via GetSubContainers.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterContainer.IsDisabled">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterContainer.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.FilterContainerOperation)">
            <summary>
            Creates a new IContainer in the dtabase for use with an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>
            </summary>
            <param name="repository"></param>
            <param name="operation"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterContainer.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterContainer.GetCatalogueIfAny">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterContainer.DeepCloneEntireTreeRecursivelyIncludingFilters">
            <summary>
            Creates a copy of the current AggregateFilterContainer including new copies of all subcontainers, filters (including those in subcontainers) and paramaters of those 
            filters.  This is a recursive operation that will clone the entire tree no matter how deep.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterContainer.GetAggregate">
            <summary>
            Returns the AggregateConfiguration for which this container is either the root container for or part of the root container subcontainer tree.
            Returns null if the container is somehow an orphan. 
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter">
            <summary>
            Each AggregateFilter can have 1 or more AggregateFilterParameters, these allows you to specify an SQL parameter that the user can adjust at runtime to change
            how a given filter works.  E.g. if you have a filter 'Prescribed after @startDate' you would have an AggregateFilterParameter called @startDate with an appropriate
            user friendly description.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.AggregateFilter_ID">
            <summary>
            The ID of the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.AggregateFilter"/> to which this parameter should be used with.  The filter should have a reference to the parameter name (e.g. @startDate)
            in it's WhereSQL.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.ParameterSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.Value">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.Comment">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.AggregateFilter">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.AggregateFilter_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.ParameterName">
            <summary>
            extracts the name ofthe parameter from the SQL
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter)">
            <summary>
            Declares a new parameter to be used by the specified AggregateFilter.  Use AggregateFilterFactory to call this 
            constructor.
            </summary>
            <param name="repository"></param>
            <param name="parameterSQL"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <inheritdoc cref="T:Rdmp.Core.QueryBuilding.SyntaxChecking.ParameterSyntaxChecker"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilterParameter.GetOwnerIfAny">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateForcedJoin.#ctor(Rdmp.Core.Repositories.CatalogueRepository)">
            <summary>
            Creates a new instance targetting the catalogue database referenced by the repository.  The instance can be used to populate / edit the AggregateForcedJoin in 
            the database.  Access via <see cref="P:Rdmp.Core.Repositories.CatalogueRepository.AggregateForcedJoinManager"/>
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateForcedJoin.GetAllForcedJoinsFor(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateForcedJoin.BreakLinkBetween(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateForcedJoin.CreateLinkBetween(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.IAggregateForcedJoinManager">
            <summary>
            Describes the requirement to include a given TableInfo in an AggregateConfiguration query even though the TableInfo is not the owner of any of the Columns in the
            query (the usual way of deciding which TableInfos to join).  This is needed if you want a count(*) for example in which both header and result records tables are
            joined together. 
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.IAggregateForcedJoinManager.GetAllForcedJoinsFor(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Returns all the TableInfos that the provided <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> has been explicitly requested (by the user) to join to in it's FROM section (See 
            <see cref="!:CatalogueLibrary.QueryBuilding.AggregateBuilder"/>. 
            
            <para>This set will be combined with those that would already be joined against because of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension"/> configured.  Note that your query results
            in multiple TableInfos being needed then you will still need to have defined a way for the TableInfos to be joined (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.JoinInfo"/>.</para>
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.IAggregateForcedJoinManager.BreakLinkBetween(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <summary>
            Deletes the mandate that the provided AggregateConfiguration should always join with the specified TableInfo regardless of what <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension"/> are
            configured.  This will have no effect if there was no forced join declared in the first place.
            </summary>
            <param name="configuration"></param>
            <param name="tableInfo"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.IAggregateForcedJoinManager.CreateLinkBetween(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <summary>
            Creates the mandate that the provided AggregateConfiguration should always join with the specified TableInfo regardless of what <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension"/> are
            configured (See <see cref="!:CatalogueLibrary.QueryBuilding.AggregateBuilder"/>. 
            
            <para>Note that your query results in multiple TableInfos being needed then you will still need to have defined a way for the TableInfos to be joined (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.JoinInfo"/>.</para>
            </summary>
            <seealso cref="M:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateForcedJoin.GetAllForcedJoinsFor(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)"/>
            <param name="configuration"></param>
            <param name="tableInfo"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheFetchFailure">
            <summary>
            Describes a failed attempt to contact a caching service including the time it occurred and any associated Exception as well as whether it has been 
            resolved.  Any object of type ICacheFetchRequest (with paired Exception) can be used to create a failure record.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheFetchFailure.CacheProgress_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheFetchFailure.FetchRequestStart">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheFetchFailure.FetchRequestEnd">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.FetchRequestStart"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheFetchFailure.ExceptionText">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheFetchFailure.LastAttempt">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheFetchFailure.ResolvedOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheFetchFailure.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress,System.DateTime,System.DateTime,System.Exception)">
            <summary>
            Documents that a given cache fetch request was not succesfully executed e.g. the remote endpoint returned an error for that date range.
            </summary>
            <param name="repository"></param>
            <param name="cacheProgress"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="e"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheFetchFailure.Resolve">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod">
            <summary>
            Describes the period of time for which data should not be fetched during caching (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress"/>) in Months/Days.  This allows for the fact that
            data in the remote server is unlikley to be real time up to the second accurate and you might need to delay requesting data until it has been collected.
             
            <para>Serialises to/from simple string representation of duration + type, where type is month (m) or day (d)</para>
            </summary>
            <remarks>Created this because TimeSpans can't handle months and I didn't want to go to the hassle of importing an entire library such as NodaTime just to be able to deal with months</remarks>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.PeriodType">
            <summary>
            Is the lag period measured in months or days
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.PeriodType.Month">
            <summary>
            Specifies that the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Duration"/> is a count of Months
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.PeriodType.Day">
            <summary>
            Specifies that the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Duration"/> is a count of Days
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Duration">
            <summary>
            The number of Days/Months etc (See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Type"/>) to wait before the associated CacheProgress should be run.  This specifies a window of time
            measured from the present not to load e.g. 'do not load any data if it is newer than 3 months since the remote endpoint data source is still volatile
            in this range'.
            
            <para>Use this when your remote endpoint to which you make Cache fetch requests is not a realtime system in which records are instantly available and
            utterly immutable</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Type">
            <summary>
            Indicates which interval type (Days / Months etc) <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Duration"/> is measured in.
            </summary>
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Duration"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Months">
            <summary>
            Returns the Months component represented by this period, note that if period is 2 Months then Days will still be 0
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Days">
            <summary>
            Returns the Days component represented by this period, note that if period is 2 Months then Days will be 0, therefore you should only use this property in conjunction with Months
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Zero">
            <summary>
            Define a Zero length CacheLagPeriod i.e. the remote end point from which caching happens is real time up to the millisecond so you can always issue a cache fetch 
            request for data up to DateTime.Now (obviously you can't request future data).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.#ctor(System.String)">
            <summary>
            Deserializes a <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.CacheLagPeriodLoadDelay"/> string into an instance of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod"/>
            </summary>
            <param name="cacheLagPeriod"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.#ctor(System.Int32,Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.PeriodType)">
            <summary>
            Defines a new lag period of the specified number of Months/Days etc
            </summary>
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Duration"/>
            <param name="duration"></param>
            <param name="type"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.ToString">
            <summary>
            String representation of the CacheLagPeriod.  This should be a valid serialization such that it can be loaded by the internal constructor.
            </summary>
            <remarks>Do not change this without good reason because it's implementation is tied to the internal constructor</remarks>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.CalculateStartOfLagPeriodFrom(System.DateTime)">
            <summary>
            Adds the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Duration"/> to the specified DateTime.  Use this to decide whether the lag time is up or not
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.TimeIsWithinPeriod(System.DateTime)">
            <summary>
            Pass the date you are about to create a cache fetch request for.  Returns true if the date is outside (i.e. older than) the lag period.  E.g. if you have a lag period of 
            6 months then any date before 6 months is valid for fetching since the remote endpoint is likely to have had it's data stabalised.
            </summary>
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Duration"/>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.op_LessThan(System.TimeSpan,Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod)">
            <summary>
            Allows comparing a TimeSpan with a CacheLagPeriod.  This treats the Timespan as an offset equivalent to <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Duration"/>
            </summary>
            <param name="timespan"></param>
            <param name="lagPeriod"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.op_GreaterThan(System.TimeSpan,Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod)">
            <summary>
            Allows comparing a TimeSpan with a CacheLagPeriod.  This treats the Timespan as an offset equivalent to <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod.Duration"/>
            </summary>
            <param name="timespan"></param>
            <param name="lagPeriod"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress">
            <summary>
            Records the progress of fetching and caching data from a remote source e.g. a Webservice or Imaging file host.  Each CacheProgress
            is tied to a LoadProgress (which itself is tied to a LoadMetadata).  
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.LoadProgress_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.PermissionWindow_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.CacheFillProgress">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.CacheLagPeriod">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.Pipeline_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.ChunkPeriod">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.CacheLagPeriodLoadDelay">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.CacheFetchFailures">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.LoadProgress">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.LoadProgress_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.Pipeline">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.Pipeline_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.PermissionWindow">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.PermissionWindow_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.GetCacheLagPeriod">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheLagPeriod"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.GetCacheLagPeriodLoadDelay">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheLagPeriodLoadDelay"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.SetCacheLagPeriod(Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod)">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheLagPeriod"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.SetCacheLagPeriodLoadDelay(Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod)">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheLagPeriodLoadDelay"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.ILoadProgress)">
            <summary>
            Defines that the given <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.LoadProgress"/> is a DLE data load that is driven by reading data from a cache.  The instance created can be used
            to describe which pipeline should be run to fill that cache, the period that has been fetched from the remote endpoint so far etc.
            </summary>
            <param name="repository"></param>
            <param name="loadProgress"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.FetchPage(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.GetShortfall">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.GetAllCataloguesMaximisingOnPermissionWindow">
            <summary>
            Returns all the Catalogues in this caches LoadMetadata OR if it has a PermissionWindow then ALL the unique catalogues across ALL the LoadMetadatas of ANY cache that uses the same permission window
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure">
            <summary>
            See CacheFetchFailure
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.CacheProgress_ID">
            <summary>
            The ID of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress"/> that was being executed when the fetch error occured.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.FetchRequestStart">
            <summary>
            The time in 'dataset time' for which the request errored.  For example if the cache fetch request was for 10:00am - 11:00am on 2001-01-01 then the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.FetchRequestStart"/>
            would be 10:00 2001-01-01 and the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.FetchRequestEnd"/> would be 11:00 2001-01-01.  This has no bearing on the time the process was running at or the time
            it errored, it is the period of dataset time that we were attempting to fetch from the remote endpoint
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.FetchRequestEnd">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.FetchRequestStart"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.ExceptionText">
            <summary>
            The Exception resulted from the cache fetch request which documents what went wrong (e.g. 404 file not found, invalid credentials etc)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.LastAttempt">
            <summary>
            The realtime date that this request was last attempted
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.ResolvedOn">
            <summary>
            The date at which we were able to make a succesful request for the time period defined by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.FetchRequestStart"/> and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.FetchRequestEnd"/>.  If this
            date is populated then it means that although we were unable to fetch the period when we first requested it we were subsequently able to rerun that period and the 
            remote endpoint was succesfully able to return to us the results
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.Resolve">
            <summary>
            Marks that we were able to succesfully rerun this request window
            </summary>
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheFetchFailure.ResolvedOn"/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheLagPeriodLoadDelay">
            <summary>
            <para>The amount of time that has to have passed beyond the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheLagPeriod"/> before a fetch will be initiated.</para>
            
            <para>Stored as string in DB, use GetCacheLagPeriod() to get as CacheLagPeriod</para> 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.LoadProgress_ID">
            <summary>
            The LoadProgress which is responsible for loading data from this cache.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.PermissionWindow_ID">
            <summary>
            When we can run the cache (e.g. evenings only).  Also serves as the locking object for preventing multiple caching engines/automation servers from executing
            caching activities belonging to the same window.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheFillProgress">
            <summary>
            How far through the caching activity are we? files up to this date should be on disk in archives
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheLagPeriod">
            <summary>
            The period of time e.g. 1m that is never fetched expressed as an offset from DateTime.Now.  This handles the case where the cache source
            is not real time i.e. we expect it to take at least 1 month for data to appear on the cache endpoint so don't make requests for data that would
            originate very recently.  
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.ChunkPeriod">
            <summary>
            The amount of time to request at a time from the cache source e.g. (fetch 6 hours of data at a time).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.Pipeline_ID">
            <summary>
            The pipeline configuration responsible for populating the cache.  This will be run repeatedly for each date range fetched (See CachingEngine.Factories.CachingPipelineUseCase)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.Pipeline">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.Pipeline_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.PermissionWindow">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.PermissionWindow_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheFetchFailures">
            <summary>
            Returns all failed cache requests documented.  This is an array of dates that were requested of the caching endpoint but were no data was available due
            to the endpoint reporting an Exception at the time it was requested. 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.LoadProgress">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.LoadProgress_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.GetCacheLagPeriod">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheLagPeriod"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.SetCacheLagPeriod(Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod)">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheLagPeriod"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.GetCacheLagPeriodLoadDelay">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheLagPeriodLoadDelay"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.SetCacheLagPeriodLoadDelay(Rdmp.Core.CatalogueLibrary.Data.Cache.CacheLagPeriod)">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.CacheLagPeriodLoadDelay"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.FetchPage(System.Int32,System.Int32)">
            <summary>
            Returns a subset of CacheFetchFailures between the start and batch size.  Should return only unresolved 
            failures.
            <para>This differs from CacheFetchFailures since it ignores resolved failures and only returns 're-runnable' ICacheFetchFailures</para>
            </summary>
            <param name="start"></param>
            <param name="batchSize"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress.GetShortfall">
            <summary>
            Returns the maximum amount of time that could be loaded from this cache (based on the origin date of the dataset or the max date of current data cached) and todays date (offset by lag period)
            e.g. if the data has been cached to 2016-01-01 and todays date is 2016-01-05 then the TimeSpan will be +4 days.  A Negative shortfall indicates that it has overcached ahead of the lag period or
            it has cached future data (as in data from the future!).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.ICatalogue"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Acronym">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Name">
            <summary>
            The full human readable name of the dataset.  This should usually match the name of the underlying <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> but might differ
            if there are multiple tables powering the Catalogue or they don't have user accessible names.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Folder">
            <summary>
            A user defined hierarchical category which designates the role of the dataset e.g. '\datasets\extractable\labdata\'
            <para>Should always start and end with a '\' even if it is the root (i.e. '\')</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Description">
            <summary>
            Human readable description provided by the RDMP user that describes what the dataset contains.  
            <para>This can be multiple paragraphs.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Detail_Page_URL">
            <summary>
            User defined Uri for a website page which describes the dataset (probably null)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Type">
            <summary>
            User defined classification of the Type of dataset the Catalogue is e.g. Cohort, ResearchStudy etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Periodicity">
            <summary>
            User specified period on how regularly the dataset is updated.  This does not have any technical bearing on how often it is loaded
            and might be an outright lie.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Granularity">
            <summary>
            User specified field describing how the dataset is subdivided/bounded e.g. relates to a multiple 'HealthBoards' / 'Clinics' / 'Hosptials' etc.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Geographical_coverage">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Background_summary">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Search_keywords">
            <summary>
            User specified list of keywords that are intended to help in finding the Catalogue
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Update_freq">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Periodicity"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Update_sched">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Periodicity"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Time_coverage">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Periodicity"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Last_revision_date">
            <summary>
            User specified date that user alledgedly reviewed the contents of the Catalogue / Metadata
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Contact_details">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Resource_owner">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Attribution_citation">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Access_options">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.SubjectNumbers">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.API_access_URL">
            <summary>
            User specified field.  Supposedly a URL for a webservice for accessing the dataset? Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Browse_URL">
            <summary>
            User specified field.  Supposedly a URL for a webservice for browsing the dataset? Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Bulk_Download_URL">
            <summary>
            User specified field.  Supposedly a URL for a webservice for bulk downloading the dataset? Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Query_tool_URL">
            <summary>
            User specified field.  Supposedly a URL for a webservice for querying the dataset? Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Source_URL">
            <summary>
            User specified field.  Supposedly a URL for a website describing where you procured the data from? Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Country_of_origin">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Data_standards">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Administrative_contact_name">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Administrative_contact_email">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Administrative_contact_telephone">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Administrative_contact_address">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Explicit_consent">
            <summary>
            User specified field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Ethics_approver">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Source_of_data_collection">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Ticket">
            <summary>
            Identifier for a ticket in your <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/> for documenting / auditing work on the Catalogue and for 
            recording issues (if you are not using the RDMP issue system (See <see cref="!:CatalogueItemIssue"/>))
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.LoggingDataTask">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.ValidatorXML">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.TimeCoverage_ExtractionInformation_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.PivotCategory_ExtractionInformation_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.IsDeprecated">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.IsInternalDataset">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.IsColdStorageDataset">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.LiveLoggingServer_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.DatasetStartDate">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.LoadMetadata_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueItems">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.LoadMetadata">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.AggregateConfigurations">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.LiveLoggingServer">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.TimeCoverage_ExtractionInformation">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.PivotCategory_ExtractionInformation">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueType">
            <summary>
            Somewhat arbitrary concepts for defining the limitations of a Catalogues data
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueType.Unknown">
            <summary>
            No CatalogueType has been specified
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueType.ResearchStudy">
            <summary>
            Catalogue data relates to a research study
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueType.Cohort">
            <summary>
            Catalogue data relates to or defines a Cohort
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueType.NationalRegistry">
            <summary>
            Catalogue data is collected by a national registry
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueType.HealthcareProviderRegistry">
            <summary>
            Catalogue data is collected by a healthcare provider
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueType.EHRExtract">
            <summary>
            Catalogue data can be classified as Electronic Health Records (prescriptions, hospital records etc.)
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CataloguePeriodicity">
            <summary>
            Notional user declared period on which the data in the Catalogue is refreshed.  This may not have any bearing
            on reality.  Not used by RDMP for any technical processes.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CataloguePeriodicity.Unknown">
            <summary>
            No period for the dataset has been specified
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CataloguePeriodicity.Daily">
            <summary>
            Data is updated on a daily basis
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CataloguePeriodicity.Weekly">
            <summary>
            Data is updated on a weekly basis
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CataloguePeriodicity.Fortnightly">
            <summary>
            Data is updated every 2 weeks
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CataloguePeriodicity.Monthly">
            <summary>
            Data is updated every month
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CataloguePeriodicity.BiMonthly">
            <summary>
            Data is updated every 2 months
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CataloguePeriodicity.Quarterly">
            <summary>
            Data is updated every 4 months
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CataloguePeriodicity.Yearly">
            <summary>
            Data is updated on a yearly basis
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueGranularity">
            <summary>
            Notional user declared boundary for the dataset defined by the Catalogue.  The data should be isolated to this Granularity
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueGranularity.Unknown">
            <summary>
            No granularity has been specified
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueGranularity.National">
            <summary>
            Contains data relating to multiple nations
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueGranularity.Regional">
            <summary>
            Contains data relating to multiple regions (e.g. Scotland / England)
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueGranularity.HealthBoard">
            <summary>
            Contains data relating to multiple healthboards (e.g. Tayside / Fife)
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueGranularity.Hospital">
            <summary>
            Contains data relating to multiple hospitals (e.g. Ninewells)
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CatalogueGranularity.Clinic">
            <summary>
            Contains data relating to multiple clinics (e.g. Radiology)
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String)">
            <summary>
            Declares a new empty virtual dataset with the given Name.  This will not have any virtual columns and will not be tied to any underlying tables.  
            
            <para>The preferred method of getting a Catalogue is to use <see cref="T:Rdmp.Core.CatalogueLibrary.DataHelper.TableInfoImporter"/> and <see cref="T:Rdmp.Core.CatalogueLibrary.ForwardEngineerCatalogue"/></para>
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.Data.Common.DbDataReader)">
            <summary>
            Creates a single runtime instance of the Catalogue based on the current state of the row read from the DbDataReader (does not advance the reader)
            </summary>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.CompareTo(System.Object)">
            <summary>
            Sorts alphabetically based on <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Name"/>
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the Catalogue has a sensible Name (See <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.IsAcceptableName(System.String)"/>).  Then checks that there are no missing ColumnInfos 
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetTableInfoList(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetLookupTableInfoList">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetTableInfos(System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.ITableInfo}@,System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.ITableInfo}@)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetAllMandatoryFilters">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetAllFilters">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetDistinctLiveDatabaseServer(ReusableLibraryCode.DataAccess.DataAccessContext,System.Boolean,ReusableLibraryCode.DataAccess.IDataAccessPoint@)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetDistinctLiveDatabaseServer(ReusableLibraryCode.DataAccess.DataAccessContext,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetDistinctLiveDatabaseServerType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.HardDisassociateLoadMetadata">
            <summary>
            Use to set LoadMetadata to null without first performing Disassociation checks.  This should only be used for in-memory operations such as cloning
            This (if saved to the original database it was read from) could create orphans - load stages that relate to the disassociated catalogue.  But if 
            you are cloning a catalogue and dropping the LoadMetadata then you wont be saving the dropped state to the original database ( you will be saving it
            to the clone database so it won't be a problem).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetLogManager">
            <summary>
            Gets the <see cref="T:Rdmp.Core.Logging.LogManager"/> for logging load events related to this Catalogue / it's LoadMetadata (if it has one).  This will throw if no
            logging server has been configured.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetAllSupportingDocuments(Rdmp.Core.CatalogueLibrary.Data.FetchOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetAllSupportingSQLTablesForCatalogue(Rdmp.Core.CatalogueLibrary.Data.FetchOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetAllExtractionInformation(Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.CatalogueExtractabilityStatus)">
            <summary>
            Records the known extractability status (as a cached answer for <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetExtractabilityStatus(Rdmp.Core.Repositories.IDataExportRepository)"/>)
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.CatalogueItem[])">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.ClearAllInjections">
            <summary>
            Cleares the cached answer of <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetExtractabilityStatus(Rdmp.Core.Repositories.IDataExportRepository)"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetExtractabilityStatus(Rdmp.Core.Repositories.IDataExportRepository)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.IsProjectSpecific(Rdmp.Core.Repositories.IDataExportRepository)">
            <summary>
            Returns true if the Catalogue is extractable but only with a specific Project.  You can pass null if you are addressing a Catalouge for whom you know 
            IInjectKnown&lt;CatalogueExtractabilityStatus> has been called already.
            </summary>
            <param name="dataExportRepository"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetQuerySyntaxHelper">
            <summary>
            Gets an IQuerySyntaxHelper for the <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetDistinctLiveDatabaseServerType"/> amongst all underlying <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/>.  This can be used to assist query building.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.IsAcceptableName(System.String,System.String@)">
            <summary>
            Returns true if the given name would be sensible for a Catalogue.  This means no slashes, hashes @ symbols etc and other things which make XML serialization hard
            or prevent naming a database table after a Catalogue (all things we might want to do with the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Name"/>).
            </summary>
            <param name="name"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.IsAcceptableName(System.String)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.IsAcceptableName(System.String,System.String@)"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.ShallowClone">
            <summary>
            Provides a new instance of the object (in the database).  Properties will be copied from this object (child objects will not be created).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueExtractabilityStatus">
            <summary>
            <para>Describes whether a Catalogue can be extracted in data export projects and if so, whether it is only permitted in a single Project.</para>
            
            <para>See <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Catalogue.GetExtractabilityStatus(Rdmp.Core.Repositories.IDataExportRepository)"/></para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueExtractabilityStatus.IsExtractable">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> is extractable as an ExtractableDataSet in data export database
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueExtractabilityStatus.IsProjectSpecific">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> is extractable as an ExtractableDataSet in data export dabase but only for use in a single
            Project.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueExtractabilityStatus.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Creates a new confirmed extractability knowledge for a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>
            </summary>
            <param name="isExtractable"></param>
            <param name="isProjectSpecific"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder">
            <summary>
            The virtual 'folder' in which to display Catalogues.  This should be a helpful subdivision e.g. "\core datasets\labsystems\"
             
            <para>CatalogueFolder are represented in the user interface as a tree of folders (calculated at runtime). You can't create an empty CatalogueFolder,
            just declare a Catalogue as being in a new folder and it will be automatically shown.</para>
            
            <para>CatalogueFolder is persisted as a string but has methods to help prevent illegal paths and to calculate hierarchy based on multiple Catalogues 
            (See <see cref="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.GetImmediateSubFoldersUsing(System.Collections.Generic.IEnumerable{Rdmp.Core.CatalogueLibrary.Data.Catalogue})"/>)</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.Root">
            <summary>
            The topmost folder under which all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder"/> reside
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.Path">
            <summary>
            The full path of the folder (starts and ends with a slash).  Throws if you try to set property to an invalid path 
            <seealso cref="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.IsValidPath(System.String)"/> 
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.#ctor(Rdmp.Core.CatalogueLibrary.Data.Catalogue,System.String)">
            <summary>
            Creates a new folder that the Catalogue should now reside in.
            <para><remarks>After calling this you should use <code>parent.Folder = instance; parent.SaveToDatabase();</code></remarks></para>
            </summary>
            <param name="parent"></param>
            <param name="folder"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.IsValidPath(System.String)">
            <summary>
            Returns true if the specified path is valid for a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder"/>.  Not blank, starts with '\' etc.
            </summary>
            <param name="candidatePath"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.GetTypeCode">
            <summary>
            Makes this class behave as a string for IConvertible
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToBoolean(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToChar(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToSByte(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToByte(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToInt16(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToUInt16(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToInt32(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToUInt32(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToInt64(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToUInt64(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToSingle(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToDouble(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToDecimal(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToDateTime(System.IFormatProvider)">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToString(System.IFormatProvider)">
            <summary>
            Returns the Path
            </summary>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.ToType(System.Type,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.IsSubFolderOf(Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder)">
            <summary>
            Returns true if the passed value is resident in a subfolder of this one.
            </summary>
            <param name="potentialParent"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder.GetImmediateSubFoldersUsing(System.Collections.Generic.IEnumerable{Rdmp.Core.CatalogueLibrary.Data.Catalogue})">
            <summary>
            Returns the next level of folder down towards the Catalogues in collection - note that the next folder down might be empty 
            e.g.
            
            <para>Pass in 
            CatalogueA - \2005\Research\
            CatalogueB - \2006\Research\</para>
            
            <para>This is Root (\)
            Returns:
                \2005\ - empty 
                \2006\ - empty</para>
            
            <para>Pass in the SAME collection but call on This (\2005\)
            Returns :
            \2005\Research\ - containing CatalogueA</para>
            </summary>
            <param name="collection"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem">
            <summary>
            A virtual column that is made available to researchers.  Each Catalogue has 1 or more CatalogueItems, these contain the descriptions of what is contained
            in the column as well as any outstanding/resolved issues with the column (see CatalogueItemIssue).
            
            <para>It is important to note that CatalogueItems are not tied to underlying database tables/columns except via an ExtractionInformation.  This means that you can
            for example have multiple different versions of the same underlying ColumnInfo </para>
            
            <para>e.g.
            CatalogueItem: PatientDateOfBirth (ExtractionInformation verbatim but 'Special Approval Required')
            CatalogueItem: PatientDateOfBirthApprox (ExtractionInformation rounds to nearest quarter but governance is 'Core')</para>
            
            <para>Both the above would extract from the same ColumnInfo DateOfBirth</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue_ID">
            <summary>
            The ID of the parent <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue"/> (dataset) to which this is a virtual column/column description
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Statistical_cons">
            <summary>
            User supplied field meant to identify any statistical anomalies with the data in the column described.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Research_relevance">
            <summary>
            User supplied field meant for describing research applicability/field of the data in the column.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Description">
            <summary>
            User supplied description of what is in the column
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Topic">
            <summary>
            User supplied heading or keywords of what is in the column relates to.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Agg_method">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Limitations">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Comments">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ColumnInfo_ID">
            <summary>
            The ID of the underlying <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ColumnInfo"/> to which this CatalogueItem describes.  This can be null if the underlying column has been deleted / removed.
            You can have multiple <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/>s in a <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue"/> that share the same underlying <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ColumnInfo"/> if one of them is a transform
            e.g. you might release the first 3 digits of a postcode to anyone (<see cref="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.Core"/>) but only release the full postcode with 
            <see cref="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.SpecialApprovalRequired"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Periodicity">
            <summary>
            How frequently this column is updated... why this would be different from <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.Periodicity"/>?
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ExtractionInformation">
            <summary>
            Fetches the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ExtractionInformation"/> (if any) that specifies how to extract this column.  This can be the underlying column name (fully specified) or a transform.
            <para>This will be null if the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/> is not extractable</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ColumnInfo">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ColumnInfo_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.CatalogueName">
            <summary>
            Name of the parent <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue"/>.  This property value will be cached once fetched for a given object thanks to Lazy/IInjectKnown&lt;Catalogue&gt;"/>.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Catalogue,System.String)">
            <summary>
            Creates a new virtual column description for for a column in the dataset (<paramref name="parent"/>) supplied with the given Name.
            <para><remarks>You should next choose which <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ColumnInfo"/> powers it and optionally create an <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ExtractionInformation"/> to
            make the column extractable</remarks></para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.Catalogue)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.CompareTo(System.Object)">
            <summary>
            Sorts alphabetically by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Name"/>
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.CloneCatalogueItemWithIDIntoCatalogue(Rdmp.Core.CatalogueLibrary.Data.Catalogue)">
            <summary>
            Copies the descriptive metadata from one <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/> (this) into a new <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/> in the supplied <paramref name="cataToImportTo"/>
            </summary>
            <param name="cataToImportTo">The <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue"/> to import into (cannot be the current <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/> parent)</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.GuessAssociatedColumn(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo[],System.Boolean)">
            <summary>
            Guesses which <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ColumnInfo"/> from a collection is probably the right one for underlying this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/>.  This is done
            by looking for a <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.ColumnInfo"/> whose name is the same as the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Name"/> if not then it gets more flexible looking
            for .Contains etc.
            </summary>
            <param name="guessPool"></param>
            <param name="allowPartial">Set to false to avoid last-resort match based on String.Contains</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.SetColumnInfo(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo)">
            <summary>
            Changes the CatalogueItem in the database to be based off of the specified ColumnInfo (or none if null is specified).  This will
            likely result in the ExtractionInformation being corrupt / out of sync in terms of the SQL appearing in it's
            <see cref="P:Rdmp.Core.QueryBuilding.IColumn.SelectSQL"/>.
            </summary>
            <param name="columnInfo"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueObscureDependencyFinder">
            <summary>
            Handles rules for cascading/preventing deleting database objects which cannot be directly implemented by database constraints (e.g. foreign keys).  This includes
            things such as preventing deleting Catalogues which have been used in data extraction projects.  Use property OtherDependencyFinders to add new rules / logic for
            tailoring deleting.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueObscureDependencyFinder.#ctor(Rdmp.Core.Repositories.CatalogueRepository)">
            <summary>
            Sets the target upon which to apply delete/cascade obscure dependency rules
            </summary>
            <param name="repository"></param>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.CatalogueObscureDependencyFinder.OtherDependencyFinders">
            <summary>
            Plugin and supplemental child IObscureDependencyFinders
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueObscureDependencyFinder.ThrowIfDeleteDisallowed(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <inheritdoc/>
            <remarks>Consults each <see cref="F:Rdmp.Core.CatalogueLibrary.Data.CatalogueObscureDependencyFinder.OtherDependencyFinders"/> to see if deleting is disallowed</remarks>
            <param name="oTableWrapperObject"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueObscureDependencyFinder.HandleCascadeDeletesForDeletedObject(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <inheritdoc/>
            <remarks>Consults each <see cref="F:Rdmp.Core.CatalogueLibrary.Data.CatalogueObscureDependencyFinder.OtherDependencyFinders"/> for CASCADE logic then deletes any <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter"/> declared
            on the deleted object</remarks>
            <param name="oTableWrapperObject"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CatalogueObscureDependencyFinder.AddOtherDependencyFinderIfNotExists``1(Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator)">
            <summary>
            Adds a new instance of the supplied  <see cref="T:MapsDirectlyToDatabaseTable.IObscureDependencyFinder"/> to <see cref="F:Rdmp.Core.CatalogueLibrary.Data.CatalogueObscureDependencyFinder.OtherDependencyFinders"/> if it is a unique Type.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="repositoryLocator"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter">
            <summary>
            Allows you to override ALL instances of a given named parameter e.g. @studyStartDate in ALL AggregateFilterParameters in a given CohortIdentificationConfiguration
            with a single value.  This allows you to have multiple filters in different datasets that all use @studyStartDate parameter but override it globally for the configuration
            so that you don't have to manually update every parameter when you want to change your study criteria.  For this to work all AggregateFilterParameters must have the same name
            and datatype AND comment! as the study filters (see CohortQueryBuilder).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.ParameterSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.Value">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.Comment">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.ParameterName">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable,System.String)">
            <summary>
            Declares that a new <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> (e.g. 'DECLARE @bob as varchar(10)') exists for the parent database object.  The object
            should be of a type which passes <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.IsSupportedType(System.Type)"/>.  When the object is used for query generation by an <see cref="!:CatalogueLibrary.QueryBuilding.ISqlQueryBuilder"/>
            then the parameter will be used 
            </summary>
            <param name="repository"></param>
            <param name="parent"></param>
            <param name="parameterSQL"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <inheritdoc cref="T:Rdmp.Core.QueryBuilding.SyntaxChecking.ParameterSyntaxChecker"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.IsSupportedType(System.Type)">
            <summary>
            Returns true if the Type (which should implement <see cref="T:MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable"/>) is one which is designed to store it's <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/>
            in this table.  Only supported objects will have parameters sought here by <see cref="!:CatalogueLibrary.QueryBuilding.ISqlQueryBuilder"/>s.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <seealso cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.DescribeUseCaseForParent(System.Type)"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.DescribeUseCaseForParent(System.Type)">
            <summary>
            Describes how the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/>s declared in this table will be used with parents of the supplied Type (See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.ReferencedObjectType"/>).
            </summary>
            <param name="type"></param>
            <returns></returns>
            <seealso cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.IsSupportedType(System.Type)"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.GetOwnerIfAny">
            <summary>
            Returns the parent object that declares this paramter (see <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.ReferencedObjectID"/> and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.ReferencedObjectType"/>)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer">
            <summary>
            Cohort identification is achieved by identifying Sets of patients and performing set operations on them e.g. you might identify "all patients who have been prescribed Diazepam"
            and then EXCEPT "patients who have been prescribed Diazepam before 2000".  This is gives you DISTINCT patients who were FIRST prescribed Diazepam AFTER 2000.  A CohortAggregateContainer
            is a collection of sets (actually implemented as an AggregateConfiguration) (and optionally subcontainers) which are all separated with the given SetOperation.
            
            <para>There are three SET operations:</para>
            <para>UNION - Match all patients in any of the child containers/aggregates</para>
            <para>INTERSECT - Match patients only if they appear in ALL child containers/aggregates</para>
            <para>EXCEPT - Take patients in the first child container/aggregate and discard any appearing in subsequent child containers/aggregates</para>
            
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.Operation">
            <summary>
            Describes how patient identifier sets identified by children (subcontainers and <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>s) in this container are combined using
            SQL operations (UNION / INTERSECT / EXCEPT).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.Name">
            <inheritdoc/>
            <remarks>Starts out as simply the name of the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.Operation"/> but can be changed by the user e.g. 'EXCEPT - Study Exclusion Criteria
            <para>This property should always start with the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.Operation"/> to avoid confusion</para>
            </remarks>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.Order">
            <summary>
            The order within the parent <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer"/> (if it is not a Root level container / orphan).  Symantically this position is relevant only for
            the <see cref="F:Rdmp.Core.CatalogueLibrary.Data.Cohort.SetOperation.EXCEPT"/> which takes the first set and throws out all subsequent sets.
            <remarks>Also affects the order of IncludeCumulativeTotals</remarks>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.IsDisabled">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Cohort.SetOperation)">
            <summary>
            Creates a new container (which starts out as an oprhan) with the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.SetOperation"/>.  You should either set a
             <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.RootCohortAggregateContainer_ID"/> to this.<see cref="P:MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable.ID"/> to make this container the root container
            or use <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.AddChild(Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer)"/>  on another container to make this a subcontainer of it.
            </summary>
            <param name="repository"></param>
            <param name="operation"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetSubContainers">
            <summary>
            Gets all the subcontainers of the current container (if any)
            <para>You might want to instead use <seealso cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetOrderedContents"/></para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetParentContainerIfAny">
            <summary>
            Gets the parent container of the current container (if it is not a root / orphan container)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetAggregateConfigurations">
            <summary>
            Returns all the cohort identifier set queries (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>) declared as immediate children of the container.  These exist in 
            order defined by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.IOrderable.Order"/> and can be interspersed with subcontainers (<see cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetSubContainers"/>).
            <para>You might want to instead use <seealso cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetOrderedContents"/></para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.AddChild(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,System.Int32)">
            <summary>
            Makes the configuration a member of this container.
            </summary>
            <param name="configuration"></param>
            <param name="order"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.RemoveChild(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Removes the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> from this container if it is an immediate child.
            <para>Has no effect if if the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> is not an immediate child</para>
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.MakeIntoAnOrphan">
            <summary>
            Deletes all relationships in which this has a parent - kills all containers parents
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.AddChild(Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer)">
            <summary>
            Makes the other <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer"/> into a subcontainer of this container
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.DeleteInDatabase">
            <inheritdoc/>
            <remarks>Also deletes subcontainers to avoid leaving orphans in the database</remarks>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.HasChild(Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer)">
            <summary>
            Returns true if this.Children contains the thing you are looking for - IMPORTANT: also returns true if we are the thing you are looking for
            </summary>
            <param name="potentialChild"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.HasChild(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Returns true if the supplied <seealso cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> is a child of this container or any of it's subcontainers (recursively)
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetOrderedContents">
            <summary>
            Returns all subcontainers and identifier sets (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>) of this container in order (See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.Order"/>)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetAllAggregateConfigurationsRecursively">
            <summary>
            Returns all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> identifier sets in this container or any subcontainers
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.CloneEntireTreeRecursively(ReusableLibraryCode.Checks.ICheckNotifier,Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration,Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration,System.Collections.Generic.Dictionary{Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration,Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration})">
            <summary>
            Creates a new CohortAggregateContainer tree containing a clone container for each container in the original tree and a clone AggregateConfiguration for each in the original tree
            but with a rename in which AggregateConfigurations in the first tree are expected to start cic_X where X is the original cohort identification configuration ID, this will be replaced
            with the new clone's ID
            </summary>
            <param name="notifier"></param>
            <param name="original"></param>
            <param name="clone"></param>
            <param name="parentToCloneJoinablesDictionary"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetCohortIdentificationConfiguration">
            <summary>
            Returns the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> that this container is a part of either as a root container or contained with in a subcontainer of
            the root container.
            <para>Returns null if the container is an orphan</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.CreateInsertionPointAtOrder(Rdmp.Core.CatalogueLibrary.Data.Cohort.IOrderable,System.Int32,System.Boolean)">
            <summary>
            Moves all children containers/identifier lists (See <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetOrderedContents"/>) to make space for inserting a new one at the specified
            Order (See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.Order"/>).
            </summary>
            <param name="makeRoomFor"></param>
            <param name="order"></param>
            <param name="incrementOrderOfCollisions"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetAllSubContainersRecursively">
            <summary>
            Returns a list of all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer"/> that are subcontainers of the this.  This includes all children and children
            of children etc recursively.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.IsRootContainer">
            <summary>
            Returns true if this a cohort set and is the topmost (root) SET container of a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer.GetAllParentContainers">
            <summary>
            Returns all containers that exist above the current container (up to the root container of the CohortIdentificationConfiguration)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration">
            <summary>
            Cohort identification is the job identifying which patients fit certain study criteria.  E.g. "I want all patients who have been prescribed Diazepam for the first time after 2000
            and who are still alive today".  Every time the data analyst has a new project/cohort to identify he should create a new CohortIdentificationConfiguration, it is the entry point
            for cohort generation and includes a high level description of what the cohort requirements are, an optional ticket and is the hanging off point for all the 
            RootCohortAggregateContainers (the bit that provides the actual filtering/technical data about how the cohort is identified).
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.CICPrefix">
            <summary>
            Characters that apear in front of any <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> which is acting as a cohort identification list or patient index table
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.IsCohortIdentificationAggregate"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Description">
            <summary>
            User typed description of the cohort identification criteria in high level terms.  This should be a primer for looking at the contents (cohort sets, set operations
            etc).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Ticket">
            <summary>
            Name of a ticket in your company issue tracking application (if you have one) for logging time/issues with this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/>.
            Ties in with <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/> if a compatible plugin is installed.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.RootCohortAggregateContainer_ID">
            <summary>
            All <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> must have a single unique root <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer"/> in order to be run.  This is the ID of that
            container.
            <para>You should not share containers/cohort sets with any other <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/></para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.QueryCachingServer_ID">
            <summary>
            To assist with complex cohort identification queries over multiple datasets (and between servers / server types) you can configure a QueryCachingServer.  
            This is an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer"/> created by <see cref="!:CatalogueLibrary.ExternalDatabaseServerPatching.QueryCachingDatabasePatcher"/>. 
            Once setup, each <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> query in this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> will be run independently and the resulting 
            patient list commmitted ot the cache server (See QueryCaching.Aggregation.CachedAggregateConfigurationResultsManager).
            
            <para>This field holds the ID of the currently configured database (if any) which acts as a result cache</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Frozen">
            <summary>
            Indicates whether the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> should be considered immutable.  Usually because it has been run and the results committed to
            a Project.
            <para>IMPORTANT:You should use <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Freeze"/> rather than just setting this manually so as to also populate <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.FrozenBy"/> and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.FrozenDate"/></para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.FrozenBy">
            <summary>
            Username of the user who ran <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Freeze"/>
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Frozen"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.FrozenDate">
            <summary>
            The date <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Freeze"/> was last ran
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Frozen"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.ClonedFrom_ID">
            <summary>
            The ID of the CohortIdentificationConfiguration that this one was cloned from (if any).
            
            <para>It is possible to delete the parent, resulting in a ClonedFrom_ID which cannot be resolved to a parent object</para>
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Frozen"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.RootCohortAggregateContainer">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.RootCohortAggregateContainer_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.QueryCachingServer">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.QueryCachingServer_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String)">
            <summary>
            Declares a new configuration for identifying patient lists matching a study requirements based on the results of cohort sets / patient index tables and set operations
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/>
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.DeleteInDatabase">
            <summary>
            Deletes the root container and consequently the entire <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.CreateRootContainerIfNotExists">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer"/> if there is no <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.RootCohortAggregateContainer_ID"/> yet
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.GetSearchString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.GetAllParameters">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.GetNamingConventionPrefixForConfigurations">
            <inheritdoc cref="F:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.CICPrefix"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.IsValidNamedConfiguration(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Returns true if the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> provided has Name compatible with <see cref="F:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.CICPrefix"/>
            <seealso cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.GetNamingConventionPrefixForConfigurations"/>
            </summary>
            <param name="aggregate"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.EnsureNamingConvention(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            All <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>s within a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> must start with the appropriate prefix (and ID of the cic)
            (See <see cref="F:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.CICPrefix"/>).  This method will change the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.Name"/> to match the expected prefix.
            <para>If the name change would result in a collisionw ith an existing set in the configuration then (Copy X) will appear at the end of the name</para>
            </summary>
            <param name="aggregate"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.CreateClone(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Creates a entirely new copy of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> with all new IDs on the root and all child objects.  This includes
            filters, patient index tables, parameters, set containers etc.
            <para>This is done in a transaction so that if it fails halfway through you won't end up with half a clone configuration</para>
            </summary>
            <param name="notifier">Event listener for reporting cloning progress and any problems</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.ImportAggregateConfigurationAsIdentifierList(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.ChooseWhichExtractionIdentifierToUseFromManyHandler,System.Boolean)">
            <summary>
            Creates an adjusted copy of the <paramref name="toClone"/> to be used as a cohort identification <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>.  This could be 
            an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> graph or one that is acting as a patient index table / cohort set for another <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/>.
            <para>IMPORTANT: It must be possible to select a single column from which to harvest the patient identifiers from <paramref name="resolveMultipleExtractionIdentifiers"/></para>
            </summary>
            <param name="toClone">The aggregate to import</param>
            <param name="resolveMultipleExtractionIdentifiers">What to do if there are multiple <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/>/<see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension"/>
             marked IsExtractionIdentifier</param>
            <param name="useTransaction">True to run the import in a transaction</param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.ChooseWhichExtractionIdentifierToUseFromManyHandler">
            <summary>
            Delegate for handling the situation in which the user wants to create a cohort based on a given Catalogue but there are multiple IsExtractionIdentifier columns.
            For example SMR02 (baby birth records) might have (Mother CHI, Father CHI, Baby CHI).  In this situation the descision on which column to use is resolved by this
            class. 
            </summary>
            <param name="catalogue"></param>
            <param name="candidates"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.CreateNewEmptyConfigurationForCatalogue(Rdmp.Core.CatalogueLibrary.Data.Catalogue,Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.ChooseWhichExtractionIdentifierToUseFromManyHandler,System.Boolean)">
            <summary>
            Creates a new cohort set <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> which initially matches any patient appearing in the dataset (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>).
            <para>IMPORTANT: It must be possible to select a single column from which to harvest the patient identifiers from <paramref name="resolveMultipleExtractionIdentifiers"/></para>
            </summary>
            <param name="catalogue">The catalogue to import as a patient identification set (you can import the same Catalogue multiple times e.g. 
            'People ever prescribed morphine' EXCEPT 'People ever prescribed percoset'</param>
            <param name="resolveMultipleExtractionIdentifiers">What to do if there are multiple <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/>
             marked IsExtractionIdentifier</param>
            <param name="importMandatoryFilters"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.GetExtractionIdentifierFrom(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation@,Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.ChooseWhichExtractionIdentifierToUseFromManyHandler)">
            <summary>
            returns an underlying ExtractionInformation which IsExtractionIdentifier (e.g. a chi column).  The first pass approach is to look for a suitable AggregateDimension which
            has an underlying  ExtractionInformation which IsExtractionIdentifier but if it doesn't find one then it will look in the Catalogue for one instead.  The reason this is 
            complex is because you can have datasets with multiple IsExtractionIdentifier columns e.g. SMR02 (birth records) where there is both MotherCHI and BabyCHI which are both
            IsExtractionIdentifier - in this case the AggregateConfiguration would need a Dimension of one or the other (but not both!) - if it had neither then the method would throw
            when it checked Catalogue and found both.
            </summary>
            <param name="toClone"></param>
            <param name="underlyingExtractionInformation"></param>
            <param name="resolveMultipleExtractionIdentifiers"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.GetAllJoinables">
            <summary>
            Returns all patient index tables declared in this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration"/>)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.GetDistinctTableInfos">
            <summary>
            Returns all unique <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> required for building all of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>s in the 
            <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.RootFilterContainer_ID"/> or any subcontainers.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Freeze">
            <summary>
            Freezes the current <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> marking it as immutable.
            <para>This is the prefered way of setting <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Frozen"/></para>
            <seealso cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Frozen"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Unfreeze">
            <summary>
            Clears the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.Frozen"/> flag fields and saves to database
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.IOrderable">
            <summary>
            Any class which should appear in a specific order
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.IOrderable.Order">
            <summary>
            Order object should appear in relative to other <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.IOrderable"/> objects 
            in the same scope
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration">
            <summary>
            Relationship object which indicates that a given AggregateConfiguration is a 'PatientIndexTable'.  In order to be compatible as a 'PatientIndexTable' the 
            AggregateConfiguration must have one IsExtractionIdentifier AggregateDimension and usually at least one other column which has useful values in it (e.g. 
            admission dates).  The patient index table can then be used as part of other AggregateConfigurations in a CohortIdentificationConfiguration (e.g. 'find 
            all people in Deaths dataset who died within 3 months of having a prescription for drug Y' - where Prescriptions is the 'PatientIndexTable'. 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.CohortIdentificationConfiguration_ID">
            <summary>
            ID of the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.CohortIdentificationConfiguration"/> for which the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.AggregateConfiguration_ID"/> acts as a patient index table
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.AggregateConfiguration_ID">
            <summary>
            ID of the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.AggregateConfiguration_ID"/> which this class is making act as a patient index table
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.Users">
            <summary>
            Gets all the users of the patient index table, these <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.AggregateConfiguration"/> will be joined against the patient index table at query generation time.
            <para>The returned objects are <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse"/> which is the mandate to link against us.  Use 
            <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.AggregateConfiguration"/> to fetch the actual <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.AggregateConfiguration"/></para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.CohortIdentificationConfiguration">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.CohortIdentificationConfiguration_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.AggregateConfiguration">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.AggregateConfiguration_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Declares that the passed <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.AggregateConfiguration"/> should act as a patient index table and be joinable with other <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.AggregateConfiguration"/>s in
            the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.CohortIdentificationConfiguration"/>.
            </summary>
            <param name="repository"></param>
            <param name="cic"></param>
            <param name="aggregate"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.AddUser(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Mandates that the passed <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.AggregateConfiguration"/> should join with this patient index table at query generation time.  The <paramref name="user"/> must 
            be part of the same <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.CohortIdentificationConfiguration"/> as the patient index table (<see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.CohortIdentificationConfiguration_ID"/>)
            </summary>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse">
            <summary>
            Indicates that a given AggregateConfiguration in a CohortIdentificationConfiguration is implicitly joined against a 'PatientIndexTable' See JoinableCohortAggregateConfiguration
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.JoinableCohortAggregateConfiguration_ID">
            <summary>
            Specifies the patient index table against which the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.AggregateConfiguration_ID"/> should be joined with at query generation time
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.AggregateConfiguration_ID">
            <summary>
            Specifies the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.AggregateConfiguration"/> which should be joined with the referenced patient index table (See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.JoinableCohortAggregateConfiguration_ID"/>)
            at query generation time
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.JoinType">
            <summary>
            Determines how the cohort set <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.AggregateConfiguration"/> will be joined against the patient index table referenced by the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.JoinableCohortAggregateConfiguration_ID"/>
            <para>The cohort aggregate is always the 'left' table and the patient index table is the 'right' table.  The join is performed on the patient identifier column</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.JoinableCohortAggregateConfiguration">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.JoinableCohortAggregateConfiguration_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.AggregateConfiguration">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.AggregateConfiguration_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.GetJoinDirectionSQL">
            <summary>
            Translates <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionJoinType"/> into an SQL keyword (LEFT / RIGHT etc).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfigurationUse.GetJoinTableAlias">
            <summary>
            Gets the table alias for the index table in the join sql query e.g. if the alias was ix123 then the query built would be something like
            <code>'select chi from Tbl1 INNER JOIN TblPatIndx ix123 on Tbl1.chi = ix123.chi where ix123.date > GETDATE()'</code>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.SetOperation">
            <summary>
            The Sql set operation for combining sets (lists of patient identifiers) in a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer"/>.  This is done by compiling each 
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> and <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer"/> in a given container into queries identifying distinct patients.  A master
            query is then built in which each subquery is interspersed by the appropriate <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.SetOperation"/>. 
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Cohort.SetOperation.UNION">
            <summary>
            Result set is everyone in any sub set
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Cohort.SetOperation.INTERSECT">
            <summary>
            Result set is only people appearing in every subset
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Cohort.SetOperation.EXCEPT">
            <summary>
            Result set is the people in the first set who do not appear in any of the subsequent sets
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo">
            <summary>
            References an SQL column in a TableInfo (which itself references an SQL table).  This is the RDMP's awareness of the state of your database.  You can
            synchronize against the underlying sql server state using TableInfoSynchronizer.
            
            <para>A ColumnInfo can belong to an anonymisation group (ANOTable) e.g. ANOGPCode, in this case it will be aware not only of it's name and datatype in LIVE
            but also it's unanonymised name/datatype (see method GetRuntimeName(LoadStage stage)).</para>
            
            <para>A ColumnInfo may seem superfluous since you can query much of it's information at runtime but consider the situation where TableInfo is a table valued 
            function or it is a view and someone deletes a column from the view without telling anyone.  The ColumnInfo ensures a standard unchanging representation
            for the RDMP so that it can rationalize and inform the system user of disapearing columns etc and let the user make decisions about how to resolve it 
            (which might be as simple as deleting the ColumnInfos although that will have knock on effects for extraction logic etc).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.TableInfo_ID">
            <summary>
            ID of the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.TableInfo"/> that this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> belongs to.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ANOTable_ID">
            <summary>
            ID of the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ANOTable"/> transform that is applied to this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> during
            data loads e.g. swap chi for anochi.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Name">
            <summary>
            The fully specified name of the column in the underlying database table this record points at.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Data_type">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Format">
            <summary>
             User specified free text field.  Not used for anything by RDMP. 
            <para> Use <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Collation"/> instead</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Digitisation_specs">
            <summary>
            User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Source">
            <summary>
             User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Description">
            <summary>
             User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Status">
            <summary>
             User specified free text field.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.RegexPattern">
            <summary>
            Validation Regex that could be used to assess the cleanliness of data in the column.   Not used for anything by RDMP.
            <para>Use the data quality engine instead (See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.ValidatorXML"/>)</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ValidationRules">
            <summary>
            Not used for anything by RDMP.
            <para>Use the data quality engine instead (See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.ValidatorXML"/>)</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.IsPrimaryKey">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.IsAutoIncrement">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Collation">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.DuplicateRecordResolutionOrder">
            <summary>
            The importance of this column in resolving primary key collisions during data loads (in RAW).  Columns with a lower number are consulted first when resolving
            collisions.  E.g. are the colliding records different on this column? if yes use <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.DuplicateRecordResolutionIsAscending"/> to pick which to delete
            otherwise move onto the next (non primary key) column.
            <para>Only applies if you have a PrimaryKeyCollisionResolverMutilation in the data load</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.DuplicateRecordResolutionIsAscending">
            <summary>
            Used in primary key collision resolution during data loads (in RAW).  If two records differ on this field (and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.IsPrimaryKey"/> is false) then the order
            (<see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.DuplicateRecordResolutionIsAscending"/>) will be used to decide which is deleted.
            <para>Only applies if you have a PrimaryKeyCollisionResolverMutilation in the data load</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.TableInfo">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.TableInfo_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ANOTable">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ANOTable_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ExtractionInformations">
            <summary>
            Fetches all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> which draw on this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/>.  This could be none (if it is not extractable) or more than one
            (if there are multiple extraction transforms available for the column or if the column/table is part of multiple <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.CatalogueItems">
            <summary>
            Fetches all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/> which describe the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ExtractionInformations"/> of this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/>.  This will also include any
            non extractable <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/> linked to this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> in <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>s.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ColumnStatus">
            <summary>
            Notional usage status of a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/>.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ColumnStatus.Deprecated">
            <summary>
            Should not be used anymore.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ColumnStatus.Inactive">
            <summary>
            Notional usage state of a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/>.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ColumnStatus.Archived">
            <summary>
            Notional usage state of a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/>.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ColumnStatus.Active">
            <summary>
            Normal state for columns.  Not used for anything by RDMP.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String,System.String,Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <summary>
            Creates a new record of a column found on a database server in the table referenced by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.TableInfo"/>.  This constructor will be used
            when first importing a table reference (See <see cref="T:Rdmp.Core.CatalogueLibrary.DataHelper.TableInfoImporter"/>)  and again whenever there are new columns
            discovered during table sync (See <see cref="T:Rdmp.Core.CatalogueLibrary.TableInfoSynchronizer"/>)
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
            <param name="type"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ToString">
            <summary>
            Returns the fully qualified <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Name"/> of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.CompareTo(System.Object)">
            <summary>
            Allows sorting by fully qualified <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Name"/>.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.GetRuntimeName">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.GetFullyQualifiedName">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.GetRuntimeName(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.GetRuntimeDataType(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <summary>
            Gets the DataType adjusted for the stage at which the ColumnInfo is at, this is almost always the same as Data_type.  The only
            time it is different is when there is an ANOTable involved e.g. ANOLocation could be a varchar(6) like 'AB10_L' after anonymisation
            but if the LoadStage is AdjustRaw then it would have a value like 'NH10' (varchar(4) - the unanonymised state).
            </summary>
            <param name="loadStage"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Discover(ReusableLibraryCode.DataAccess.DataAccessContext)">
            <summary>
            Connects to the live database referenced by this <seealso cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> and discovers the column returning the
            live state of the column.
            <para>If the database/table/column doesn't exist or is inaccessible then this method will throw</para>
            </summary>
            <param name="context">Determines which credentials (if any) to use to perform the connection operation</param>
            <returns>The live state of the column</returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks the ANO status of the column is valid (and matching on datatypes etc).  
            <para>Does not check for synchronization against the underlying database.</para>
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.GetAllLookupForColumnInfoWhereItIsA(Rdmp.Core.CatalogueLibrary.Data.LookupType)">
            <summary>
            Determines whether the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> is involved in <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> declarations (either as a foreign key, or as part of a lookup <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.TableInfo"/>).
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.IsNumerical">
            <summary>
            Returns true if the Data_type is numerical (decimal or int) according to the DBMS it resides in.  Returns
            false if the the Data_type is not found to be numerical or if the datatype is unknown, missing or anything 
            else goes wrong resolving the Type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn">
            <summary>
            Common abstract base class for ExtractionInformation (how to extract a given ColumnInfo) and ExtractableColumn (clone into data export database of an 
            ExtractionInformation - i.e. 'extract column A on for Project B Configuration 'Cases' where A would be an ExtractionInformation defined in the Catalogue 
            database and copied out for use in the data extraction configuration).
            
            <para>Provides an implementation of IColumn whilst still being a DatabaseEntity (saveable / part of a database repository etc)</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.Order">
            <summary>
            The order the column should be in when part of a SELECT statement built by an <see cref="T:Rdmp.Core.QueryBuilding.ISqlQueryBuilder"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.SelectSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.Alias">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.HashOnDataRelease">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.IsExtractionIdentifier">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.IsPrimaryKey">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.ColumnInfo">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.#ctor(MapsDirectlyToDatabaseTable.IRepository,System.Data.Common.DbDataReader)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.GetRuntimeName">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <inheritdoc cref="T:Rdmp.Core.QueryBuilding.SyntaxChecking.ColumnSyntaxChecker"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.CompareTo(System.Object)">
            <summary>
            Compares columns by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.Order"/>
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer">
            <summary>
            Common abstract base class for IContainer (AND/OR Where logic) classes that are persisted in the database as a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.Operation">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.GetParentContainerIfAny">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.GetSubContainers">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.GetFilters">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.AddChild(Rdmp.Core.CatalogueLibrary.Data.IContainer)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.AddChild(Rdmp.Core.CatalogueLibrary.Data.IFilter)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.MakeIntoAnOrphan">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.DeleteInDatabase">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.GetRootContainerOrSelf">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.GetAllFiltersIncludingInSubContainersRecursively">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.GetAllSubContainersRecursively">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter">
            <summary>
            Abstract base class for all IFilters which are database entities (Stored in the Catalogue/Data Export database as objects). 
            
            <para>ConcreteFilter is used to provide UI editing of an IFilter without having to add persistence / DatabaseEntity logic to IFilter (which would break 
            SpontaneouslyInventedFilters)</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.#ctor(MapsDirectlyToDatabaseTable.IRepository,System.Data.Common.DbDataReader)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.#ctor">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.WhereSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.Description">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.IsMandatory">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.ClonedFromExtractionFilter_ID">
            <summary>
            An <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> can either be created from scratch or copied from a master <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/> declared at Catalogue level.  If this filter
            was cloned from a master catalogue filter then the ID of the filter will be in this property.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.FilterContainer_ID">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.GetAllParameters">
            <summary>
            Returns all the immediate <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> which are declared on the IFilter.  These are sql parameters e.g. 'DECLARE @startDate as datetime' with a defined
            Value, the parameter should be referenced by the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.WhereSQL"/> of the IFilter.  This may not be representative of the final values used in query building if
            there are higher level/global overriding parameters e.g. declared at <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> or 
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.FilterContainer">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.FilterContainer_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.GetColumnInfoIfExists">
            <summary>
            If an IFilter is associated with a specific ColumnInfo then this method returns it.  This is really only the case for master Catalogue level filters 
            (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/>)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.GetFilterFactory">
            <summary>
            When overriden in a derrived class, creates an <see cref="T:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.IFilterFactory"/> which can be used to create new correctly typed <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> for use with
            the current <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> 
            </summary>
            <remarks>Most IFilter implementations require their own specific type of IContainer, ISqlParameter etc and they only work with those concrete classes.  Therefore the 
            IFilterFactory is needed to create those correct concrete classes when all you have is a reference to the interface</remarks>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.GetCatalogue">
            <summary>
            Every IFilter is ultimately tied to a single <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> either because it is a master filter declared on a column in one or because it is being used
            in the extraction of a dataset or an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> graph / cohort set which are again tied to a 
            single <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>.   When overridden this method returns the associated Catalogue. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.GetQuerySyntaxHelper">
            <summary>
            Returns an appropriately typed <see cref="T:FAnsi.Discovery.QuerySyntax.IQuerySyntaxHelper"/> depending on the DatabaseType of the Catalogue that it relates to.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.GetDatabaseType">
            <summary>
            Returns the database provider type (e.g. MySql / Sql Server) that the filter is written for.  This is determined by what <see cref="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.GetColumnInfoIfExists"/>
            it is declared against.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> WhereSQL passes basic syntax checks via <see cref="T:Rdmp.Core.QueryBuilding.SyntaxChecking.FilterSyntaxChecker"/>.
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword">
            <summary>
            Describes a specific key/value pair that should always be used (unless overriden by an API requirement) in connection strings to servers of the given <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword.DatabaseType"/>
            by RDMP.  For example you could specify Encrypt = true to force all connections made to go through SSL (requires certificates / certificate validation etc).  Be careful when creating 
            these as they apply to all users of the system and can make servers unreachable if a syntactically valid but unresolvable connection string is created.
            
            <para>Checks will ensure that the keyword is a valid connection string keyword for the given <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword.DatabaseType"/> and thus you will not get syntactically illegal connection strings</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword.DatabaseType">
            <summary>
            The DBMS (Oracle / MySql etc) which this keyword should be used when connecting to
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword.Name">
            <summary>
            The name of the keyword.  Must be a valid connection string key for the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword.DatabaseType"/> e.g. IntegratedSecurity
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword.Value">
            <summary>
            The value to write into the connection string for the keyword e.g.  sspi
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword.#ctor(MapsDirectlyToDatabaseTable.IRepository,FAnsi.DatabaseType,System.String,System.String)">
            <summary>
            Defines a new keyword that should be set on all connections to databases of <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword.DatabaseType"/> when making new connections
            </summary>
            <param name="repository"></param>
            <param name="databaseType"></param>
            <param name="keyword"></param>
            <param name="value"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the keyword is valid syntax for the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword.DatabaseType"/> and can be set on a <see cref="T:System.Data.Common.DbConnectionStringBuilder"/>
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.CredentialsInUseException">
            <summary>
            Exception thrown when you attempt to delete an DataAccessCredentials upon which a TableInfo or other class relies upon to access data.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CredentialsInUseException.#ctor(System.String)">
            <inheritdoc>
                <cref>base(string)</cref>
            </inheritdoc>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.CredentialsInUseException.#ctor(System.String,System.Exception)">
            <inheritdoc>
                <cref>base(string, Exception)</cref>
            </inheritdoc>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl">
            <summary>
            Records position and Type of an IDashboardableControl on a DashboardLayout.  The lifecycle goes:
            1. Control instance created (must have a blank constructor)
            2. ConstructEmptyCollection called on instance of control
            3. Step2 collection Hydrated witht he PersistenceString (which can be null/empty)
            4. Step2 collection given the Objects referenced by ObjectsUsed
            5. Control instance given the Hydrated collection with SetCollection method
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.DashboardLayout_ID">
            <summary>
            Records which <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout"/> the control exists on
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.X">
            <summary>
            The X Coordinate of the control within the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout"/> window
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.Y">
            <summary>
            The Y Coordinate of the control within the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout"/> window
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.Width">
            <summary>
            The Width of the control within the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout"/> window
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.Height">
            <summary>
            The Height of the control within the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout"/> window
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.ControlType">
            <summary>
            The C# Class name of an IDashboardableControl which this class documents the existence of
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.PersistenceString">
            <summary>
            Serialized settings as configured by the user for the IDashboardableControl referenced by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.ControlType"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.ObjectsUsed">
            <summary>
            Gets all <see cref="T:MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable"/> objects used by the IDashboardableControl.  E.g. if the control is a pie chart of which columns in a dataset
            are missing column descriptions then this will return the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ICatalogue"/> which represents that dataset
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.ParentLayout">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.DashboardLayout_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout,System.Type,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Adds a new IDashboardableControl (<paramref name="controlType"/>) to the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout"/> (<paramref name="parent"/>) at the specified position.
            </summary>
            <param name="repository"></param>
            <param name="parent"></param>
            <param name="controlType"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="w"></param>
            <param name="h"></param>
            <param name="persistenceString"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.SaveCollectionState(Rdmp.Core.CatalogueLibrary.Data.Dashboarding.IPersistableObjectCollection)">
            <summary>
            Serializes the current state settings of the IDashboardableControl into <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl.PersistenceString"/>
            </summary>
            <param name="collection"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout">
            <summary>
            Describes a named collection of windows helpful for achieving a given task (usually data summarisation).  This class is the root object and has name (e.g. Dave's Dashboard).  It then
            has a collection of DashboardControls which are IDashboardableControl instances that the user has configured on his Dashboard via DashboardLayoutUI.  This can include plugins. Not only
            does this class provide persistence for useful layouts of controls between application executions but it allows users to share their dashboards with one another.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout.Created">
            <summary>
            The time the new dashboard was created
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout.Username">
            <summary>
            The user who created the dashboard
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout.Controls">
            <summary>
            Returns all controls that should be rendered on the given dashboard
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String)">
            <summary>
            Creates a new empty dashboard with the given name ready for controls to be added by the user
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardLayout.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardObjectUse">
            <summary>
            Describes a specific object used by a DashboardControl.  For example if you create a pie chart of issues on a specific catalogue on your DashboardLayout then there will be a 
            DashboardControl for the pie chart and a DashboardObjectUse pointing at that specific Catalogue.  These refernces do not stop objects being deleted.  References can also be 
            cross database (e.g. pointing at objects in a DataExport database like Project etc).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardObjectUse.DashboardControl_ID">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl"/> for which the class records object usage for
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardObjectUse.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl,MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Records the fact that the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.DashboardControl"/> targets the given object (and hopefully displays information about it)
            </summary>
            <param name="repository"></param>
            <param name="parentControl"></param>
            <param name="objectToSave"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.IPersistableObjectCollection">
            <summary>
            A collection of database objects used to drive an IObjectCollectionControl which is a user interface tab that requires multiple root objects in order to be created
            persisted and mainted.  All tabs in RDMP are either IObjectCollectionControl, IRDMPSingleDatabaseObjectControl or RDMPCollectionUI.  Try to avoid using collections if
            it is possible to hydrate the UI from one database object
            
            <para>A good example of an IObjectCollectionControl (which are driven by IPersistableObjectCollection) is CohortSummaryAggregateGraphUI which requires both a graph and a cohort
            and the UI shows a summary graph adjusted to match only records in the cohort.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.IPersistableObjectCollection.Helper">
            <summary>
            Gets the class you can use to serialize/deserialize values for this collection
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.IPersistableObjectCollection.DatabaseObjects">
            <summary>
            A list of all the currently used objects in this collection
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.IPersistableObjectCollection.SaveExtraText">
            <summary>
            Serialize any current state information about the collection that is not encapsulated in <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.IPersistableObjectCollection.DatabaseObjects"/> e.g. tickboxes, options, selected enums etc.
            <para>Returns null if there is no supplemental information to save about the collection</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.IPersistableObjectCollection.LoadExtraText(System.String)">
            <summary>
            Hydrate the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.IPersistableObjectCollection"/> state with a value that was created by <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.IPersistableObjectCollection.SaveExtraText"/>.  This does not include populating <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.IPersistableObjectCollection.DatabaseObjects"/>
            which happens seperately.
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistenceException">
            <summary>
            Occurs when there is an error restoring a specific Persistence String.  Often occurs when a UI class has been renamed or a plugin unloaded between 
            RDMP application executions.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistenceException.#ctor(System.String)">
            <summary>
            Throw when you were unable to resolve a saved Control state
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistenceException.#ctor(System.String,System.Exception)">
            <summary>
            Throw when you were unable to resolve a saved Control state and have an <paramref name="exception"/>
            </summary>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper">
            <summary>
            Helps you create simple string based argument lists
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.CollectionObjectSeparator">
            <summary>
            The string to use to divide objects declared within a collection e.g. ',' in [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.CollectionStartDelimiter">
            <summary>
            The string to use to indicate the start of an objects collection e.g. '[' in  [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.CollectionEndDelimiter">
            <summary>
            The string to use to indicate the end of an objects collection e.g. ']' in  [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.Separator">
            <summary>
            The string to use to separate logic portions of a persistence string e.g. ':"  in  [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.ExtraText">
            <summary>
            Divider between Type section  (see <see cref="F:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.Separator"/> - what is the control) and args dictionary for IPersistableObjectCollection
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.SaveDictionaryToString(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Serializes the dictionary to a string of XML
            </summary>
            <param name="dict"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.LoadDictionaryFromString(System.String)">
            <summary>
            Creates a dictionary by deserializing the XML string provided (e.g. a string generated by <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.SaveDictionaryToString(System.Collections.Generic.Dictionary{System.String,System.String})"/>) 
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.GetValueIfExistsFromPersistString(System.String,System.String)">
            <summary>
            Fetches the given key from the serialized <paramref name="persistString"/> (e.g. a string generated by <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.SaveDictionaryToString(System.Collections.Generic.Dictionary{System.String,System.String})"/>) 
            
            <para>If you need lots of values you should probably just use <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.LoadDictionaryFromString(System.String)"/> instead</para>
            </summary>
            <param name="key"></param>
            <param name="persistString"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.GetObjectCollectionPersistString(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable[])">
            <summary>
            Returns the objects IDs formatted with the <see cref="F:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.CollectionStartDelimiter"/>, <see cref="F:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.CollectionEndDelimiter"/> and <see cref="F:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.CollectionObjectSeparator"/>
            </summary>
            <param name="objects"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.MatchCollectionInString(System.String)">
            <summary>
            Returns the object list section of any <paramref name="persistenceString"/>. This string must take the format [RepoType:ObjectType:ID,RepoType:ObjectType:ID]
            
            <para>Throws <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistenceException"/> if there is not exactly 1 match or if the number of subtokens in each section is not 3.</para>
            </summary>
            <param name="persistenceString">persistence string in the format [RepoType:ObjectType:ID,RepoType:ObjectType:ID]</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.GetObjectCollectionFromPersistString(System.String,Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator)">
            <summary>
            Fetches the listed objects out of the collection section of a persistence string by fetching the listed ObjectType by ID from the RepoType
            </summary>
            <param name="allObjectsString">A string with a list of objects ID's, should have the format [RepoType:ObjectType:ID,RepoType:ObjectType:ID]</param>
            <param name="repositoryLocator"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.GetExtraText(System.String)">
            <summary>
            Returns all text appearing after <see cref="F:Rdmp.Core.CatalogueLibrary.Data.Dashboarding.PersistStringHelper.ExtraText"/>
            </summary>
            <param name="persistString"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials">
            <summary>
            Stores a username and encrypted password the Password property of the entity will be a hex value formatted as string which can be decrypted at runtime via 
            the methods of base class EncryptedPasswordHost which currently uses SimpleStringValueEncryption which is a wrapper for RSACryptoServiceProvider.  The layout
            of this hierarchy however allows for future plugin utility e.g. using different encryption keys for different tables / user access rights etc. 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials.Username">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials.Password">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String)">
            <summary>
            Records a new (initially blank) set of credentials that can be used to access a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> or other object requiring authentication.
            <para>A single <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials"/> can be shared by multiple tables</para>
            
            <para>You can also use <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentialsFactory"/> for easier credentials creation</para>
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials.DeleteInDatabase">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials.GetAllTableInfosThatUseThis">
            <summary>
            Returns all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> that rely on the credentials to access the table(s).  This is split into the contexts under which the 
            credentials are used e.g. <see cref="F:ReusableLibraryCode.DataAccess.DataAccessContext.DataLoad"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials.GetDecryptedPassword">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentialsFactory">
            <summary>
            Helper Factory for creating DataAccessCredentials.  This class exists solely to prevent duplication in DataAccessCredentials being created for newly imported
            TableInfos where the username/password/server are the same as an existing DataAccessCredentials.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentialsFactory.#ctor(Rdmp.Core.Repositories.ICatalogueRepository)">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentialsFactory"/> for creating <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials"/> which will be stored in the database provided (<paramref name="cataRepository"/>)
            </summary>
            <param name="cataRepository"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentialsFactory.Create(Rdmp.Core.CatalogueLibrary.Data.TableInfo,System.String,System.String,ReusableLibraryCode.DataAccess.DataAccessContext)">
            <summary>
            Ensures that the passed username/password combination are used to access the TableInfo under the provided context.  This will either create a new DataAccessCredentials 
            or wire up the TableInfo with a new usage permission to an existing one (if the same username/password combination already exists).
            </summary>
            <param name="tableInfoCreated"></param>
            <param name="username"></param>
            <param name="password"></param>
            <param name="usageContext"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity">
            <summary>
            Base class for all objects which are stored in database repositories (e.g. Catalogue database , Data Export database).  This is the abstract implementation of
            IMapsDirectlyToDatabaseTable.  You must always have two constructors, one that takes a DbDataReader and is responsible for constructing an instance from a 
            record in the database and one that takes the minimum parameters required to satisfy database constraints and is used to create new objects.
            
            <para>A DatabaseEntity instance cannot exist without there being a matching record in the database repository.  This is the RDMP design pattern for object permenance, 
            sharing and allowing advanced users to update the data model via database queries running directly on the object repository database.</para>
            
            <para>A DatabaseEntity must have the same name as a Table in in the IRepository and must only have public properties that match columns in that table.  This enforces
            a transparent mapping between code and database.  If you need to add other public properties you must decorate them with [NoMappingToDatabase]</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.Repository">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.CatalogueRepository">
            <summary>
            Returns <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.Repository"/> as <see cref="T:Rdmp.Core.Repositories.ICatalogueRepository"/> or null if the object does not exist in a catalogue repository.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.DataExportRepository">
            <summary>
            Returns <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.Repository"/> as <see cref="T:Rdmp.Core.Repositories.IDataExportRepository"/> or null if the object does not exist in a data export repository.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.#ctor">
            <summary>
            Constructs a new instance.  You should only use this when your object does not yet exist in the database
            and you are trying to create it into the db
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.#ctor(MapsDirectlyToDatabaseTable.IRepository,System.Data.Common.DbDataReader)">
            <summary>
            Creates a new instance and hydrates it from the current values of <paramref name="r"/>
            </summary>
            <param name="repository">The database which the record/object was read from</param>
            <param name="r">Data reader with values for hydrating this object</param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.ParseUrl(System.Data.Common.DbDataReader,System.String)">
            <summary>
            Converts the <paramref name="fieldName"/> into a <see cref="T:System.Uri"/>.  DBNull.Value and null are returned as null;
            </summary>
            <param name="r"></param>
            <param name="fieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.GetHashCode">
            <inheritdoc cref="M:MapsDirectlyToDatabaseTable.IRepository.GetHashCode(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.Equals(System.Object)">
            <inheritdoc cref="M:MapsDirectlyToDatabaseTable.IRepository.AreEqual(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable,System.Object)"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.SaveToDatabase">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.DeleteInDatabase">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.RevertToDatabaseState">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.HasLocalChanges">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.Exists">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.ObjectToNullableDateTime(System.Object)">
            <summary>
            Converts the supplied object to a <see cref="T:System.DateTime"/> or null if o is null/DBNull.Value
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.ObjectToNullableInt(System.Object)">
            <summary>
            Converts the supplied object to a <see cref="T:System.Int32"/> or null if o is null/DBNull.Value
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.ObjectToNullableBool(System.Object)">
            <summary>
            Converts the supplied object to a <see cref="T:System.Boolean"/> or null if o is null/DBNull.Value
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="E:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.PropertyChanged">
            <inheritdoc cref="!:IMapsDirectlyToDatabaseTable.PropertyChanged"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.OnPropertyChanged(System.Object,System.Object,System.String)">
            <summary>
            Fired when any database tied property is changed in memory.
            </summary>
            <param name="propertyName"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.SetField``1(``0@,``0,System.String)">
            <summary>
            Changes the value of <paramref name="field"/> to <paramref name="value"/> and triggers <see cref="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.OnPropertyChanged(System.Object,System.Object,System.String)"/>.  You should have a public Property and
            a backing field for all database fields on your object.  The Property should use this method to change the underlying fields value.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="field"></param>
            <param name="value"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.SetReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.CopyShallowValuesTo(Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity,System.Boolean,System.Boolean)">
            <summary>
            Copies all properties not marked with [NoMappingToDatabase] or [Relationship] from the this object to the <paramref name="to"/> object. 
            Also skips 'Name' and 'ID'
            </summary>
            <param name="to"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable">
            <summary>
            Defines an anonymisation method for a group of related columns of the same datatype.  For example 'ANOGPCode' could be an instance/record that defines input of type 
            varchar(5) and anonymises into 3 digits and 2 characters with a suffix of _G.  This product would then be used by all ColumnInfos that contain GP codes (current GP
            previous GP, Prescriber code etc).  Anonymisation occurs at  ColumnInfo level after being loaded from a RAW data load bubble as is pushed to the STAGING bubble.
            
            <para>Each ANOTable describes a corresponding table on an ANO server (see the Server_ID property - we refer to this as an ANOStore) including details of the transformation and a UNIQUE name/suffix.  This let's you
            quickly identify what data has be annonymised by what ANOTable when you find a random excel sheet kicking around on a hard disk devoid of context.</para>
             
            <para>It is very important to curate your ANOTables properly or you could end up with irrecoverable data, for example sticking to a single ANO server, taking regular backups
            NEVER deleting ANOTables that reference existing data  (in the ANOStore database).</para>
            
            <para>The ANOTable.cs class does it's best to ensure you do not corrupt the data in your Catalogue e.g. by loading 10 files then changing the transform then loading 10 more which
            would result in mixed typed data in the final anonymised state but if you edit the ANOTable data directly you could still end up with corrupted configurations.  Fortunately
            in almost all cases it should be possible to manually salvage the configuration without loosing data.  The only time you would loose data is when you delete the identifier substitutions
            off the ANOStore server (see DeleteANOTableInANOStore method which will let you do this for empty tables)</para>
            
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.ANOPrefix">
            <summary>
            Prefix to put on anonymous columns
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.TableName">
            <summary>
            The name of the table in the ANO database that stores swapped identifiers
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.NumberOfIntegersToUseInAnonymousRepresentation">
            <summary>
            The number of decimal characters to use when creating ANO mapping identifiers.  This will directly impact the number of possible values that can be generated and therefore
            the number of unique input values before anonymising fails (due to collisions).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.NumberOfCharactersToUseInAnonymousRepresentation">
            <summary>
            The number of alphabetic characters to use when creating ANO mapping identifiers.  This will directly impact the number of possible values that can be generated and therefore
            the number of unique input values before anonymising fails (due to collisions).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.Server_ID">
            <summary>
            The ID of the ExternalDatabaseServer which stores the anonymous identifier substitutions (e.g. chi=>ANOchi).  This should have been created by the ANOStoreDatabasePatcher
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.Suffix">
            <summary>
            The letter that appears on the end of all anonymous identifiers generated e.g. AAB11_GP would have the suffix "GP"
            
            <para>Once you have started using the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable"/> to anonymise identifiers you should not change the Suffix</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.Server">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.Server_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer,System.String,System.String)">
            <summary>
            Declares that a new ANOTable (anonymous mapping table) should exist in the referenced database.  You can call this constructor without first creating the table.  If you do
            you should set <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.NumberOfIntegersToUseInAnonymousRepresentation"/> and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.NumberOfCharactersToUseInAnonymousRepresentation"/> then <see cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.PushToANOServerAsNewTable(System.String,ReusableLibraryCode.Checks.ICheckNotifier,System.Data.Common.DbConnection,System.Data.Common.DbTransaction)"/>
            </summary>
            <param name="repository"></param>
            <param name="externalDatabaseServer"></param>
            <param name="tableName"></param>
            <param name="suffix"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.SaveToDatabase">
            <summary>
            Saves the current state to the database if the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable"/> is in a valid state according to <see cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.Check(ReusableLibraryCode.Checks.ICheckNotifier)"/> otherwise throws an Exception 
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.DeleteInDatabase">
            <summary>
            Attempts to delete the remote mapping table (only works if it is empty) if the <see cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.IsTablePushed"/> then deletes the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable"/> reference
            object (this) from the RDMP platform database.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the remote mapping table referenced by this object exists and checks <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable"/> settings (<see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.Suffix"/> etc).
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.IsTablePushed">
            <summary>
            Returns true if the anonymous mapping table (<see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.TableName"/> exists in the referenced mapping database (<see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.Server"/>)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.GetPushedTable">
            <summary>
            Connects to <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.Server"/> and returns a <see cref="T:FAnsi.Discovery.DiscoveredTable"/> that contains the anonymous identifier mappings
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.DeleteANOTableInANOStore">
            <summary>
            Attempts to delete the anonymous mapping table referenced by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.TableName"/> on the mapping <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.Server"/>.  This is safer than just dropping
            from <see cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.GetPushedTable"/> since it will check the table exists, is empty etc.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.PushToANOServerAsNewTable(System.String,ReusableLibraryCode.Checks.ICheckNotifier,System.Data.Common.DbConnection,System.Data.Common.DbTransaction)">
            <summary>
            Connects to the remote ANO Server and creates a swap table of Identifier to ANOIdentifier
            </summary>
            <param name="identifiableDatatype">The datatype of the identifiable data table</param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.GetRuntimeDataType(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <summary>
            Anonymisation with an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable"/> happens during data load.  This means that the column goes from identifiable in RAW to anonymous in STAGING/LIVE.  This means
            that the datatype of the column changes depending on the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage"/>.
            
            <para>Returns the appropriate datatype for the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage"/>.  This is done by connecting to the mapping table and retrieving the mapping table types</para>
            </summary>
            <param name="loadStage"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ANOTable.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument">
            <summary>
            Abstract base for all concrete IArgument objects.  An Argument is a stored value for a Property defined on a PipelineComponent or DLE component which has
            been decorated with [DemandsInitialization] and for which the user has picked a value.  The class includes both the Type of the argument (extracted from
            the class Property PropertyInfo via reflection) and the Value (stored in the database as a string).
            
            <para>This allows simple UI driven population and persistence of configuration settings for plugin and system core components as they are used in all pipeline and
            dle activities.  See ArgumentCollection for UI logic.</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.PermissableTypes">
            <summary>
            All Types that are supported for <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.Type"/> and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.Value"/> of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/>s.
            
            <para>Or to put it another way, don't decorate an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost"/> property with <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute"/> if its Type isn't on this list</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.Value">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.Type">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.Description">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.Data.Common.DbDataReader)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.GetValueAsSystemType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.GetSystemType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.GetConcreteSystemType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.GetConcreteSystemType(System.String)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.GetConcreteSystemType"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.SetType(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.SetValue(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory">
            <summary>
            Provides methods for creating Argument values in the database for [DemandsInitialization] properties on classes (See Argument).  Every public property marked with
            [DemandsInitialization] on a plugin component will allow the user to specify a value of the appropriate type.  This class will handle not only creating the IArguments
            for a plugin component but also rationalising differences e.g. there is a new version of a class in the latest plugin with different [DemandsInitialization] properties,
            which Argument values are no longer needed and which new ones must be created to store configuration values.
            
            <para>Remember that a given plugin class can have multiple instances of it deployed into different pipelines with different argument values.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory.CreateArgumentsForClassIfNotExistsGeneric``1(Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost,Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument[])">
            <inheritdoc cref = "M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory.CreateArgumentsForClassIfNotExistsGeneric(System.Type,Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost,Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument[])"/>
            <typeparam name="T">A class with one or more Properties marked with DemandsInitialization</typeparam>
            <returns>Each new ProcessTaskArgument created - note that it will not return existing ones that were already present (and therefore not created)</returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory.CreateArgumentsForClassIfNotExistsGeneric(System.Type,Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost,Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument[])">
            <summary>
            Interrogates a class via reflection and enumerates it's properties to find any that have the attribute [DemandsInitialization]
            Each one of these that is found is created as a ProcessTaskArgument of the appropriate Name and PropertyType under the parent ProcessTask
            </summary>
            <returns>Each new ProcessTaskArgument created - note that it will not return existing ones that were already present (and therefore not created)</returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory.GetRequiredProperties(System.Type)">
            <summary>
            Gets all public properties of the given <paramref name="classType"/> decorated with <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute"/>.  
            
            <para>If there are any public properties encountered with <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DemandsNestedInitializationAttribute"/> then the referenced class is also investigated in the same manner.</para>
            </summary>
            <param name="classType"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory.SyncArgumentsForClass(Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost,System.Type)">
            <summary>
            Creates <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/> instances for all demanded properties (See <see cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory.GetRequiredProperties(System.Type)"/>) of the given class and deletes any old arguments
            which are no longer required by the class (e.g. due to an API change).
            </summary>
            <param name="host"></param>
            <param name="underlyingClassTypeForWhichArgumentsWillPopulate"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory.GetDemandDictionary(Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost,System.Type)">
            <summary>
            Synchronizes all arguments (See SyncArgumentsForClass) for the supplied class (<paramref name="underlyingClassTypeForWhichArgumentsWillPopulate"/>) and returns the mapping
            between <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/> (which stores the value) and public class property (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.RequiredPropertyInfo"/>)
            </summary>
            <param name="host"></param>
            <param name="underlyingClassTypeForWhichArgumentsWillPopulate"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Extensions.LoadBubbleExtensions">
            <summary>
            Static type extensions for Enum <see cref="T:Rdmp.Core.CatalogueLibrary.Data.LoadBubble"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Extensions.LoadBubbleExtensions.ToLoadStage(Rdmp.Core.CatalogueLibrary.Data.LoadBubble)">
            <summary>
            Converts a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.LoadBubble"/> into a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage"/>
            </summary>
            <param name="bubble"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Extensions.LoadStageExtensions">
            <summary>
            Static extensions for <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Extensions.LoadStageExtensions.ToLoadBubble(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <summary>
            Converts a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage"/> into a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.LoadBubble"/>
            </summary>
            <param name="loadStage"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument">
            <summary>
            Records the user configured value of a property marked with [DemandsInitialization] declared on a data flow/dle component (including plugin components).
             See Argument for full description.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.Name">
            <summary>
            The name of the Property which this object stores the value of.  The Property should be decorated with [DemandsInitialization]
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.Description">
            <summary>
            Record of <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute.Description"/> as it was specified when the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/> was created
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.Value">
            <summary>
            The string value for populating the class Property at runtime.  This is usually set to null or a default then adjusted by the user as needed to tailor
            the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost"/> class.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.Type">
            <summary>
            The full Type name of the class Property this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/> holds the runtime value for (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost"/>)
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.SetValue(System.Object)">
            <summary>
            Change the current <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.Value"/> held by the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/> to a new value (this must be a supported Type - See <see cref="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.Argument.PermissableTypes"/>)
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.GetValueAsSystemType">
            <summary>
            Parses the current <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.Value"/> into the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.Type"/> and returns it as a strongly typed object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.GetSystemType">
            <summary>
            Parses the current <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.Type"/> string into a <see cref="T:System.Type"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.GetConcreteSystemType">
            <summary>
            Similar to <see cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.GetSystemType"/> except it will look for a non interface/abstract derrived class e.g. if <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.Type"/> is <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ICatalogue"/> 
            it will return <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.SetType(System.Type)">
            <summary>
            Change the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.Type"/> of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/> to the supplied <see cref="T:System.Type"/>.  This may make <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument.Value"/> invalid.
            </summary>
            <param name="t"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost">
            <summary>
            Interface for all classes which make use of the IArgument/Argument system to record user configured values of [DemandsInitialization] properties.  Allows you
            to get the currently configured arguments and create new ones.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost.GetAllArguments">
            <summary>
            Gets all persisted property values for the class referenced by the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost"/> (i.e. <see cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost.GetClassNameWhoArgumentsAreFor"/>).  Each argument will
             satisfy one public property on the class decorated with <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost.CreateNewArgument">
            <summary>
            Creates a new empty <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/> of a Type compatible with the  <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost"/> e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask"/> would create a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskArgument"/>
            
            <para>It is better to use <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory"/></para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost.GetClassNameWhoArgumentsAreFor">
            <summary>
            The name of the class for which the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost"/> stores arguments for and is responsible for hosting e.g. a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask"/> could be hosting an blueprint
            for a specific configuration of IAttacher, IDataProvider etc.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost.CreateArgumentsForClassIfNotExists``1">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory.CreateArgumentsForClassIfNotExistsGeneric(System.Type,Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost,Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument[])"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost.CreateArgumentsForClassIfNotExists(System.Type)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory.CreateArgumentsForClassIfNotExistsGeneric(System.Type,Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost,Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument[])"/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUI`1">
            <summary>
            Powers the creation of instances of T in an ICustomUI
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUI`1.SetUnderlyingObjectTo(`0)">
            <summary>
            Loads the current value into the user interface
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUI">
            <summary>
            Interface that lets you create UIs for populating <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/> values for Properties which are too complicated to do with basic Types.  See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUIDrivenClass"/>.  If
            If at all possible you should avoid the overhead of this system and instead use [DemandsNestedInitialization] and subclasses if you have a particluarly complex concept
            defined in your plugin component.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUI.CatalogueRepository">
            <summary>
            Use this to fetch objects from the RDMP platform databases e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>, <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> etc
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUI.SetGenericUnderlyingObjectTo(Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUIDrivenClass)">
            <summary>
            When implementing this just cast value to T and call the overload in ICustomUI&lt;T&gt;
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUI.GetFinalStateOfUnderlyingObject">
            <summary>
            Fetches the final state of the object being show in the user interface (e.g. after closing the form)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUIDrivenClass">
            <summary>
            Interface that allows you to be supported as a [DemandsInitialization] property of a DLE / pipeline component (see Argument) despite having a horribly complex Type.
            If your property Type too complex to be handled by the existing supported Types of Argument (See PermissableTypes) then you will have to use the ICustomUI system and
            create your own interface for allowing the user to configure it and write the code to serialize/deserialize it into a string yourself.
            
            <para>If the complexity is due to subcomponents of the class e.g. 'RemoteDataFetcher' could have a Property 'Endpoint' of Type 'EndpointDefinition' you can instead 
            decorate the property 'Endpoint' with [DemandsNestedInitialization] and then decorate the properties of 'EndpointDefinition' with 'DemandsInitialization'.  Basically
            you don't want to use this interface if you can avoid it.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUIDrivenClass.RestoreStateFrom(System.String)">
            <summary>
            Hydrate the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUIDrivenClass"/> by deserializing the supplied string.  If there is no <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/> value configured yet
            then <paramref name="value"/> may be null
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUIDrivenClass.SaveStateToString">
            <summary>
            Persist the current state of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUIDrivenClass"/> as a string.  This must be compatible with <see cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ICustomUIDrivenClass.RestoreStateFrom(System.String)"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IHasStageSpecificRuntimeName">
            <summary>
            Interface for an object that has a name that varies depending on which stage of a data load you are attempting to reference.  For example TableInfo will have a 
            different name depending on whether you are addressing the live table or the table as it exists in during the AdjustStaging during a data load.  Likewise an
            anonymised ColumnInfo will have a different name in the live stage (e.g. ANOLabNumber) vs the raw stage (e.g. LabNumber - column prior to anonymisation).
            
            <para>See also IHasRuntimeName</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IHasStageSpecificRuntimeName.GetRuntimeName(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <summary>
            Returns the runtime name (unqualified name e.g. "MyColumn" ) for the column/table at the given stage of a data load (RAW=>STAGING=>LIVE)
            <seealso cref="M:FAnsi.Naming.IHasRuntimeName.GetRuntimeName"/>
            </summary>
            <param name="stage"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata.LocationOfFlatFiles">
            <summary>
            The root working directory for a load.  Should have subdirectories like Data, Executables etc
            <para>For structured access to this use a new <see cref="T:Rdmp.Core.CatalogueLibrary.ILoadDirectory"/></para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata.OverrideRAWServer">
            <summary>
            Optional - Overrides the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Defaults.ServerDefaults"/> RAWDataLoadServer with an explicit RAW server to use this load only.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata.ProcessTasks">
            <summary>
            List of all the user configured steps in a data load.  For example you could have 2 ProcessTasks, one that downloads files from an FTP server and one that loads RAW.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata.GetAllCatalogues">
            <summary>
            Returns all datasets this load is responsible for supplying data to.  This determines which <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> are 
            available during RAW=>STAGING=>LIVE migration (the super set of all tables underlying all catalogues).
            
            <para>See also <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.LoadMetadata_ID"/></para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata.GetDistinctLoggingDatabase">
            <summary>
            The unique logging server for auditing the load (found by querying <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.LiveLoggingServer"/>)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata.GetDistinctLoggingDatabase(Rdmp.Core.CatalogueLibrary.Data.IExternalDatabaseServer@)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata.GetDistinctLoggingDatabase"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata.GetDistinctLiveDatabaseServer">
            <summary>
            Returns the single server that contains all the live data tables in all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ICatalogue"/> that are loaded by the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata"/>.
            All datasets in a load must be on the same database server.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata.GetDistinctLoggingTask">
            <summary>
            Returns the unique value of <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.LoggingDataTask"/> amongst all catalogues loaded by the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadProgressHost">
            <summary>
            Interface for defining that a given class is dependent or operates on one or more LoadProgress.  This is used when you declare a [DemandsInitialization] property on
            a plugin component of type ILoadProgress to determine which instances to offer at design time (i.e. only show LoadProgresses that are associated with the load you are
            editing).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadProgressHost.LoadProgresses">
            <summary>
            Data loads can be either one offs (e.g. load all csv files in ForLoading) or iterative (load all data from the cache between 2001-01-01 and 2002-01-01).
            If a data load is iterative then it will have one or more <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress"/> which describe how far through the loading process it is.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IPreLoadDiscardedColumn">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IPreLoadDiscardedColumn.Destination">
            <summary>
            Where the RAW column values will end up during a load.  Either dropped completely, diluted into LIVE or routed to an identifier dump
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IPreLoadDiscardedColumn.RuntimeColumnName">
            <summary>
            The name of the virtual column (that will exist only in RAW).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IPreLoadDiscardedColumn.SqlDataType">
            <summary>
            The type of the virtual column when creating it in RAW during a data load
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IPreLoadDiscardedColumn.TableInfo">
            <summary>
            The table the virtual column is associated with.  When creating RAW during a DLE execution, all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IPreLoadDiscardedColumn"/> will be created in addition
            to the normal LIVE columns in the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IPreLoadDiscardedColumn.TableInfo"/> live schema.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IProcessTask">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IProcessTask.ProcessTaskArguments">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost.GetAllArguments"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IProcessTask.Path">
            <summary>
            Either the C# Type name of a data load component (e.g. an IAttatcher, IDataProvider) or the path to an sql file or exe file (depending on <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IProcessTask.ProcessTaskType"/>)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IProcessTask.Name">
            <summary>
            The human readable description of what the component is supposed to do (e.g. "Copy all csv files from c:/temp/landing into ForLoading")
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IProcessTask.LoadStage">
            <summary>
            The stage of the data load (RAW=>STAGING=>LIVE) that the task should be run at.  This can restrict which operations are allowed e.g. you can't run attatchers PostLoad
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IProcessTask.ProcessTaskType">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskType"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IProcessTask.RelatesSolelyToCatalogue_ID">
            <summary>
            Allows you to specify that a task should only be run when loading a specific <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>.  Since you can't change which <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> are loaded
            by a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata"/> at runtime, this property is now obsolete
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IResolveDuplication">
            <summary>
            Common interface for columns which can be used in RAW to resolve primary key duplication (See PrimaryKeyCollisionResolver).  This includes both PreLoadDiscardedColumns
            and ColumnInfos.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IResolveDuplication.DuplicateRecordResolutionOrder">
            <summary>
            The preference order for the non primary key column in deleting rows to obtain a unique primary key.  Records will be evaluated on the first column in the order
            and if records hold the same value the next column in the order will be used. Once a differing field value is found one row will be selected based on
             <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IResolveDuplication.DuplicateRecordResolutionIsAscending"/>)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IResolveDuplication.DuplicateRecordResolutionIsAscending">
            <summary>
            True to prefer short strings, low numbers, nulls.  False to prefer longer strings, not null values, high numbers when comparing which record to delete
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IResolveDuplication.Data_type">
            <summary>
            The proprietary SQL datatype of the column in the underlying database table this record points at.  
            <para>E.g. datetime2 or varchar2 (Oracle) or int etc</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ITableInfoCollectionHost">
            <summary>
            Interface for defining that a given class is dependent or operates on one or more TableInfos.  This is used when you declare a [DemandsInitialization] property on
            a plugin component of type ITableInfo to determine which instances to offer at design time (i.e. only show TableInfos that are associated with the load you are
            editing).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ITableInfoCollectionHost.GetTableInfos">
            <summary>
            Gets all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> that are part of the load
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.CacheArchiveType">
            <summary>
            How are files cached within the cache (e.g. within a zip? tar? just uncompressed in a directory).
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.CacheArchiveType.None">
            <summary>
            Cached files are in a directory uncompressed
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.CacheArchiveType.Zip">
            <summary>
            Cached files are contained in a zip file
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata">
            <summary>
            Entrypoint to the loading metadata for one or more Catalogues. This includes name, description, scheduled start dates etc.  All other loading
            entities are attached to this entity for example each load Process (Unzip files called *.zip / Dowload all files from FTP server X) contains
            a reference to the LoadMetadata that it belongs in.
            
            <para>A LoadMetadata also allows you to override various settings such as forcing a specific alternate server to load - for when you want to overule
            the location that TableInfo thinks data is on e.g. into a test environment mirror of live.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.LocationOfFlatFiles">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.AnonymisationEngineClass">
            <summary>
            Not used
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.Description">
            <summary>
            Human readable description of the load, what it does etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.CacheArchiveType">
            <summary>
            The format for storing files in when reading/writing to a cache with a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress"/>.  This may not be respected
            depending on the implementation of the sepecific ICacheLayout
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.OverrideRAWServer_ID">
            <summary>
            Optional.  Indicates that when running the Data Load Engine, the specific <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer"/> should be used for the RAW server (instead of 
            the system default - see <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Defaults.ServerDefaults"/>).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.OverrideRAWServer">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.LoadProgresses">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.ProcessTasks">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String)">
            <summary>
            Create a new DLE load.  This load will not have any <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask"/> and will not load any <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> yet.
            
            <para>To set the loaded tables, set <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Catalogue.LoadMetadata_ID"/> on some of your datasets</para>
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.DeleteInDatabase">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.GetAllCatalogues">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.GetDistinctLoggingDatabase(Rdmp.Core.CatalogueLibrary.Data.IExternalDatabaseServer@)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.GetDistinctLoggingDatabase">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.GetDistinctLoggingTask">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.GetDistinctTableInfoList(System.Boolean)">
            <summary>
            Return all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> underlying the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>(s) which use this load (what tables will be loaded by the DLE).
            </summary>
            <param name="includeLookups">true to include lookup tables (e.g. z_sex etc) configured in the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>(s)</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.GetDistinctLiveDatabaseServer">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.EnsureLoggingWorksFor(Rdmp.Core.CatalogueLibrary.Data.ICatalogue)">
            <summary>
            Tests that the logging database for the load is reachable and that it has an appropriate logging task for the load (if not a new task will be created 'Loading X')
            </summary>
            <param name="catalogue"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage">
            <summary>
            Describes a stage related to the RAW=>STAGING=>LIVE bubble data load model in RDMP.  The stages are more refined than LoadBubbles (RAW / STAGING / LIVE) and
            include such things as GetFiles (where you download remote resources ahead of the actual load etc).
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage.GetFiles">
            <summary>
            Processes in this category should result in the generation or modification of files (e.g.
             FTP file download, unzip local file etc).  The data load engine will not provide processes 
            in this stage with any information about the database being loaded (but it will provide 
            the root project directory so that processes know where to generate files into)"
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage.Mounting">
            <summary>
            Processes in this category should be concerned with moving data from the project directory
            into the RAW database.  The data load engine will provide both the root directory and the 
            location of the RAW database.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage.AdjustRaw">
            <summary>
            Processes in this category should be concerned with modifying the content/structure of the data
            in the RAW database.  This data will not be annonymised at this point.  After running all the
            processes in this category, the structure of the database must match the _STAGING database.
            Assuming the RAW database structure matches _STAGING, the data load engine will then move the data
            (performing appropriate anonymisation steps on a column by column basis as defined in the Catalogue
             ColumnInfos)
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage.AdjustStaging">
            <summary>
            "Processes in this category should be concerned with modifying the content (not structure) of the data in the 
            STAGING database.  This data will be annonymous.  After all processes have been executed and assuming the _STAGING 
            database structure still matches the LIVE structure, the data load engine will use the primary key informtion
            defined in the Catalogue ColumnInfos to merge the new data into the current LIVE database
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage.PostLoad">
            <summary>
            "Processes in this category are executed after the new data has been merged into the LIVE database.  This 
            is your opportunity to update dependent data, run longitudinal/dataset wide cleaning algorithms etc."
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.DiscardedColumnDestination">
            <summary>
            Describes where a PreLoadDiscardedColumn will ultimately end up.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.DiscardedColumnDestination.Oblivion">
            <summary>
            Column appears in RAW and might be used in AdjustRaw but is droped completely prior to migration to Staging
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.DiscardedColumnDestination.StoreInIdentifiersDump">
            <summary>
            Column appears in RAW but is seperated off and stored in an IdentifierDump (See IdentifierDumper) and not passed through to Staging
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.DiscardedColumnDestination.Dilute">
            <summary>
            Column appears in RAW but is Diluted during AdjustStaging prior to joining the live dataset e.g. by rounding dates to the nearest quarter.  The undilted value may be stored in the IdentifierDump (See IdentifierDumper).
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn">
            <summary>
            Describes a column that is provided to your institution by a data provider but which is not loaded into your LIVE database table.  This column might be very sensitive, 
            irrelevant to you etc.  Each discarded column has a destination (DiscardedColumnDestination)  e.g. it might be dropped completely or routed into an identifier dump for
            when you still want to store information such as Who an MRI was for but do not want it sitting in your live dataset for governance/anonymisation reasons.
            
            <para>Each instance is tied to a specific TableInfo and when a data load occurs from an unstructured format (e.g. CSV) which RequestsExternalDatabaseCreation then not only are the
            LIVE columns created in the RAW bubble but also the dropped columns described in PreLoadDiscardedColumn instances.  This allows the live system state to drive required formats/fields
            for data load resulting in a stricter/more maintainable data load model.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.TableInfo_ID">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IPreLoadDiscardedColumn.TableInfo"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.Destination">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.RuntimeColumnName">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.SqlDataType">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.DuplicateRecordResolutionOrder">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.DuplicateRecordResolutionIsAscending">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.TableInfo">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.Data_type">
            <summary>
            For setting, use SqlDataType instead, it is an exact alias to allow for IResolveDuplication interface definition (see the fact that ColumnInfo also uses that interface and is also IMapsDirectlyToDatabaseTable)
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.TableInfo,System.String)">
            <summary>
            Creates a new virtual column that will be created in RAW during data loads but does not appear in the LIVE table schema.  This allows
            identifiable data to be loaded and processed in a data load without ever hitting the live database.
            </summary>
            <param name="repository"></param>
            <param name="parent"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.GetRuntimeName">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.GetRuntimeName(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn.GoesIntoIdentifierDump">
            <summary>
            true if destination for column is to store in identifier dump including undiluted versions of dilutes 
            (Dillution involves making clean values dirty for purposes of anonymisation and storing the clean values in
            the Identifier Dump).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask">
            <summary>
            Describes a specific operation carried out at a specific step of a LoadMetadata.  This could be 'unzip all files called *.zip in for loading' or
            'after loading the data to live, call sp_clean_table1' or 'Connect to webservice X and download 1,000,000 records which will be serialized into XML'
            
            <para>The class achieves this wide ranging functionality through the interaction of ProcessTaskType and Path.  e.g. when ProcessTaskType is Attacher then
            Path functions as the Type name of a class that implements IAttacher e.g. 'LoadModules.Generic.Attachers.AnySeparatorFileAttacher'.  </para>
            
            <para>Each ProcessTask can have one or more strongly typed arguments (see entity ProcessTaskArgument), these are discovered at design time by using
            reflection to query the Path e.g. 'AnySeparatorFileAttacher' for all properties marked with [DemandsInitialization] attribute.  This allows for 3rd party developers
            to write plugin classes to easily handle freaky source file types or complex/bespoke data load requirements.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.LoadMetadata_ID">
            <summary>
            The load the process task exists as part of
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.RelatesSolelyToCatalogue_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.Order">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.Path">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.LoadStage">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.ProcessTaskType">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.IsDisabled">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.LoadMetadata">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.LoadMetadata_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.ProcessTaskArguments">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.RelatesSolelyToCatalogue">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.RelatesSolelyToCatalogue_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.LoadProgresses">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata,Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <summary>
            Creates a new operation in the data load (e.g. copy files from A to B, load all CSV files to RAW table B etc)
            </summary>
            <param name="repository"></param>
            <param name="parent"></param>
            <param name="stage"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.GetTableInfos">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.GetAllArguments">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.CreateNewArgument">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.GetClassNameWhoArgumentsAreFor">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.CloneToNewLoadMetadataStage(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata,Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <summary>
            Creates a new copy of the processTask and all it's arguments in the database, this clone is then hooked up to the
            new LoadMetadata at the specified stage
            </summary>
            <param name="loadMetadata">The new LoadMetadata parent for the clone</param>
            <param name="loadStage">The new load stage to put the clone in </param>
            <returns>the new ProcessTask (the clone has a different ID to the parent)</returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.CreateArgumentsForClassIfNotExists(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.CreateArgumentsForClassIfNotExists``1">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.IsCompatibleStage(Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskType,Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <summary>
            Returns true if the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.ProcessTaskType"/> is allowed to happen during the given <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.LoadStage"/>  (e.g. you can't use an IAttacher to
            load data into STAGING/LIVE - only RAW). 
            </summary>
            <param name="type"></param>
            <param name="stage"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.IsPluginType">
            <summary>
            True if <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.Path"/> is the name of a C# class (as opposed to the path to an executable or SQL file etc)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.SetArgumentValue(System.String,System.Object)">
            <summary>
            Sets the value of the corresponding <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/> (which must already exist) to the given value.  If your argument doesn't exist yet you
            can call <see cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask.CreateArgumentsForClassIfNotExists(System.Type)"/>
            </summary>
            <param name="parameterName"></param>
            <param name="o"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskArgument">
            <summary>
            Contains a strongly typed value which will be provided to an instantiated data class of ProcessTask at runtime.  These usually correspond
            1 to 1 with [DemandsInitialization] flagged properties of a data class e.g. 'LoadModules.Generic.Attachers.AnySeparatorFileAttacher' would have
            a ProcessTaskArgument record for the property UnderReadBehaviour and one for IgnoreBlankLines and one for IgnoreQuotes etc. 
            
            <para>This all happens transparently by reflection and is handled at design time through PluginProcessTaskUI seamlessly</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskArgument.ProcessTask_ID">
            <summary>
            The task for which this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskArgument"/> stores values
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskArgument.ProcessTask">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskArgument.ProcessTask_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskArgument.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTask)">
            <summary>
            Stores a new argument value for the class hosted by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskArgument.ProcessTask"/>. Use
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ArgumentFactory"/> if you want to do this in a more structured manner. 
            </summary>
            <param name="repository"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskArgument.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskArgument.CreateArgumentsForClassIfNotExists``1(Rdmp.Core.CatalogueLibrary.Data.DataLoad.IProcessTask)">
            <summary>
            Creates new ProcessTaskArguments for the supplied class T (based on what DemandsInitialization fields it has).  Parent is the ProcessTask that hosts the class T e.g. IAttacher
            </summary>
            <typeparam name="T">A class that has some DemandsInitializations</typeparam>
            <param name="parent"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskType">
            <summary>
            The high level type of a ProcessTask, defines what the property Path contains.  If the ProcessTaskType is Executable then Path contains the path to an exe to run, If
            ProcessTaskType is Attacher then Path will be a class name etc.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskType.Executable">
            <summary>
            ProcessTask is to launch an executable file with parameters telling it about the load stage being operated on (servername, database name etc)
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskType.SQLFile">
            <summary>
            ProcessTask is to run an SQL file directly on the server
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskType.Attacher">
            <summary>
            ProcessTask is to instantiate the IAttacher class Type specified in Path and hydrate it's [DemandsInitialization] properties with values matching 
            ProcessTaskArguments and run it in the specified load stage in an AttacherRuntimeTask wrapper.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskType.DataProvider">
            <summary>
            ProcessTask is to instantiate the IDataProvider class Type specified in Path and hydrate it's [DemandsInitialization] properties with values matching 
            ProcessTaskArguments and run it in the specified load stage in an DataProviderRuntimeTask wrapper.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ProcessTaskType.MutilateDataTable">
            <summary>
            ProcessTask is to instantiate the IMutilateDataTables class Type specified in Path and hydrate it's [DemandsInitialization] properties with values matching 
            ProcessTaskArguments and run it in the specified load stage in an MutilateDataTablesRuntimeTask wrapper.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.RequiredPropertyInfo">
            <summary>
            Class for documenting properties declared as [DemandsInitialization] in a class.  Includes the DemandsInitializationAttribute (Description, Mandatory etc) and the 
            PropertyInfo (reflection) of the class as well as the parent propertyinfo if PropertyInfo is defined in a [DemandsNestedInitialization] sub component class of the
            of the class being evaluated.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.RequiredPropertyInfo.Demand">
            <summary>
            The attribute that decorates the public property on the class who is demanding that the user provide a value (in an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/>)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.RequiredPropertyInfo.PropertyInfo">
            <summary>
            The public property on the class who is demanding that the user provide a value (in an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/>)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.RequiredPropertyInfo.ParentPropertyInfo">
            <summary>
            Null unless the demand is for a property on a settings class of the main class e.g. MyPlugin has a property Settings marked with [DemandsNestedInitialization]
            and this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.RequiredPropertyInfo"/> is for one of the public [DemandsInitialization] decorated properties of Settings.  If this is the case then
             <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.RequiredPropertyInfo.ParentPropertyInfo"/> will be the root property Settings.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.RequiredPropertyInfo.#ctor(Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute,System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
            <summary>
            Records the fact that a given public property on a class is marked with <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute"/> and that the user is supposed
            to provide a value for it in an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/>
            </summary>
            <param name="demand"></param>
            <param name="propertyInfo"></param>
            <param name="parentPropertyInfo"></param>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DataLoad.RequiredPropertyInfo.Name">
            <summary>
            The property name.  If the property is a nested one (i.e. DemandsNestedInitialization) then returns the full expression parent.property
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Defaults.IServerDefaults">
            <summary>
            Server defaults let you identify a role a server plays (e.g. IdentifierDumpServer) and make it the default one of it's type for all rows created which have an IdentifierDump.
            For example TableInfo.IdentifierDumpServer_ID defaults to whichever IdentifierDump ExternalDatabaseServer is configured (can be DBNull.Value).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Defaults.IServerDefaults.GetDefaultFor(Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults)">
            <summary>
            Returns the default server for performing the activity
            </summary>
            <param name="field"></param>
            <returns>the currently configured ExternalDatabaseServer the user wants to use as the default for the supplied role or null if no default has yet been picked</returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Defaults.IServerDefaults.ClearDefault(Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults)">
            <summary>
            Sets the database <paramref name="toDelete"/> default to null (not configured)
            </summary>
            <param name="toDelete"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Defaults.IServerDefaults.SetDefault(Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults,Rdmp.Core.CatalogueLibrary.Data.IExternalDatabaseServer)">
            <summary>
            Changes the database <paramref name="toChange"/> default to the specified server
            </summary>
            <param name="toChange"></param>
            <param name="externalDatabaseServer"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults">
            <summary>
            Fields that can be set or fetched from the ServerDefaults table in the Catalogue Database
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults.None">
            <summary>
            Null value/representation
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults.LiveLoggingServer_ID">
            <summary>
            Relational logging database to store logs in while loading, running DQE, extracting etc
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults.IdentifierDumpServer_ID">
            <summary>
            Server to split sensitive identifiers off to during load (e.g. IdentifierDumper)
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults.DQE">
            <summary>
            Server to store the results of running the DQE on datasets over time
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults.WebServiceQueryCachingServer_ID">
            <summary>
            Server to store cached results of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> which are not sensitive and could be shown on a website etc
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults.RAWDataLoadServer">
            <summary>
            The RAW bubble server in data loads
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults.ANOStore">
            <summary>
            Server to store substituted ANO/Identifiable mappings for sensitive fields during data load e.g. GPCode, CHI, etc.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults.CohortIdentificationQueryCachingServer_ID">
            <summary>
            Server to store cached identifier lists of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>  which are part of a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> in order
            to speed up performance of UNION/INTERSECT/EXCEPT section of the cohort building query.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaultsExtensions.ToTier2DatabaseType(Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults)">
            <summary>
            Translates the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults"/> (a default that can be set) to a <see cref="!:Tier2DatabaseType"/> (identifies what type of database it is).
            </summary>
            <param name="permissableDefault"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Defaults.ServerDefaults">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.Defaults.IServerDefaults"/>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Defaults.ServerDefaults._repository">
            <inheritdoc/>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Defaults.ServerDefaults.StringExpansionDictionary">
            <summary>
            The value that will actually be stored in the ServerDefaults table as a dictionary (see constructor for population
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Defaults.ServerDefaults.#ctor(Rdmp.Core.Repositories.CatalogueRepository)">
            <summary>
            Creates a new reader for the defaults configured in the <paramref name="repository"/> platform database
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Defaults.ServerDefaults.GetDefaultFor(Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Defaults.ServerDefaults.ClearDefault(Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Defaults.ServerDefaults.SetDefault(Rdmp.Core.CatalogueLibrary.Data.Defaults.PermissableDefaults,Rdmp.Core.CatalogueLibrary.Data.IExternalDatabaseServer)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute">
            <summary>
            Used to model Design Time initialization of IDataFlowComponents and DLE ProcessTasks (IAttacher etc).  Decorate public properties of IDataFlowComponents
            with this attribute to allow the user  to define values for the Pipeline when they build it.  Each Demand will be serialised as a 
            PipelineComponentArgument/ProcessTaskArgument.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute.Description">
            <summary>
            User readable description of what they are supposed to supply as values for the decorated property, allowable values etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute.DemandType">
            <summary>
            Any special subcategory e.g. String might be <see cref="F:Rdmp.Core.CatalogueLibrary.Data.DemandType.SQL"/> or it might just be a regular string value.  If in doubt
            use <see cref="F:Rdmp.Core.CatalogueLibrary.Data.DemandType.Unspecified"/> (the default)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute.DefaultValue">
            <summary>
            The value to use if the user hasn't picked a value yet (created an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/>).  This will also be the default value set
            on any argument when it is created.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute.Mandatory">
            <summary>
            True if the public property must have a value supplied by the user.  This is compatible with <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute.DefaultValue"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute.TypeOf">
            <summary>
            If the property being decorated is System.Type e.g. <code>public Type OperationType {get;set;}</code>.  Then this specifies which Types the user can
            select (anything derrived from this Type).  This lets you have the user pick a strategy for your plugin as long as the strategies have blank/compatible 
            constructors.  You will have to decide how best to instantiate this Type yourself at runtime.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute.#ctor(System.String,Rdmp.Core.CatalogueLibrary.Data.DemandType,System.Object,System.Type,System.Boolean)">
            <summary>
            Marks a public property on an RDMP plugin class as editable by the user.  The user can pick a value at design time for use with the plugin e.g. in
            a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> then when the pipeline is run your class will be instantiated and all properties will be 
            hydrated from the corresponding <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument"/>s.
            </summary>
            <param name="description"></param>
            <param name="demandType"></param>
            <param name="defaultValue"></param>
            <param name="typeOf"></param>
            <param name="mandatory"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DemandsNestedInitializationAttribute">
            <summary>
            Used by classes to indicate that a complex POCO property should have all its properties initialized from a ProcessTaskArgument
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.DemandType">
            <summary>
            Used to define non Type semantically important things about a [DemandsInitialization] which cannot be determined from the Type of the property.  For example if a
            System.String property is expected to contain Sql then this DemandType can be specified which will result in a better user experience than a basic Textbox when it
            comes time to provide a value at Design time.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DemandType.Unspecified">
            <summary>
            There is no special subcategory
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.DemandType.SQL">
            <summary>
            The property is String but it should be rendered/edited the user interface as a SQL syntax (e.g. big editor with highlighting)
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.EncryptedPasswordHost">
            <summary>
            Helper class for becomming an IEncryptedPasswordHost via SimpleStringValueEncryption.  This class needs an ICatalogueRepository because
            SimpleStringValueEncryption is only secure when there is a private RSA encryption key specified in the CatalogueRepository.  This key 
            certificate will be a file location.  This allows you to use windows file system based user authentication to securely encrypt strings
            within RDMP databases.
            
            <para>See also PasswordEncryptionKeyLocationUI</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.EncryptedPasswordHost.FakeEncryptedString">
            <summary>
            This is only to support XML de-serialization
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EncryptedPasswordHost.#ctor">
            <summary>
            For XML serialization
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EncryptedPasswordHost.#ctor(Rdmp.Core.Repositories.ICatalogueRepository)">
            <summary>
            Prepares the object for decrypting/encrypting passwords based on the <see cref="!:PasswordEncryptionKeyLocation"/>
            </summary>
            <param name="repository"></param>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.EncryptedPasswordHost.Password">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EncryptedPasswordHost.GetDecryptedPassword">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.EncryptedString">
            <summary>
            Encrypts a string, providing access to both the encrypted and decrypted values.
            </summary>
            <exception cref="T:System.InvalidOperationException">Value is too long to be encrypted</exception>
            <exception cref="T:System.Security.Cryptography.CryptographicException" />
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EncryptedString.ToString">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.EncryptedString.Value">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EncryptedString.#ctor(Rdmp.Core.Repositories.ICatalogueRepository)">
            <summary>
            Creates a new encrypted string using <see cref="T:Rdmp.Core.CatalogueLibrary.SimpleStringValueEncryption"/>
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EncryptedString.GetDecryptedValue">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EncryptedString.IsStringEncrypted(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.EntityNaming.FixedStagingDatabaseNamer">
            <summary>
            Used when there is a single staging database used for multiple different Catalogues. The name of the database being loaded is prepended to the staging table name.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EntityNaming.FixedStagingDatabaseNamer.#ctor(System.String,System.String)">
            <summary>
            <para>---</para>
            <para>For 'Staging', returns the table name prefixed with <paramref name="databaseName"/> and suffixed with _STAGING</para>
            <para>---</para>
            <para>For others, appends:</para>
            <para>_Archive for Archive</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EntityNaming.FixedStagingDatabaseNamer.GetName(System.String,Rdmp.Core.CatalogueLibrary.Data.LoadBubble)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EntityNaming.FixedStagingDatabaseNamer.GetDatabaseName(System.String,Rdmp.Core.CatalogueLibrary.Data.LoadBubble)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads">
            <summary>
            Provides service for determining/checking a table's name at a particular stage in the load process, as the same canonical table name may be different at different stages.
            For example, the 'Data' table may be called 'Data' in live but 'LoadID_Data_STAGING' in staging if a single staging database is being used for all data loads
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads.GetDatabaseName(System.String,Rdmp.Core.CatalogueLibrary.Data.LoadBubble)">
            <summary>
            Gets the database name to give to the LIVE database during the given DLE load stage (e.g. RAW / STAGING/) e.g. STAGING might always be DLE_STAGING regardless of the
            LIVE database
            </summary>
            <param name="rootDatabaseName">The LIVE database name</param>
            <param name="convention">The stage for which you want to know the corresponding database name</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads.GetName(System.String,Rdmp.Core.CatalogueLibrary.Data.LoadBubble)">
            <summary>
            Determines what name to give to passed LIVE table in the given DLE load bubble (e.g. RAW / STAGING)
            </summary>
            <param name="tableName">The LIVE table name</param>
            <param name="convention">The stage for which you want to know the corresponding tables name, this may not change at all depending on implementation</param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.EntityNaming.SuffixBasedNamer">
            <summary>
            Determines how to translate a TABLE (not database!) name based on the load stage of a DLE RAW=>STAGING=>LIVE migration.  E.g. Raw tables
            already have the same name as Live tables (they are in a RAW database) but Staging tables and Archive tables have the suffixes specified
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EntityNaming.SuffixBasedNamer.GetDatabaseName(System.String,Rdmp.Core.CatalogueLibrary.Data.LoadBubble)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.EntityNaming.SuffixBasedNamer.GetName(System.String,Rdmp.Core.CatalogueLibrary.Data.LoadBubble)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer">
            <summary>
            <para>Records information about a server.  This can be a system specific database e.g. a Logging database or an ANOStore or it could be a generic
            database you use to hold data (e.g. lookups).  These are usually database servers but don't have to be (e.g. you could create a reference to an FTP server).</para>
            
            <para>IMPORTANT: do not add an ExternalDatabaseServer just because you store data on it, instead you should import pointers to the data you hold as TableInfo 
            objects which themselves store Server/Database which allows for minimal disruption when you decide to move a table to a different server (it also allows
            for accessing the data under different accounts based on what is being done - loading vs extraction : see DataAccessCredentials_TableInfo).</para>
            
            <para>ExternalDatabaseServer are really only for fixed global entities such as logging/identifier dumps etc.</para>
            
            <para>Servers can but do not have to have usernames/passwords in which case integrated security (windows account) is used when openning connections.  Password
            is encrypted in the same fashion as in the DataAccessCredentials table.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.Name">
            <summary>
            Human readable name for the server e.g. 'My Favourite Logging Database'
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.CreatedByAssembly">
            <summary>
            If the database was created by an RDMP schema (or plugin schema) this will contain the name of the dll which holds the schema e.g. DataQualityEngine.Database and was
            responsible for creating the database.  This determines what roles RDMP lets the database play.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.MappedDataPath">
            <summary>
            The public network share of the Data path where the physical database files are stored if applicable.  Sharing your database directory on the network is a 
            terrible idea (don't do it).  You can use this to automate detatching and shipping an MDF to your researchers e.g. MsSqlReleaseSource
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.Server">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.Database">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.Username">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.Password">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.DatabaseType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String,MapsDirectlyToDatabaseTable.Versioning.IPatcher)">
            <summary>
            Creates a new persistent server reference in RDMP platform database that allows it to connect to a (usually database) server.
            
            <para>If you are trying to create a database (e.g. a logging database) you should instead use 
            <see cref="T:MapsDirectlyToDatabaseTable.Versioning.MasterDatabaseScriptExecutor"/></para>
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
            <param name="databaseAssemblyIfCreatedByOne"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.GetCredentialsIfExists(ReusableLibraryCode.DataAccess.DataAccessContext)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.GetDecryptedPassword">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.SetProperties(FAnsi.Discovery.DiscoveredDatabase,System.Boolean)">
            <summary>
            Sets server,database,username and password properties based on the supplied DiscoveredDatabase (which doesn't have to actually exist).  This method also optionally calls
            SaveToDatabase which commits the changes to the Catalogue Repository 
            </summary>
            <param name="discoveredDatabase"></param>
            <param name="save">true if you want to call SaveToDatabase after setting the properties</param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.WasCreatedBy(MapsDirectlyToDatabaseTable.Versioning.IPatcher)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer.Discover(ReusableLibraryCode.DataAccess.DataAccessContext)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory">
            <summary>
            Determines how accessible a given ExtractionInformation should be.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.Core">
            <summary>
            This column is always available for extraction
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.Supplemental">
            <summary>
            This column is available but might not always be wanted e.g. lookup descriptions where there is already a lookup code
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.SpecialApprovalRequired">
            <summary>
            This column is only available to researchers who have additional approvals over and above those required for a basic data extract
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.Internal">
            <summary>
            This column is for internal use only and shouldn't be released to researchers during data extraction
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.Deprecated">
            <summary>
            This column used to be supplied to researchers but should no longer be provided
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.ProjectSpecific">
            <summary>
            This column is part of a 'Project Specific Catalogue'.  If a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> is for use only with a specific data export Project then all 
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> in that <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> must have this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory"/>
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.Any">
            <summary>
            Value can only be used for fetching ExtractionInformations.  This means that all will be returned.  You cannot set a column to have an ExtractionCategory of Any
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter">
            <summary>
            Defines as a single line SQL Where statement, a way of reducing the scope of a data extraction / aggregation etc.  For example, 
            'Only prescriptions for diabetes medications'.  An ExtractionFilter can have 0 or more ExtractionFilterParameters which allows
            you to define a more versatile filter e.g. 'Only prescriptions for drug @bnfCode'
            
            <para>Typically an ExtractionFilter is cloned out as either a DeployedExtractionFilter or an AggregateFilter and either used as is or
            customised in it's new state (where it's parameters might have values populated into them).</para>
            
            <para>It is not uncommon for an extraction to involve multiple customised copies of the same Extraction filter for example a user might
            take the filter 'Prescriptions of drug @Drugname' and make 3 copies in a given project in DataExportManager (this would result in
            3 DeployedExtractionFilters) and set the value of the first to 'Paracetamol' the second to 'Aspirin' and the third to 'Ibuprofen'
            and then put them all in a single AND container.</para>
            
            <para>At query building time QueryBuilder rationalizes all the various containers, subcontainers, filters and parameters into one extraction
            SQL query (including whatever columns/transforms it was setup with).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.ExtractionInformation_ID">
            <summary>
            The column in the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> which is best/most associated with this filter.  A filter can query any column in any of the table(s) under
            the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> but must always be associated with only one specific extractable column (<see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.ExtractionInformation"/>)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.FilterContainer">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.FilterContainer_ID">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.GetColumnInfoIfExists">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.GetFilterFactory">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.GetCatalogue">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.GetAllParameters">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.ExtractionInformation">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.ExtractionInformation_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.ExtractionFilterParameters">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.ConcreteFilter.GetAllParameters"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String,Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation)">
            <summary>
            Creates a new WHERE SQL block for reuse with the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> in which the <paramref name="parent"/> resides.  This is a top level master filter and can be
            copied out in <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/>, ExtractionConfiguration etc.  This ensures a single curated block of
            logic that everyone shares.
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.ToString">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.ClonedFromExtractionFilter_ID">
            <summary>
            Returns null, <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/> are master level filters and therefore never cloned from another filter
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter">
            <summary>
            Describes an SQL parameter (e.g. @drugname) which is required for use of an ExtractionFilter (it's parent).
            
            <para>See the description of ExtractionFilter to see how filters are cloned and adjusted depending on usage context</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.Value">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.Comment">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.ParameterSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.ExtractionFilter_ID">
            <summary>
            The filter which requires this parameter belongs e.g. an <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.ExtractionFilter"/>'Healthboard X' could have a required property (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter"/>) @Hb 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.ParameterName">
            <summary>
            extracts the name ofthe parameter from the SQL
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.ExtractionFilter">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.ExtractionFilter_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String,Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter)">
            <summary>
            Creates a new parameter on the given <paramref name="parent"/>
            <para>It is better to use <see cref="T:Rdmp.Core.CatalogueLibrary.FilterImporting.ParameterCreator"/> to automatically generate parameters based on the WHERE Sql</para>
            </summary>
            <param name="repository"></param>
            <param name="parameterSQL"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <inheritdoc cref="T:Rdmp.Core.QueryBuilding.SyntaxChecking.ParameterSyntaxChecker"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.IsProperlyDocumented(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter,System.String@)">
            <summary>
            Returns true if a  <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.Comment"/> has been provided and an example/initial <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.Value"/> specified.  This is a requirement of
            publishing a filter as a master filter
            </summary>
            <param name="sqlParameter"></param>
            <param name="reasonParameterRejected"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter.GetOwnerIfAny">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet">
            <summary>
            Often an ExtractionFilter will have a parameter associated with it (or more than one).  In this case it can be that you want to curate various values and give them
            meaningful titles.  For exmaple if you have a filter 'Hospitalised with condition X' which has parameter @ConditionList.  Then you decide that you want to curate
            a list 'A101.23,B21.1' as 'People hospitalised with drug dependency'.  This 'known meaningful parameter values set' is called a ExtractionFilterParameterSet.  You 
            can provide a name and a description for the concept.  Then you create a value for each parameter in the associated filter.  See ExtractionFilterParameterSetValue for
            the value recordings.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.Description">
            <summary>
            Human readable description of what the parameter set identifies e.g. 'Diabetes Drugs' and any supporting information about how it works, quirks etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.ExtractionFilter_ID">
            <summary>
            The filter which the parameter values are designed to work with
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.ExtractionFilter">
            <inheritdoc cref ="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.ExtractionFilter_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.Values">
            <summary>
            Gets all the individual parameter values required for populating the filter to achieve this concept (e.g. 'Diabetes Drugs' might have 2 parameter values @DrugList='123.122.1,1.2... etc' and @DrugCodeFormat='bnf')
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter,System.String)">
            <summary>
            Defines a new set of known parameter values to achieve a given goal (e.g. identify 'diabetic drugs' in dataset prescriptions) in combination with a parent <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/>.
            <para>A single <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.ExtractionFilter"/> (e.g. 'Drug Prescriptions of X' with parameter @DrugList) could have many <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet"/></para>
            </summary>
            <param name="repository"></param>
            <param name="filter"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.GetAllParameters">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.Values"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet.CreateNewValueEntries">
            <summary>
            Creates new value entries for each parameter in the filter that does not yet have a value in this value set
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue">
            <summary>
            Stores a known specific useful value for a given ExtractionFilterParameter.  See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet"/> for a use case for this.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameterSet_ID">
            <summary>
            The 'known good paramter set' (<see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameterSet"/>) to which this parameter value belongs
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameter_ID">
            <summary>
            The specific parameter that this object is providing a 'known value' for in the parent <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/> e.g. @DrugList='123.2,123.2,... etc'.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.Value">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ParameterName">
            <inheritdoc/>
            <remarks>Readonly, fetched from associated <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameter_ID"/></remarks>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ParameterSQL">
            <inheritdoc/>
            <remarks>Readonly, fetched from associated <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameter_ID"/></remarks>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.Comment">
            <inheritdoc/>
            <remarks>Readonly, fetched from associated <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameter_ID"/></remarks>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.GetOwnerIfAny">
            <summary>
            Returns the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameterSet"/> this known good value belongs to
            </summary>
            <returns></returns>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameterSet">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameterSet_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameter">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameter_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet,Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameter)">
            <summary>
            Creates a record of what value to use with the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> of the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameterSet"/> <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> to achieve the concept.
            
            <para>For example if there is an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/> 'Prescribed Drug X' with a parameter @DrugList and you create an <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameterSet"/>
            'Diabetic Drugs' then this will create a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue"/> of '@DrugList='123.23,121,2... etc'.</para>
            
            <para>If a filter has more than one parameter then you will need one <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue"/> per parameter per <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.ExtractionFilterParameterSet"/></para>
            </summary>
            <param name="repository"></param>
            <param name="parent"></param>
            <param name="valueIsForParameter"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSetValue.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation">
            <summary>
            Describes in a single line of SELECT SQL a transform to perform on an underlying ColumnInfo.  ExtractionInformation is the technical implementation 
            of what is described by a CatalogueItem.  Most ExtractionInformations in your database will just be direct extraction (verbatim) of the ColumnInfo
            however you might have simple transformations e.g. 'UPPER([MyDatabase]..[Users].[Name]' or even call complex SQL scalar functions for example
            'fn_CleanDrugCode([Prescribing]..[Items].[DrugCode])'
            
            <para>Note that alias is stored separately because it is useful for GetRuntimeName().  Also note that you should not have newlines in your SelectSQL 
            since this will likely confuse QueryBuilder.</para>
            
            <para>The interface ExtractionInformationUI handles all of these requirements transparentely.  Also recorded in ExtractionInformation is ExtractionCategory
            which lets you flag the sensitivity of the data being extracted e.g. SpecialApprovalRequired</para>
            
            <para>Finally one ExtractionInformation (and only one) in each CatalogueItem set (of parent Catalogue) must be flagged as IsExtractionIdentifier.  This 
            is the column which will be joined against cohorts in data extraction linkages.  This should be the private identifier you use to identify people
            in your datasets (e.g. Community Health Index or NHS Number).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.CatalogueItem_ID">
            <summary>
            The virtual column (description, name etc) to which this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> provides extraction SELECT SQL for.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.ExtractionCategory">
            <summary>
            Which governance conditions is this column/transform extractable under (e.g. Core, SpecialApprovalRequired etc) 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.CatalogueItem">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.CatalogueItem_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.ColumnInfo">
            <summary>
            The ColumnInfo that underlies this extractable column.  ExtractionInformation allows for transforms, governance rules and indicates extractability (Core / Supplemental etc)
            while the ColumnInfo is the concrete/immutable reference to the underlying column in the database from which the SelectSQL is executed.  This determines what tables are 
            joined on during query generation and which servers are connected to during query execution etc.  
            
            <para>This field can be null only if the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.ColumnInfo"/> has been deleted rendering this an orphan and broken.  This is considered a problem by 
            <see cref="T:Rdmp.Core.Providers.CatalogueProblemProvider"/> and as such it is the users responsibility to fix it, you shouldn't worry too much about null
            checking this field.</para> 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.ExtractionFilters">
            <summary>
            Gets all WHERE logic that can be used to reduce the number of records matched/extracted etc in cohort creation, project extractions etc.  These are master catalogue level
            filters (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/>) and act as templates that can be imported/cloned into other use cases (e.g. cohort identification, extraction etc).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.CatalogueItem,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,System.String)">
            <summary>
            Makes the given <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.CatalogueItem"/> which has an underlying column <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.ColumnInfo"/> in the data repository database extractable using the
            provided SQL code which must be a single line of SELECT sql.
            </summary>
            <param name="repository">Platform database to store the new object in</param>
            <param name="catalogueItem">The virtual column to make extractable (could be a transform e.g. YearOfBirth)</param>
            <param name="column">The column underlying the virtual column (e.g. `MyTable`.`DateOfBirth`)</param>
            <param name="selectSQL">The fully specified column name or transform SQL to execute as a line of SELECT Sql </param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.CatalogueItem)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.IsProperTransform">
            <summary>
            Returns true if the SELECT SQL is different from the fully qualified underlying column name e.g. 'UPPER(MyCol)' would return true.
            
            <para>Also returns true if the column is hashed</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Favourite">
            <summary>
            Allows you to store a record of a faviourite database object including all objects in Catalogue and DataExport databases.  The Objects type and ID are stored and then 
            whenever an RDMPCollectionUI is visible and that object is onscreen a star will appear beside it.  Favourites are stored on a 'per user' basis in the Catalogue database so 
            even if you switch computers/change sessions Favourites are preserved. 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Favourite.Username">
            <summary>
            The user that favourited the object
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Favourite.FavouritedDate">
            <summary>
            When the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Favourite.Username"/> favourited the object
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Favourite.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Records that the current Environment.UserName wants to mark the <paramref name="objectToFavourite"/> as one of his favourite objects
            </summary>
            <param name="repository"></param>
            <param name="objectToFavourite"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernanceDocument">
            <summary>
            Contains the path to a useful file which reflects either a request or a granting of governance e.g. a letter from your local healthboard authorising you to host/use 1 or more
            datasets for a given period of time.  Also includes a name (which should really match the file name) and a description which should be a plain summary of what is in the document
            such that lay users can appreciate what the document contains/means for the system.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernanceDocument.GovernancePeriod_ID">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod"/> for which this document is part of (either as a letter requesting approval, granting approval etc)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernanceDocument.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernanceDocument.Description">
            <summary>
            Human readable description/summary of the contents of the document, who sent it why it exists etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernanceDocument.URL">
            <summary>
            The location of the referenced document on disk
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernanceDocument.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod,System.IO.FileInfo)">
            <summary>
            Marks a given <paramref name="file"/> as being important in the obtaining of the <paramref name="parent"/> <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod"/>
            </summary>
            <param name="repository"></param>
            <param name="parent"></param>
            <param name="file"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernanceDocument.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernanceDocument.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the file exists
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernanceDocument.GetFilenameOnly">
            <summary>
            Returns the name of the file (See also <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernanceDocument.URL"/>)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod">
            <summary>
            A GovernancePeriod is used to track the fact that a given set of datasets requires external approval for your agency to hold.  This is not the same as releasing data
            to researchers or researcher approval to get specific extracts from you.  Governance Periods are concerned only with your agency and it's ability to hold datasets.  A 
            GovernancePeriod starts at a specific date and can optionally expire.  A GovernancePeriod relates to one or more Catalogues but Catalogues can have multiple GovernancePeriods
            e.g. if you require to get approval from 2 different external agencies to hold a specific dataset.  
            
            <para>GovernancePeriods are entirely optional, you can happily get by without configuring any for any of your Catalogues.  However once you have configured a GovernancePeriod for a
            specific Catalogue once then it will always require governance and be reported as Governance Expired in the Dashboard once it's GovernancePeriod has expired.</para>
            
            <para>The correct usage of GovernancePeriods is to never delete them e.g. your dataset
            MyDataset1 would have Governacne 2001-2002 (with attachment letters of approval) and another one for 2003-2004 and another from 2005 onwards etc.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.StartDate">
            <summary>
            When did the governance come into effect (in realtime not dataset time)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.EndDate">
            <summary>
            Does governane for the described datasets ever expire (e.g. if you need to get annual approval for holding datasets)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.Description">
            <summary>
            Who gave the governance and what it covers in human readable broad terms
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.Ticket">
            <summary>
            <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/> ticket number for tracking effort / progress towards obtaining the governance
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.GovernanceDocuments">
            <summary>
            All documents (emails sent, pdfs, letters of permission etc) that were involved in obtaining and which grant permission to hold the datasets described by the
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.GovernedCatalogues">
            <summary>
            All datasets to which this governance grants permission to hold
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.#ctor(MapsDirectlyToDatabaseTable.IRepository)">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod"/> in the database.  This grants (ethical) permission to hold datasets referenced by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.GovernedCatalogues"/>.
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the governance has not expired before it began etc
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.DeleteGovernanceRelationshipTo(Rdmp.Core.CatalogueLibrary.Data.ICatalogue)">
            <summary>
            Marks the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> as no longer requiring governance approval from this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod"/>.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.CreateGovernanceRelationshipTo(Rdmp.Core.CatalogueLibrary.Data.ICatalogue)">
            <summary>
            Declares that the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> requires governance to hold and that this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod"/> describes the specifics
            as well as any <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.EndDate"/> to the governance.
            
            <para>A <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> belonging to 0 <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod"/> is not assumed to require any governance.  A <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> can
            belong to multiple <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod"/> e.g. 'Tayside Governance 2001', 'Tayside Governance 2002' etc</para>
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.IsExpired">
            <summary>
            True if the current date is after the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod.EndDate"/> (if there is one)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.IAggregateTopX">
            <summary>
            See AggregateTopX
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IAggregateTopX.TopX">
            <summary>
            The number of records to return from the TopX e.g. Top 10
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IAggregateTopX.OrderByColumn">
            <summary>
            The dimension which the top X applies to, if null it will be the count / sum etc column (The AggregateCountColumn)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IAggregateTopX.OrderByDirection">
            <summary>
            When applying a TopX to an aggregate, this is the direction (Ascending/Descending) for the ORDER BY statement.  Descending means pick top X where
            count / sum etc is highest.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ICatalogue">
            <summary>
            The central class for the RDMP, a Catalogue is a virtual dataset e.g. 'Hospital Admissions'.  A Catalogue can be a merging of multiple underlying tables and exists 
            independent of where the data is actually stored (look at other classes like TableInfo to see the actual locations of data).
            
            <para>As well as storing human readable names/descriptions of what is in the dataset it is the hanging off point for Attachments (SupportingDocument), validation logic, 
            extractable columns (CatalogueItem->ExtractionInformation->ColumnInfo) ways of filtering the data, aggregations to help understand the dataset etc.</para>
            
            <para>Catalogues are always flat views although they can be built from multiple relational data tables underneath.</para>
            
            <para>Whenever you see Catalogue, think Dataset (which is a reserved class in C#, hence the somewhat confusing name Catalogue)</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.LoadMetadata_ID">
            <summary>
            The load configuration (if any) which is used to load data into the Catalogue tables.  A single <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.LoadMetadata"/> can load multiple Catalogues.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.LoggingDataTask">
            <summary>
            Name of a task in the logging database which should be used for documenting the loading of this Catalogue. 
            <seealso cref="T:Rdmp.Core.Logging.LogManager"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.LiveLoggingServer_ID">
            <summary>
            The ID of the logging server that is to be used to log data loads of the dataset <see cref="T:Rdmp.Core.Logging.LogManager"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.ValidatorXML">
            <summary>
            Currently configured validation rules for columns in a Catalogue, this can be deserialized into a HIC.Common.Validation.Validator
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.TimeCoverage_ExtractionInformation_ID">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> which indicates the time field (in dataset time) of the dataset.  This should be a column in your table
            that indicates for every row when it became active e.g. 'PrescribedDate' for prescribing.  Try to avoid using columns that have lots of nulls or 
            where the date is arbitrary (e.g. 'RecordLoadedDate')
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.PivotCategory_ExtractionInformation_ID">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> which can provide a useful subdivision of the dataset e.g. 'Healthboard'.  This should be a logical subdivision
            that helps in the assesment of data quality e.g. you might imagine that if you have 10% errors in data quality and 10 healthboards knowing that all the errors
            are from a single healthboard would be handy.
            
            <para>This chosen column should not have hundreds/thousands of unique values</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.IsInternalDataset">
            <summary>
            Bit flag indicating whether the dataset should NEVER be extracted and ONLY EVER used internally by data analysts.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.IsColdStorageDataset">
            <summary>
            Bit flag indicating whether the Catalogue is a seldom used dataset that should be hidden by default.  Use this if you are importing lots of researcher
            datasets for cohort generation / extraction but don't want them to clog up your user interface.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.DatasetStartDate">
            <summary>
            The alledged user specified date at which data began being collected.  For a more accurate answer you should run the DQE (See also DatasetTimespanCalculator)
            <para>This field is optional</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.TimeCoverage_ExtractionInformation">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.TimeCoverage_ExtractionInformation_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.PivotCategory_ExtractionInformation">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.PivotCategory_ExtractionInformation_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.LoadMetadata">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.LoadMetadata_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.CatalogueItems">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.AggregateConfigurations">
            <summary>
            Returns all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> that are associated with the Catalogue.  This includes both summary graphs, patient index tables and all
            cohort aggregates that are built to query this dataset.
            </summary>
            <seealso cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.LiveLoggingServer">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.LiveLoggingServer_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.Acronym">
            <summary>
            Shorthand (recommended 3 characters or less) for referring to this dataset (e.g. 'DEM' for the dataset 'Demography')
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetTableInfoList(System.Boolean)">
            <summary>
            Retrieves all the TableInfo objects associated with a particular catalogue
            </summary>
            <param name="includeLookupTables"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetLookupTableInfoList">
            <summary>
            Retrieves all the TableInfo objects associated with a particular catalogue
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetTableInfos(System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.ITableInfo}@,System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.ITableInfo}@)">
            <summary>
            Gets all distinct underlying <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> that are referenced by the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/>s of the Catalogue.  The tables are divided into
            'normalTables' and 'lookupTables' depending on whether there are any <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> declarations of <see cref="F:Rdmp.Core.CatalogueLibrary.Data.LookupType.Description"/> on any of the
            Catalogue referenced ColumnInfos.
            <para>The sets are exclusive, a TableInfo is either a normal data contributor or it is a linked lookup table</para>
            </summary>
            <param name="normalTables">Unique TableInfos amongst all CatalogueItems in the Catalogue</param>
            <param name="lookupTables">Unique TableInfos amongst all CatalogueItems in the Catalogue where there is at least
             one <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> declarations of <see cref="F:Rdmp.Core.CatalogueLibrary.Data.LookupType.Description"/> on the referencing ColumnInfo.</param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetDistinctLiveDatabaseServer(ReusableLibraryCode.DataAccess.DataAccessContext,System.Boolean,ReusableLibraryCode.DataAccess.IDataAccessPoint@)">
            <summary>
            Returns the unique <see cref="T:FAnsi.Discovery.DiscoveredServer"/> from which to access connect to in order to run queries generated from the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>.  This is 
            determined by comparing all the underlying <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> that power the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> of the Catalogue and looking for a shared
            servername.  This will handle when the tables are in different databases but only if you set <paramref name="setInitialDatabase"/> to false
            </summary>
            <param name="context"></param>
            <param name="setInitialDatabase">True to require all tables be in the same database.  False will just connect to master / unspecified database</param>
            <param name="distinctAccessPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetDistinctLiveDatabaseServer(ReusableLibraryCode.DataAccess.DataAccessContext,System.Boolean)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetDistinctLiveDatabaseServer(ReusableLibraryCode.DataAccess.DataAccessContext,System.Boolean,ReusableLibraryCode.DataAccess.IDataAccessPoint@)"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetAllSupportingSQLTablesForCatalogue(Rdmp.Core.CatalogueLibrary.Data.FetchOptions)">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetAllExtractionInformation(Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory)">
            <summary>
            Returns all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> declared under this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/>s.  This can be restricted by 
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory"/> 
            
            <para>pass <see cref="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.Any"/> to fetch all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> regardless of category</para>
            </summary>
            <param name="category"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetAllSupportingDocuments(Rdmp.Core.CatalogueLibrary.Data.FetchOptions)">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetAllMandatoryFilters">
            <summary>
            Gets all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/> declared under any <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> in the Catalogue where the  <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IFilter.IsMandatory"/> flag is set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetAllFilters">
            <summary>
            Gets all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/> declared under any <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> in the Catalogue.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetDistinctLiveDatabaseServerType">
            <summary>
            Returns the unique <see cref="T:FAnsi.DatabaseType"/> shared by all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> which underlie the Catalogue.  This is similar to GetDistinctLiveDatabaseServer 
            but is faster and more tolerant of failure i.e. if there are no underlying <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> at all or they are on different servers this will still return
            the shared / null <see cref="T:FAnsi.DatabaseType"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.GetExtractabilityStatus(Rdmp.Core.Repositories.IDataExportRepository)">
            <summary>
            Returns the extractability of the Catalogue if it is known.  If it is not known then the repository will be used to find out (and the result will be cached)
            <para>If a null dataExportRepository is passed then you will get the cached answer or null</para>
            </summary>
            <param name="dataExportRepository">Pass null to fetch only the cached value (or null if that is not known)</param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ICollectSqlParameters">
            <summary>
            Interface for all objects which can have one or more sql parameter associated with them.  For example an IFilter (line of WHERE Sql) might have 2 parameters @startDate
            and @endDate then GetAllParameters should return the two ISqlParameter objects that contain the DECLARE, Comment and Value setting Sql bits for these parameters.
            
            <para>Each ISqlParameter should only ever have a single owner.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ICollectSqlParameters.GetAllParameters">
            <summary>
            Returns all parameters declared directly against2 the current object.  This does not normally include sub objects existing below the current
            object which might have their own <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.FilterContainerOperation">
            <summary>
            Describes which logical keyword to use to interspace IFilters (and sub IContainers) within an IContainer.  If you have an IContainer with only one IFilter in it then
            it makes no difference which FilterContainerOperation you specify.  Once an IContainer has more than one IFilter they will be seperated with the 
            FilterContainerOperation (AND / OR See SqlQueryBuilderHelper)
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.FilterContainerOperation.AND">
            <summary>
            Subcontainers / filters should be separated by the AND SQL keyword
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.FilterContainerOperation.OR">
            <summary>
            Subcontainers / filters should be separated by the OR SQL keyword
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.IContainer">
            <summary>
            Interface for grouping IFilters (lines of WHERE Sql) into an AND/OR tree e.g. WHERE ('Hb is Tayside' OR 'Record is older than 5 months') AND 
            ('result is clinically significant').  Each subcontainer / IFilter are seperated with the Operation (See FilterContainerOperation) when building SQL
            (See SqlQueryBuilderHelper).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IContainer.Operation">
            <summary>
            Defines the boolean operation (AND / OR) to separate contained lines of WHERE Sql (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/>).  If the container has only one IFilter
            then no operation is used, if there are 2+ then the resultant SQL built will be each filter's WhereSQL separated by the AND/OR.  This also applies to 
            subcontainers e.g. an IContainer AND with two subcontainers will have the resultant SQL from compiling the two subcontainers separated by the AND/OR of the
            current IContainer.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IContainer.GetParentContainerIfAny">
            <summary>
            Gets the parental IContainer that this IContainer is a subcontainer of (inside).  This will return null if the IContainer is a root level container or an orphan.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IContainer.GetSubContainers">
            <summary>
            Gets a list of all the IContainers that are subcontainers of the this ones.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IContainer.GetFilters">
            <summary>
            Gets all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> (lines of Where SQL) which are in the current IContainer.
            </summary>
            <remarks>This only includes IFilters in the current IContainer, if you want to also include subcontainers then use
             <see cref="M:Rdmp.Core.CatalogueLibrary.Data.IContainer.GetAllFiltersIncludingInSubContainersRecursively"/></remarks>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IContainer.AddChild(Rdmp.Core.CatalogueLibrary.Data.IContainer)">
            <summary>
            Makes the specified IContainer into a child of this current IContainer.  This is a branch level operation so will include all subcontainers/filters of the moved
            IContainer moving with it.
            </summary>
            <param name="child"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IContainer.AddChild(Rdmp.Core.CatalogueLibrary.Data.IFilter)">
            <summary>
            Makes the specified IFilter a child of this current IContainer.  This will result in it not being a part of any previous IContainer it might have been in.
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IContainer.MakeIntoAnOrphan">
            <summary>
            Removes the IContainer from any parent IContainer it might be inside effectively turning it into an orphan (unless it is already referenced as a root container
            e.g. by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.RootFilterContainer_ID"/>).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IContainer.GetRootContainerOrSelf">
            <summary>
            Returns the absolute top level root IContainer of the hierarchy that the container is a part of.  If the specified container is already a root level container
            or it is an orphan or part of it's hierarchy going upwards is an orphan then the same container reference will be returned.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IContainer.GetAllSubContainersRecursively">
            <summary>
            Returns all IContainers that are declared as below the current IContainer (e.g. children).  This includes children of children etc down the tree.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IContainer.GetAllFiltersIncludingInSubContainersRecursively">
            <summary>
            Returns all IFilters that are declared in the current container or any of it's subcontainers (recursively).  This includes children of children 
            etc down the tree.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IContainer.GetCatalogueIfAny">
            <summary>
            If the IContainer is not part of an orphan hierarchy then there will be a resolvable root IContainer which will be referenced by something e.g. an
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>.  This method returns the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> which that the root object operates on.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.IEncryptedString">
            <summary>
            A string which can be decrypted.  GetDecryptedValue might throw if the user doesn't have access  to the decryption algorithm / artifacts. Allows transmission of a 
            string without nessesarily having access to the decrypted value.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IEncryptedString.Value">
            <inheritdoc cref="P:ReusableLibraryCode.DataAccess.IEncryptedPasswordHost.Password"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IEncryptedString.GetDecryptedValue">
            <inheritdoc cref="M:ReusableLibraryCode.DataAccess.IEncryptedPasswordHost.GetDecryptedPassword"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IEncryptedString.IsStringEncrypted(System.String)">
            <summary>
            Returns true if the <paramref name="value"/> looks like it is encrypted
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.IExternalDatabaseServer">
            <summary>
            See ExternalDatabaseServer
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IExternalDatabaseServer.WasCreatedBy(MapsDirectlyToDatabaseTable.Versioning.IPatcher)">
            <summary>
            Determines whether the given database server was created by the specified patcher assembly e.g. (CatalogueLibrary.Database.dll).  If it is then the 
            schema will match, database objects will be retrievable through the host assembly (e.g. DataQualityEngine.dll) etc.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IExternalDatabaseServer.Discover(ReusableLibraryCode.DataAccess.DataAccessContext)">
            <summary>
            Provides a live object for interacting directly with the server referenced by this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IExternalDatabaseServer"/>.  This will wokr
            even if the server is unreachable (See <see cref="T:FAnsi.Discovery.IMightNotExist"/>)
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.IExtractableDataSetPackage">
            <summary>
            A collection of ExtractableDataSet which share a common concept e.g. 'Core datasets', 'Supplemental Datasets', 'Diabetes datasets' etc. These allow you to add a collection of 
            datasets to a project extraction in one go and to standardise who gets what datasets.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.IExtractionResults">
            <summary>
            Record of a single component extracted as part of an <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>.  This could be an anonymised dataset or bundled supporting
            documents e.g. Lookups , pdfs etc.  This audit is used to perform release process (where all extracted artifacts are collected and sent somewhere).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IExtractionResults.DestinationDescription">
            <summary>
            Description of the file path, database table name etc of the extracted artifact.  This must make sense to the pipeline
            component which extracted the artifact (See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IExtractionResults.DestinationType"/>)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IExtractionResults.DestinationType">
            <summary>
            Type of the destination (final) component in the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline"/> used for extraction.  This is required so that
            artifacts can be collected again e.g. for release (Releasing from a flat file destination is different from releasing
            from a to database extraction).  
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IExtractionResults.RecordsExtracted">
            <summary>
            Total number of records in the dataset extracted
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IExtractionResults.DateOfExtraction">
            <summary>
            When the extraction began
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IExtractionResults.Exception">
            <summary>
            Null if the extraction completed succesfully.  Otherwise populated with the fatal error that caused the extraction to stop.
            
            <para>If this is not null then the extraction is considered to have been a failure.</para> 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IExtractionResults.SQLExecuted">
            <summary>
            The SQL Query used to extract records.  It is important that this is accurate since it is used to detect configuration changes
            (e.g. when trying to release a dataset in which the extracted artifacts are stale due to configuration changes in the live system vs
            the audit).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IExtractionResults.GetDestinationType">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IExtractionResults.DestinationType"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IExtractionResults.CompleteAudit(System.Type,System.String,System.Int32)">
            <summary>
            Finalises an ongoing extraction audit.  This should only be called once at the end of the extraction process.  
            </summary>
            <param name="destinationType">Type of the destination (final) component in the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline"/> used for extraction</param>
            <param name="destinationDescription"></param>
            <param name="recordsExtracted">Total number of records in the dataset extracted</param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.IFilter">
            <summary>
            A line of WHERE sql which can be combined in IContainers.  IFilters can be either ConcreteFilter (there is persisted user defined database object that makes 
            up the IFilter) or SpontaneouslyInventedFilter.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IFilter.WhereSQL">
            <summary>
            Single line of WHERE Sql for use in query generation.  Does not include the WHERE keyword.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IFilter.Description">
            <summary>
            Human readable description of what the WHERE logic is supposed to achieve (e.g. Tayside records only)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IFilter.IsMandatory">
            <summary>
            True if the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> should always be used with the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> it is associated with if any (See <see cref="M:Rdmp.Core.CatalogueLibrary.Data.IFilter.GetCatalogue"/>).
            
            <para>This results in the filter being added to <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> , extarctions etc by default when the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> is added</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IFilter.ClonedFromExtractionFilter_ID">
            <summary>
            Only applicable for non Catalogue level filters (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/>) i.e. derrived/deployed filters.  This is the ID of the original master <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/>
            that the current filter was cloned as a copy of.
            
            <para>Null if a master filter (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/>) or a deployed filter that was written from scratch </para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IFilter.FilterContainer_ID">
            <summary>
            An IFilter is a line of WHERE SQL.  To be used by a query builder it must be in an AND/OR <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IContainer"/>.  The container will determine which operator is used
            to separate the lines of SQL when combined.  Obviously if there is only one IFilter in an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IContainer"/> then no separation operator will be in the resulting
            query.  This property is the ID of the current container.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IFilter.FilterContainer">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IFilter.FilterContainer_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IFilter.GetColumnInfoIfExists">
            <summary>
            Fetches the underlying <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> for the column (e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/>) which this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> is ultimately associated with).
            
            <para>This mostly applies to master top level filters <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/> and cloned copies and helps identify which tables to join to during query building</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IFilter.GetFilterFactory">
            <summary>
            Gets an appropriate <see cref="T:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.IFilterFactory"/> for creating arguments and other filters of the Type compatible the derrived class (e.g. if the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> is an
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/> then an <see cref="T:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.ExtractionFilterFactory"/>  would be returned). 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IFilter.GetCatalogue">
            <summary>
            Gets the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> that this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> is designed to be run on.  This should return a value regardless of the Type of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> e.g. 
            master level or deployed as part of project extractions / cohort identification configurations.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.IJoin">
            <summary>
            Describes how to join two tables together.  This is used to during Query Building (See JoinHelper) to build the JOIN section of the query once all required tables
            have been identified (See SqlQueryBuilderHelper).  
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.ForeignKey">
            <summary>
            The column in the secondary table that should be joined iwth the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.PrimaryKey"/> column
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.PrimaryKey">
            <summary>
            The column in the main table which should be joined
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.Collation">
            <summary>
            The collation type to apply to the join if <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.ForeignKey"/> and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.PrimaryKey"/> have different column collations.  If there are <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISupplementalJoin"/> 
            then they must match on <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.Collation"/>
            
            <para>Only set this if you are sure you have a collation problem</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.ExtractionJoinType">
            <summary>
            Which SQL join keyword to use when linking the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.PrimaryKey"/> and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.ForeignKey"/>.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IJoin.GetSupplementalJoins">
            <summary>
            If it is nessesary to join on more than one column, use this method to indicate the aditional fk / pk pairs (they must belong to the same TableInfos as the 
            main IJoin)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IJoin.GetInvertedJoinType">
            <summary>
            The ExtractionJoinType Property models Left/Right/Inner when the SqlQueryBuilderHelper finds the PrimaryKey TableInfo and needs to join to the ForeignKey table
            (the normal situation). However if the ForeignKey TableInfo is required first (either because it is IsPrimaryExtractionTable or because there are other tables
            in the query that force a particular join order) then the Join direction needs to be inverted.  Normally this is a matter of swapping Left=>Right and vice versa
            but you might instead want to throw NotSupportedException if you are expecting a specific direction (See Lookup)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress">
            <summary>
            Describes the progress of a long term epic data load operation which cannot be completed in a single Data load bubble (execution of LoadMetadata through the data load engine).
            This entity includes start and end dates for what is trying to be loaded as well as how far through that process progess has been made up to.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress.OriginDate">
            <summary>
            The date the dataset starts at, this is in dataset time e.g. if you have prescribing records held from 2001-01-01 to present then the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress.OriginDate"/> is 2001-01-01
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress.DataLoadProgress">
            <summary>
            Records how far through the process of loading data into this dataset.  This is updated at the end of a successful data load for a given date range (E.g. the next 10 days
            due to be loaded) 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress.LoadMetadata_ID">
            <summary>
            The data load that this object records progress for.  You can have multiple <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress"/> for a single <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata"/> (data load) for example you 
            might have loaded Tayside data into biochemistry up to 2017-01-01 but for Fife you have only loaded data up to 2015-01-01 so far.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress.LoadMetadata">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress.LoadMetadata_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress.CacheProgress">
            <summary>
            If the data load involves iteratively loading dat from a date based cache of fetched data then this will be the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress"/> which is responsible for fetching
            and saving the cached data to disk (this occurs seperately from the data loading).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress.IsDisabled">
            <summary>
            Do not use, is not respected
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress.DefaultNumberOfDaysToLoadEachTime">
            <summary>
            The number of days to load each time the DLE is run with the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress"/>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.IMasqueradeAs">
            <summary>
            If you are a wrapper masquerading as another class e.g. <see cref="T:Rdmp.Core.Providers.Nodes.LoadMetadataNodes.CatalogueUsedByLoadMetadataNode"/>
             is a class masquerading as an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IMasqueradeAs.MasqueradingAs">
            <summary>
            Gets the object that the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IMasqueradeAs"/> is pretending to be (wrapping).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport">
            <summary>
            Identifies an object in the local Catalogue database (or DataExport database) which has been shared externally (via it's SharingUID).  The use of a SharingUID
            allows multiple external users to access and import the shared object (and any dependant objects).  Having an ObjectExport declared on an object prevents it from
            being deleted (see ObjectSharingObscureDependencyFinder) since this would leave external users with orphaned objects.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport.SharingUID">
            <summary>
            The globally unique identifier for refering to the shared object.  This allows the object to be updated later / new versions to be distributed
            even though the ID is different (e.g. it has been imported into another instance of RDMP).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport.SharingUIDAsGuid">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport.SharingUID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable,System.Guid)">
            <summary>
            use <see cref="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetNewOrExistingExportFor(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)"/> for easier access to this constructor
            </summary>
            <param name="repository"></param>
            <param name="objectForSharing"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport.#ctor(MapsDirectlyToDatabaseTable.IRepository,System.Data.Common.DbDataReader)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport">
            <summary>
            Identifies an object in the local Catalogue database (or DataExport database) which was imported from an external catalogue (See ObjectExport).  The SharingUID
            allows you to always identify which local object represents a remoted shared object (e.g. available from a web service).  The remote object will have a different
             ID but the same SharingUID).  Sometimes you will import whole networks of objects which might have shared object dependencies in this case newly imported 
            networks will reference existing imported objects where they are already available.
            
            <para>This table exists to avoid all the unmaintainability/scalability of IDENTITY INSERT whilst also ensuring referential integrity of object shares and preventing
            duplication of imported objects.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport.SharingUID">
            <summary>
            The globally unique identifier for refering to the shared object.  This allows the object to be updated later / new versions to be distributed
            even though the ID is different (e.g. it has been imported into another instance of RDMP).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport.SharingUIDAsGuid">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport.SharingUID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String,MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Use GetImportAs to access this
            </summary>
            <param name="repository"></param>
            <param name="sharingUID"></param>
            <param name="localObject"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport.#ctor(MapsDirectlyToDatabaseTable.IRepository,System.Data.Common.DbDataReader)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager">
            <summary>
            Handles querying/updating the ObjectExport and ObjectImport tables (See ObjectExport and ObjectImport classes).  These tables record which objects have
            been shared externally (with a SharingUID) or imported locally.  This table handles tasks such as identifying whether a given object is shared or not
            as well as handling the import process (in which a MapsDirectlyToDatabaseTableStatelessDefinition is translated into a local object and an ObjectImport
            record is created - to allow updating/synchronising later on).
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.RepositoryLocator">
            <summary>
            Tells the location of the platform databases to create objects/import references in
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.LocalReferenceGetter">
            <summary>
            Delegate method for populating environment specific properties e.g. <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ICatalogue.LiveLoggingServer_ID"/> when importing 
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/> since this ID will be different from the origin.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.#ctor(Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator,Rdmp.Core.CatalogueLibrary.Data.ImportExport.LocalReferenceGetterDelegate)">
            <summary>
            Creates a new manager for importing and exporting objects from the given platform databases
            </summary>
            <param name="repositoryLocator"></param>
            <param name="localReferenceGetter"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetPersistenceString(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Gets a serializated representation of the object, this is a reference to the object by ID / SharingUID (if it has one) not a list of all it's property values.
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetObjectFromPersistenceString(System.String)">
            <summary>
            Deserializes the given persistence string (created by <see cref="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetPersistenceString(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)"/>) into an actual database object.  The 
            <paramref name="persistenceString"/> is a pointer (ID / SharingUI) of the object not a value serialization.  If you want to export the
            definition use <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/> or Gatherer instead
            </summary>
            <param name="persistenceString"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.IsExportedObject(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Returns true if there is an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport"/> declared which matches the provided object <paramref name="o"/>
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.IsImportedObject(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Returns true if there is an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport"/> declared which matches the provided object <paramref name="o"/>
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.IsImported(System.String)">
            <summary>
            Returns true if an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport"/> has been declared for the given shared object identified by it's <paramref name="sharingUID"/>
            </summary>
            <param name="sharingUID"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetNewOrExistingExportFor(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Returns an existing export definition for the object o or generates a new one.  This will give you a SharingUID and 
            enable the object for sharing with other users who have RDMP.
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingImportObject(System.String)">
            <summary>
            Returns the local object which was imported under the given <paramref name="sharingUID"/> (or null if the object has never
            been imported)
            </summary>
            <param name="sharingUID"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingImportObject(System.Guid)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingImportObject(System.String)"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingExportObject(System.String)">
            <summary>
            Returns the local object which was exported under the given <paramref name="sharingUID"/> (or null if the object has never
            been exported)
            </summary>
            <param name="sharingUID"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingExportObject(System.Guid)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingExportObject(System.String)"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingImport(System.String)">
            <summary>
            Returns a matching ObjectImport for the provided sharingUID or null if the UID has never been imported
            </summary>
            <param name="sharingUID"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingImport(System.Guid)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingImport(System.String)"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingExport(System.String)">
            <summary>
            Returns a matching ObjectExport for the provided sharingUID or null if the UID has never been imported
            </summary>
            <param name="sharingUID"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingExport(System.Guid)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetExistingExport(System.String)"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetImportAs(System.String,MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Marks the given local object <paramref name="o"/> as an imported instance of a shared object (identified by it's <paramref name="sharingUID"/>)
            </summary>
            <param name="sharingUID"></param>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetAllImports">
            <summary>
            Gets all import definitions (ObjectImport) defined in the Catalogue database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.DeleteAllOrphanImportDefinitions">
            <summary>
            Deletes all import definitions (ObjectImport) for which the referenced object (IMapsDirectlyToDatabaseTable) no longer exists (has been deleted)
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.ImportSharedObject(System.IO.Stream,System.Boolean)">
            <summary>
            Reads and deserializes the .so file into objects in the database
            </summary>
            <param name="sharedObjectsFile"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.ImportSharedObject(System.String,System.Boolean)">
            <summary>
            Creates imported objects from a serialized list of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/> - usually loaded from a .so file (See Sharing.Dependency.Gathering.Gatherer)
            </summary>
            <param name="sharedObjectsFileText"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetShareDefinitionList(System.String)">
            <summary>
            Deserializes the json which must be the contents of a .sd file i.e. a ShareDefinitionList
            </summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.ImportSharedObject(System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition})">
            <summary>
            Imports a list of shared objects and creates local copies of the objects as well as marking them as <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport"/>s
            </summary>
            <param name="toImport"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.ImportSharedObject(System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition},System.Boolean)">
            <summary>
            Imports a list of shared objects and creates local copies of the objects as well as marking them as <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport"/>s
            </summary>
            <param name="toImport"></param>
            <param name="deleteExisting">Deletes the object if the object has already been imported previously (not a good idea).</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetLocalReference(System.Reflection.PropertyInfo,MapsDirectlyToDatabaseTable.Attributes.RelationshipAttribute,Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition)">
            <summary>
            When importing a <paramref name="shareDefinition"/> for a child class with a parent, this method will return the ID of parent for the given <paramref name="property"/>
            on the child.  For example if you are importing a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/> for a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/> then the property <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue_ID"/> should 
            have the ID of the locally held <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> to which it will become a part of.
            </summary>
            <param name="property">The child class property you need to fill e.g. <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue_ID"/></param>
            <param name="relationshipAttribute">The attribute that decorates the <paramref name="property"/> which indicates what type of object the parent is etc</param>
            <param name="shareDefinition">The serialization of the child you are trying to import</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.ImportPropertiesOnly(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable,Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition)">
            <summary>
            Updates the user configurable (non ID) properties of the object <pararef name="o"/> to match the <paramref name="shareDefinition"/>
            </summary>
            <param name="o"></param>
            <param name="shareDefinition"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.LocalReferenceGetterDelegate">
            <inheritdoc cref="F:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.LocalReferenceGetter"/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.SharingException">
            <summary>
            Thrown when there are problems importing or exporting objects from RDMP (either in gathering dependencies or loading <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.SharingException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.SharingException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow">
            <summary>
            Describes a period of time in which a given act can take place (e.g. only cache data from the MRI imaging web service during the hours of 11pm - 5am so as not to 
            disrupt routine hospital use).  Also serves as a Locking point for job control.  Once an IPermissionWindow is in use by a process (e.g. Caching Pipeline) then it
            is not available to other processes (e.g. loading or other caching pipelines that share the same IPermissionWindow).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow.Description">
            <summary>
            Human readable description of the period of time described e.g. 'weekday nights only because we dont want to hit local server backup periods'
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow.RequiresSynchronousAccess">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow.CacheProgresses">
            <summary>
            All caching activities which are restricted to running in this time window
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow.PermissionWindowPeriods">
            <summary>
            The time windows that the activity is allowed in
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow.WithinPermissionWindow">
            <summary>
            Returns true if the current time is within one of the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow.PermissionWindowPeriods"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow.WithinPermissionWindow(System.DateTime)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow.WithinPermissionWindow"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow.SetPermissionWindowPeriods(System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod})">
            <summary>
            Sets the time of day that activities are permitted in
            </summary>
            <param name="windowPeriods"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.IProjectCohortIdentificationConfigurationAssociation">
            <summary>
            Records the fact that a given Cohort Identification Configuration (query that identifies a cohort) is associated with a given Project.  You can have multiple
            associated configurations in a given project (e.g. cases, controls, time based etc).  You can also associate the same configuration with multiple Projects if
            you need to.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IProjectCohortIdentificationConfigurationAssociation.Project_ID">
            <summary>
            The <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> to which the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IProjectCohortIdentificationConfigurationAssociation.CohortIdentificationConfiguration_ID"/> is associated with.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IProjectCohortIdentificationConfigurationAssociation.CohortIdentificationConfiguration_ID">
            <summary>
            The <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IProjectCohortIdentificationConfigurationAssociation.CohortIdentificationConfiguration"/> which is associated with the given <see cref="P:Rdmp.Core.CatalogueLibrary.Data.IProjectCohortIdentificationConfigurationAssociation.Project_ID"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IProjectCohortIdentificationConfigurationAssociation.Project">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IProjectCohortIdentificationConfigurationAssociation.Project_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.IProjectCohortIdentificationConfigurationAssociation.CohortIdentificationConfiguration">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IProjectCohortIdentificationConfigurationAssociation.CohortIdentificationConfiguration_ID"/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter">
            <summary>
            Class for persisting the Comment, type and value of an Sql Parameter (e.g. /*mycool variable*/ DECLARE @bob as Varchar(10); Set @bob = 'fish').  RDMP supports 
            parameter overriding and merging duplicate parameters etc during query building (See ParameterManager).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter.ParameterName">
            <summary>
            The name only of the parameter e.g. @bob, this should be automatically calculated from the ParameterSQL to avoid any potential for mismatch
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter.ParameterSQL">
            <summary>
            The full SQL declaration for the parameter e.g. 'DECLARE @bob as Varchar(10);'.  This must include the pattern @something even if the SQL language does not
            require declaration (e.g. mysql), the easiest way to support this is to set the ParameterSQL to a comment block e.g. '/*@bob*/'
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter.Value">
            <summary>
            The value that the SQL parameter currently holds.  This should be a valid Right hand side operand for the assignment operator e.g. 'fish' or 10 or UPPER('omg') 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter.Comment">
            <summary>
            An optional description of what the parameter represents.  This will be included in SQL generated and will be wrapped in an SQL comment block.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter.GetOwnerIfAny">
            <summary>
            Returns the <see cref="T:MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable"/> (usually an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/>) that the parameter is declared on.  If the parameter is a global level
            parameter e.g. declared at <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> level then the corresponding higher level object will be returned 
             (e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter"/>).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ISupplementalExtractionResults">
            <summary>
            Describes the extraction status of a supplemental file/table which was bundled along with the normal datasets being extracted.  This could
            be lookup tables, pdf documents, etc.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ISupplementalExtractionResults.CumulativeExtractionResults_ID">
            <summary>
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISupplementalExtractionResults"/> is an audit class for supplemental artifacts produced in an extraction (e.g. Lookup tables).  This
            property points to the main audit record (of the dataset - see <see cref="T:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults"/>).
            
            <para>This is null if the artifact is a Global (always extracted)</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ISupplementalExtractionResults.ExtractionConfiguration_ID">
            <summary>
            Only populated if the artifact is a Global (always extracted).  This points to the <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> being extracted
            when the global was produced.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ISupplementalExtractionResults.IsGlobal">
            <summary>
            True if the artifact extracted did not relate to a specific dataset (e.g. a Lookup) but to extract as a while.  This is determined 
            by looking at whether <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ISupplementalExtractionResults.CumulativeExtractionResults_ID"/> or <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ISupplementalExtractionResults.ExtractionConfiguration_ID"/> is populated.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ISupplementalExtractionResults.ExtractedName">
            <summary>
            The Name of the object that was extracted (this is the logical name not the path e.g. "HelpDocs pdf file")
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ISupplementalJoin">
            <summary>
            Interface for additional join column pairs required by an IJoin.  This is only applicable if you need to join two tables using multiple columns at once.  E.g. A left join B
            on A.x = B.x and A.y=B.y.  ISupplementalJoin is assumed to follow the same direction as the principal IJoin.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ISupplementalJoin.ForeignKey">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.ForeignKey"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ISupplementalJoin.PrimaryKey">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.PrimaryKey"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ISupplementalJoin.Collation">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.Collation"/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ISupportingObject">
            <summary>
            An object that helps understanding a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ITableInfo">
            <summary>
            A persistent reference to an existing Database Table (See TableInfo).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.Schema">
            <summary>
            The Schema scope of the table (or blank if dbo / default / not supported by dbms).  This scope exists below Database and Above Table.  Not all database management
            engines support the concept of Schema (e.g. MySql).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.IsTableValuedFunction">
            <summary>
            True if the table referenced is an sql server table valued function (which probably takes parameters)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.IdentifierDumpServer_ID">
            <summary>
            The server that stores <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn"/> values which do not make it to LIVE during a data load e.g. because they contain identifiable data that
            must be split off (e.g. <see cref="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.DiscardedColumnDestination.StoreInIdentifiersDump"/>).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.GetRuntimeName(Rdmp.Core.CatalogueLibrary.Data.LoadBubble,Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads)">
            <summary>
            Gets the name of the table in the given RAW=>STAGING=>LIVE section of a DLE run using the provided <paramref name="tableNamingScheme"/>
            </summary>
            <param name="bubble"></param>
            <param name="tableNamingScheme"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.GetRuntimeName(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage,Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.GetRuntimeName(Rdmp.Core.CatalogueLibrary.Data.LoadBubble,Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads)"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.ColumnInfos">
            <summary>
            Fetches all the ColumnInfos associated with this TableInfo (This is refreshed every time you call this property)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.PreLoadDiscardedColumns">
            <summary>
            Gets all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn"/> declared against this table reference.  These are virtual columns which 
            do not exist in the LIVE table schema (Unless <see cref="F:Rdmp.Core.CatalogueLibrary.Data.DataLoad.DiscardedColumnDestination.Dilute"/>) but which appear in the RAW 
            stage of the data load.  
            
            <para>See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn"/> for more information</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.IsLookupTable">
            <summary>
            True if the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> has <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> relationships declared which make it a linkable lookup table in queries.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.GetDatabaseRuntimeName(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage,Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads)">
            <summary>
            Returns the <see cref="P:ReusableLibraryCode.DataAccess.IDataAccessPoint.Database"/> name at the given <paramref name="loadStage"/> of a DLE run (RAW=>STAGING=>LIVE)
            </summary>
            <param name="loadStage"></param>
            <param name="namer"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.GetColumnsAtStage(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <summary>
            Returns all column names for the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage"/> (RAW=>STAGING=>LIVE) of a data load
            </summary>
            <param name="loadStage"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.ITableInfo.Discover(ReusableLibraryCode.DataAccess.DataAccessContext)">
            <summary>
            Creates an object for interacting with the table as it exists on the live server referenced by this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/>
            <para>This will not throw if the table doesn't exist, instead you should use <see cref="M:FAnsi.Discovery.DiscoveredTable.Exists(FAnsi.Connections.IManagedTransaction)"/> on the
            returned value</para>
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.LookupType">
            <summary>
            Lookup relationships in RDMP are defined using 3 columns, a PrimaryKey from one table and a ForeignKey which appears in the lookup and the Description column
            which must also appear in the ForeignKey table.  This Enum is used to identify which ColumnInfo you are addressing in this relationship.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.LookupType.Description">
            <summary>
            The column in the Lookup table which contains the description of what a code means
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.LookupType.AnyKey">
            <summary>
            Used for Fetching only, this value reflects either the PrimaryKey or the ForeignKey (but not the Description).  Used for example to find out 
            all the Lookup involvements of a given ColumnInfo.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.LookupType.ForeignKey">
            <summary>
            The column in the lookup table which contains the code
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionJoinType">
            <summary>
            The type of ANSI Sql Join to direction e.g. Left/Right
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionJoinType.Left">
            <summary>
            All records from the table on the left and any matching ones from the table on the right (otherwise null for those fields)
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionJoinType.Right">
            <summary>
            All records from the table on the right and any matching ones from the table on the left (otherwise null for those fields)
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionJoinType.Inner">
            <summary>
            Only records where the primary/foreign keys match exactly between both tables (the right and the left)
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.JoinInfo">
            <summary>
            Persistent reference in the Catalogue database that records how to join two TableInfos.  You can create instances of this class via JoinHelper (which is available as
            a property on ICatalogueRepository).  JoinInfos are processed by during query building in the following way:
            
            <para>1. Query builder identifies all the TablesUsedInQuery (from the columns selected, forced table inclusions etc)
            2. Query builder identifies all available JoinInfos between the TablesUsedInQuery (See SqlQueryBuilderHelper.FindRequiredJoins)
            3. Query builder merges JoinInfos that reference the same tables together into Combo Joins (See AddQueryBuildingTimeComboJoinDiscovery)
            4. Query builder creates final Join Sql </para>
            
            <para>'Combo Joins' (or ISupplementalJoin) are when you need to use multiple columns to do the join e.g. A Left Join B on A.x = B.x AND A.y = B.y.  You can define
            these by simply declaring additional JoinInfos for the other column pairings with the same ExtractionJoinType.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.ForeignKey_ID">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.ForeignKey"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.PrimaryKey_ID">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.PrimaryKey"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.Collation">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.ExtractionJoinType">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.ForeignKey">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.PrimaryKey">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.#ctor(MapsDirectlyToDatabaseTable.IRepository,System.Data.Common.DbDataReader)">
            <summary>
            Constructor to be used to create already existing JoinInfos out of the database only.
            </summary>
            <param name="repository"></param>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.AddQueryBuildingTimeComboJoinDiscovery(Rdmp.Core.CatalogueLibrary.Data.JoinInfo)">
            <summary>
            Notifies the join that other columns also need to be joined at runtime (e.g. when you have 2+ column pairs all of
            which have to appear on the SQL ON section of the query
            </summary>
            <param name="availableJoin"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.GetSupplementalJoins">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.GetInvertedJoinType">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.QueryTimeComboJoin.ForeignKey">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.ForeignKey"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.QueryTimeComboJoin.PrimaryKey">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.PrimaryKey"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.QueryTimeComboJoin.Collation">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.Collation"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.SetKnownColumns(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo)">
            <summary>
            Tells the the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.JoinInfo"/> what the objects are referenced by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.PrimaryKey_ID"/> and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.ForeignKey_ID"/>
            so that it doesn't have to fetch them from the database.
            </summary>
            <param name="primaryKey"></param>
            <param name="foreignKey"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.JoinInfo.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.LoadBubble">
            <summary>
            A data load engine database stage, all tables being loaded go through each of these stages (RAW=>STAGING=>LIVE).  Archive is where redundant old replaced records are moved to on successful data loading
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.LoadBubble.Raw">
            <summary>
            The temporary unconstrained database created during a data load execution into which identifiable data is loaded and data 
            integrity issues (null records, normalisation etc) occurs
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.LoadBubble.Staging">
            <summary>
            The constrained database into which all records in a data load are written to before applying an UPSERT into the live table of
            new records.
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.LoadBubble.Live">
            <summary>
            The live database containing your clinical data
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.LoadBubble.Archive">
            <summary>
            The _Archive table in your live database into which historic records are moved when an UPDATE happens during data load
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly">
            <summary>
            This entity is a DLL (Dynamic Link Library - AKA Assembly) of compiled C# code that is either a MEF (Managed Extensibility Framework) plugin or a dependency of a MEF
            plugin.  Plugins add third party extension functionality (not part of the core RDMP functionality).  You can commit your compiled dlls by packaging them with 
            package.bat (or by zipping up your bin directory files) and committing the .zip via PluginManagementForm (Accessible via Ctrl+R).  PluginManagementForm will upload
            the DLL as a binary and pushed into the LoadModuleAssembly table.  This allows everyone using your Catalogue database access to the [Exports] defined in the compiled dll.
            
            <para>A typical use case for this is when you are required to load a particularly freaky data format (e.g. even records are in UTF8 binary and odd records are in ASCII) which
            requires specific code to execute.  You would make a class for dealing with the file format and make it implement IPluginAttacher.  Upload your dll along with any
            dependency dlls and the next time a DataAnalyst is building a load configuration your attacher will be displayed along with all the 'out of the box' attachers (CSV, Excel etc)</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.ProhibitedDllNames">
            <summary>
            List of dlls which will not be packaged up if present in your plugins bin directory since they already form part of the RDMP core architecture
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.Name">
            <summary>
            The name of the dll or src file within the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.Plugin"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.Description">
            <summary>
            Not currently used
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.Dll">
            <summary>
            The assembly (dll) file as a Byte[], use File.WriteAllBytes to write it to disk
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.Pdb">
            <summary>
            The assembly (pdb) file if any for the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.Dll"/> which contains debugging symbols
            as a Byte[], use File.WriteAllBytes to write it to disk
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.Committer">
            <summary>
            The user who uploaded the dll
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.UploadDate">
            <summary>
            The date the dll was uploaded
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.DllFileVersion">
            <summary>
            The version number of the dll
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.Plugin_ID">
            <summary>
            The plugin this file forms a part of (each <see cref="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.Plugin"/> will usually have multiple dlls as part of it's dependencies)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.Plugin">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.Plugin_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.IO.FileInfo,Rdmp.Core.CatalogueLibrary.Data.Plugin)">
            <summary>
            Uploads the given dll file to the catalogue database ready for use as a plugin within RDMP (also uploads any pdb file in the same dir)
            </summary>
            <param name="repository"></param>
            <param name="f"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.IsDllProhibited(System.IO.FileInfo)">
            <summary>
            Returns true if the file is on the list of <see cref="F:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.ProhibitedDllNames"/>
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.DownloadAssembly(System.IO.DirectoryInfo)">
            <summary>
            Downloads the plugin dll/pdb/src to the given directory
            </summary>
            <param name="downloadDirectory"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.UpdateTo(System.IO.FileInfo)">
            <summary>
            Updates the current state to match the dll file on disk
            </summary>
            <param name="toCommit"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.LoadProgress">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadProgress.IsDisabled">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadProgress.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadProgress.OriginDate">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadProgress.LoadPeriodicity">
            <summary>
            Not used
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadProgress.DataLoadProgress">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadProgress.LoadMetadata_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadProgress.DefaultNumberOfDaysToLoadEachTime">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadProgress.LoadMetadata">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LoadProgress.CacheProgress">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.LoadProgress.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata)">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.ILoadProgress"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.LoadProgress.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Lookup">
            <summary>
            Describes a relationship between 3 ColumnInfos in which 2 are from a lookup table (e.g. z_drugName), these are a primary
            key (e.g. DrugCode) and a description (e.g. HumanReadableDrugName).  And a third ColumnInfo from a different table (e.g. 
            Prescribing) which is a foreign key (e.g. DrugPrescribed).
            
            <para>The QueryBuilder uses this information to work out how to join together various tables in a query.  Note that it is possible
            to define the same lookup multiple times just with different foreign keys (e.g. Prescribing and DrugAbuse datasets might both
            share the same lookup table z_drugName).</para>
            
            <para>It is not possible to create these lookup dependencies automatically because often an agency won't actually have relationships
            (referential integrity) between their lookup tables and main datasets due to dirty data / missing lookup values.  These are all
            concepts which the RDMP is familiar with and built to handle.</para>
            
            <para>Note also that you can have one or more LookupCompositeJoinInfo for when you need to join particularly ugly lookups (e.g. if you 
            have the same DrugCode meaning different things based on the prescribing board - you need to join on both drugName and 
            prescriberHealthboard).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Lookup.Description_ID">
            <summary>
            The column in the lookup table containing the lookup description for the code e.g. [z_GenderLookup].[GenderCodeDescription]
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Lookup.ForeignKey_ID">
            <summary>
            The column in the lookup table containing the lookup code e.g. [z_GenderLookup].[Gender]
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Lookup.PrimaryKey_ID">
            <summary>
            The column in the main dataset containing the lookup code e.g. [Prescribing].[Gender]
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Lookup.Collation">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Lookup.ExtractionJoinType">
             <inheritdoc/>
            <remarks>For <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> this should almost always be LEFT</remarks>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Lookup.Description">
            <summary>
            These are dereferenced cached versions of the entities to which the _ID properties refer to, to change them change the _ID version 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Lookup.ForeignKey">
            <summary>
            These are dereferenced cached versions of the entities to which the _ID properties refer to, to change them change the _ID version 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Lookup.PrimaryKey">
            <summary>
            These are dereferenced cached versions of the entities to which the _ID properties refer to, to change them change the _ID version 
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Lookup.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,Rdmp.Core.CatalogueLibrary.Data.ExtractionJoinType,System.String)">
            <summary>
            Declares that the columns provide form a foreign key join to lookup table relationship
            </summary>
            <param name="repository"></param>
            <param name="description">The lookup table description column</param>
            <param name="foreignKey">The main dataset column that joins to the lookup e.g. Prescribing.DrugCode</param>
            <param name="primaryKey">The lookup table column that contains the code e.g. z_DrugLookup.Code</param>
            <param name="type"></param>
            <param name="collation"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Lookup.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Lookup.GetAllLookupsBetweenTables(Rdmp.Core.CatalogueLibrary.Data.TableInfo,Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <summary>
            Returns all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> relationships that exist between the main dataset <paramref name="foreignKeyTable"/> and the
            assumed lookup table <paramref name="primaryKeyTable"/>
            </summary>
            <param name="foreignKeyTable">The main dataset table</param>
            <param name="primaryKeyTable">The hypothesized lookup table</param>
            <returns>All lookup relationships, a given table could have 2+ of these e.g. SendingLocation and DischargeLocation could both reference z_Location lookup</returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Lookup.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the Lookup configuration is legal (e.g. not a table linking against itself etc).
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Lookup.SaveToDatabase">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Lookup.GetSupplementalJoins">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Lookup.GetInvertedJoinType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Lookup.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Lookup.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Lookup.SetKnownColumns(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo)">
            <summary>
            Tells the the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> what the objects are referenced by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Lookup.PrimaryKey_ID"/>, <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Lookup.ForeignKey_ID"/> and
            <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Lookup.Description_ID"/> so that it doesn't have to fetch them from the database.
            </summary>
            <param name="primaryKey"></param>
            <param name="foreignKey"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.LookupCompositeJoinInfo">
            <summary>
            Describes to QueryBuilder a secondary/tertiary etc join requirement when making a Lookup join (see <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/>)
            
            <para>This is only the case if you have a given lookup code which changes meaning based on another column e.g. testcode X means a different thing
            in healthboard A vs healthboard B</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LookupCompositeJoinInfo.OriginalLookup_ID">
            <summary>
            The Main <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> to which this column pair must also be joined in the ON SQL block
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LookupCompositeJoinInfo.ForeignKey_ID">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.ForeignKey"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LookupCompositeJoinInfo.PrimaryKey_ID">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.PrimaryKey"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LookupCompositeJoinInfo.Collation">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LookupCompositeJoinInfo.ForeignKey">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.ForeignKey"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.LookupCompositeJoinInfo.PrimaryKey">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.IJoin.PrimaryKey"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.LookupCompositeJoinInfo.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Lookup,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,System.String)">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.LookupCompositeJoinInfo"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.LookupCompositeJoinInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.LookupCompositeJoinInfo.SaveToDatabase">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.IPermissionWindow"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.Description">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.RequiresSynchronousAccess">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.PermissionPeriodConfig">
            <summary>
            The serialized string of <see cref="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.PermissionWindowPeriods"/> which is written/read from the catalogue database
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.CacheProgresses">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.PermissionWindowPeriods">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.WithinPermissionWindow">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.WithinPermissionWindow(System.DateTime)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.#ctor(Rdmp.Core.Repositories.ICatalogueRepository)">
            <summary>
            Create a new time window in which you can restrict things (caching, loading etc) from happening outside
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow.SetPermissionWindowPeriods(System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod})">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod">
            <summary>
            Note all times are stored as UTC
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.DayOfWeek">
            <summary>
            Which day this period is in (periods cannot cross day boundaries)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.Start">
            <summary>
            The start time on the day in which the activity becomes allowable
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.End">
            <summary>
            The end time on the day in which the activity is no longer allowed
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.StartString">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.Start"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.EndString">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.End"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.#ctor">
            <summary>
            Used by serialization only
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.#ctor(System.Int32,System.TimeSpan,System.TimeSpan)">
            <summary>
            Defines a period of day during which an activity is allowable
            </summary>
            <param name="dayOfWeek"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.Contains(System.DateTime,System.Boolean)">
            <summary>
            True if the <paramref name="timeToTest"/> falls with the allowable time range (and on the correct <see cref="P:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.DayOfWeek"/>)
            </summary>
            <param name="timeToTest"></param>
            <param name="testToNearestSecond"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.PermissionWindowPeriod.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine">
            <summary>
            Interface for the Generic IDataFlowPipelineEngine T.  An IDataFlowPipelineEngine is a collection of IDataFlowComponents starting with an IDataFlowSource and
            ending with an IDataFlowDestination with any number of IDataFlowComponents in the middle.  Each component must operate on the class that flows through which is
            of type T (see the Generic implementation).  
            
            <para>Before running the IDataFlowPipelineEngine you should call Initialize with the objects that are available for IPipelineRequirement on components.</para>
            
            <para>See also Pipeline</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine.ExecutePipeline(Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <summary>
            Runs all components from source to destination repeatedly until the source returs null;
            </summary>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine.ExecuteSinglePass(Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <summary>
            Runs the source GetChunk once and passes it down through the other components to the destination
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine.Initialize(System.Object[])">
            <summary>
            Components can declare IPipelineRequirement, calling this method will PreInitialize all components with compatible IPipelineRequirements with the values
            provided.  This is used to for example tell an ExecuteDatasetExtractionSource what IExtractCommand it is supposed to be running.
            </summary>
            <param name="initializationObjects"></param>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine.ComponentObjects">
            <summary>
            All middle IDataFlowComponents in the pipeline (except the source / destination)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine.DestinationObject">
            <summary>
            The IDataFlowDestination component at the end of the pipeline
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine.SourceObject">
            <summary>
            The IDataFlowSource component at the start of the pipeline
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDemandToUseAPipeline">
            <summary>
            Interface for components (of PipelineComponents or ProcessTasks) which have [DemandsInitialization] property(s) of type Pipeline.  This lets you have a pipeline 
            component which requires the user select another Pipeline as one of it's arguments.  You might want to do this for example if you have a standard pipeline for
            reading records and you want to use it in many places (in many other pipelines).  You must define the Context and any Fixed components.  Note that you can even
            set yourself (this) to the FixedDestination to effectively join two IPipelines together.  
            
            <para>The user will only be able to select IPipelines which are compatible with the Context you provide (so it won't for example override source/destination etc).</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDemandToUseAPipeline.GetDesignTimePipelineUseCase(Rdmp.Core.CatalogueLibrary.Data.DataLoad.RequiredPropertyInfo)">
            <summary>
            Get an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase"/> which describes the flow type, required source/destination components and the types of required initialization objects 
            that must be available for a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> to be usable/selectable with the implementing component.
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IHasDesignTimeMode">
            <summary>
            Interface for classes which are requirements of a Pipeline (e.g. the file you want to load) but which might not be available at design time
            (e.g. when the user wants to edit the 'BULK UPLOAD Files' pipeline).  Rather than making the user pick a file implement this interface and 
            provide a suitable static method for constructing the object  and mark it as IsDesignTime too.  
            
            <para>PipelineComponents should check objects they are initialized with (See <see cref="T:Rdmp.Core.DataFlowPipeline.Requirements.IPipelineRequirement`1"/>)
            to see if they are <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IHasDesignTimeMode"/> and have<see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IHasDesignTimeMode.IsDesignTime"/> before checking on them (e.g. checking a file exists on disk).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IHasDesignTimeMode.IsDesignTime">
            <summary>
            True if the user is trying to edit a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> independent of carrying out the task (i.e. no input objects have been selected).
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline">
             <summary>
             Describes the flow of strongly typed objects (usually DataTables) from a source to a destination (e.g. extracting linked cohort data into a flat file ).  
             This entity is the serialized version of DataFlowPipelineEngine&lt;T&gt; (built by a DataFlowPipelineEngineFactory&lt;T&gt; ).
             
             <para>It is the hanging off point of a sequence of steps e.g. 'clean strings', 'substitute column X for column Y by mapping values off of remote server B'.</para>
             
             <para>The functionality of the class is like a microcosm of LoadMetadata (a sequence of predominately reflection driven operations) but it happens in memory 
             (rather than in the RAW=>STAGING=>LIVE databases).</para>
             
             <para>Any time data flows from one location to another there is usually a pipeline involved (e.g. read from a flat file and bulk insert into a database), it 
             may be an empty pipeline but the fact that it is there allows for advanced/freaky user requirements such as:</para>
            
             <para>"Can we count all dates to the first Monday of the week on all extracts we do from now on? - it's a requirement of our new Data Governance Officer"</para>
             
             <para>A Pipeline can be missing either/both a source and destination.  This means that the pipeline can only be used in a situation where the context forces
             a particular source/destination (for example if the user is trying to bulk insert a CSV file then the Destination might be a fixed instance of DataTableUploadDestination
             initialized with a specific server/database that the user had picked on a user interface).</para>
             
             <para>Remember that Pipeline is the serialization, pipelines are used all over the place in RDMP software under different contexts (caching, data extraction etc)
             and sometimes we even create DataFlowPipelineEngine on the fly without even having a Pipeline serialization to create it from.</para>
             </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.Description">
            <summary>
            Human readable description of the intended purpose of the pipeline as configured by the user.  Should include
            what the pipeline is supposed to do.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.DestinationPipelineComponent_ID">
            <summary>
            The component acting as the source of the pipeline and producing data (e.g. by reading a flat file).  This
            can be null if the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase"/> has a fixed runtime source instance instead.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.SourcePipelineComponent_ID">
            <summary>
            The component acting as the destination of the pipeline and consuming data (e.g. writing records to a database).  This
            can be null if the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase"/> has a fixed runtime destination instance instead.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.PipelineComponents">
            <summary>
            All components in the pipeline (including the source and destination)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.Destination">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.DestinationPipelineComponent_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.Source">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.SourcePipelineComponent_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.Clone">
            <summary>
            Creates a complete copy (in the database) of the current <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> including all new copies of components and arguments
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent">
            <summary>
            Each Pipeline has 0 or more PipelineComponents.  A Pipeline Component is a persistence record for a user configuration of a class implementing IDataFlowComponent with
            zero or more [DemandsInitialization] properties.  The class the user has chosen is stored in Class property and a PipelineComponentArgument will exist for each 
            [DemandsInitialization] property.  
            
            <para>PipelineComponents are turned into IDataFlowComponents when stamping out the Pipeline for use at a given time (See DataFlowPipelineEngineFactory.Create) </para>
            
            <para>PipelineComponent is the Design time class (where it appears in Pipeline, what argument values it should be hydrated with etc) while IDataFlowComponent is 
            the runtime instance of the configuration. </para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.Name">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.Pipeline_ID">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> in which the component is configured
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.Class">
            <summary>
            The full name of the C# class Type which should be isntantiated and hydrated when using the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> in which this component is configured.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.PipelineComponentArguments">
            <summary>
            All the arguments for hydrating <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.Class"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.GetClassAsSystemType">
            <summary>
            Returns <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.Class"/> as a resolved System.Type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.GetClassNameLastPart">
            <summary>
            Returns the name only (without namespace) of the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.Class"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.Clone(Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline)">
            <summary>
            Creates a new copy of the current <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent"/> into another <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> <paramref name="intoTargetPipeline"/>
            <para>This is usually done as part of <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.Clone"/></para>
            </summary>
            <param name="intoTargetPipeline"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponentArgument">
            <summary>
            See PipelineComponentArgument
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponentArgument.PipelineComponent_ID">
            <summary>
            Component for whom this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponentArgument"/> provides a value for.  There will be one <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponentArgument"/>
            per public property with <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute"/> on the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.Class"/>.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase">
            <summary>
            Describes a specific use case for executing an IPipeline under.  This includes specifying the type T of the data flow, if there is an explicit
            source/destination component instance which must be used, what objects are available for PreInitialize on components (GetInitializationObjects).
            
            <para>An instance of IPipelineUseCase is not just the general case (which is defined by IDataFlowPipelineContext) but the specific hydrated use case 
            e.g. 'I want to Release Project 205'.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase.GetInitializationObjects">
            <summary>
            All the objects available for executing the Pipeline.  
            <para>OR: If <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IHasDesignTimeMode.IsDesignTime"/> then an array of the Types of objects that should be around at runtime
            when performing the task described by the PipelineUseCase</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase.FilterCompatiblePipelines(System.Collections.Generic.IEnumerable{Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline})">
            <summary>
            Returns all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> from the collection which are compatible with the <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase.GetContext"/> and <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase.GetInitializationObjects"/>
            </summary>
            <param name="pipelines"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase.GetContext">
            <summary>
            Returns an object describing which <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/>s can be used to undertake the activity described by this use case (e.g. loading a flat file into the
            database).  This includes the flow object (T) of and whether there are fixed sources/destinations as well as any forbidden <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent"/> types
            </summary>
            <returns></returns>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase.ExplicitSource">
            <summary>
            The fixed runtime instance of <see cref="T:Rdmp.Core.DataFlowPipeline.IDataFlowSource`1"/> that will be used instead of an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent"/> when
            running this use case. If this is populated then <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/>s cannot have a user configured source component.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase.ExplicitDestination">
            <summary>
            The fixed runtime instance of <see cref="T:Rdmp.Core.DataFlowPipeline.IDataFlowDestination`1"/> that will be used instead of an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent"/> when
            running this use case. If this is populated then <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/>s cannot have a user configured destination component.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase.GetEngine(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline,ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Constructs and engine from the provided <paramref name="pipeline"/> initialized by <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase.GetInitializationObjects"/>
            </summary>
            <param name="pipeline"></param>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUser">
            <summary>
            Interface primarily for interacting with PipelineSelectionUIFactory.  Provides consumers with a method (Getter) for determining the currently configured Pipeline
            of a class as well as a method for committing changes to this Pipeline.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUser.Getter">
            <summary>
            Delegate for returning the referenced <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> for the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUser"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUser.Setter">
            <summary>
            Delegate for changing the referenced <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> for the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUser"/>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.Description">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.DestinationPipelineComponent_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.SourcePipelineComponent_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.PipelineComponents">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.Destination">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.Source">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String)">
            <summary>
            Creates a new empty <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> in the database, this is a sequence of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent"/> which when combined
            with an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase"/> achieve a specific goal (e.g. loading records into the database from a flat file).
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.Clone">
            <summary>
            Creates (in the database) and returns a new <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> which is an identical copy of the current.  This includes creating new copies
            of all child objects (i.e. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent"/> and <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponentArgument"/>) 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent[])">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.Order">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.Pipeline_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.Class">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.PipelineComponentArguments">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.Pipeline">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.Pipeline_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline,System.Type,System.Int32,System.String)">
            <summary>
            Creates a new component in the <paramref name="parent"/> <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.Pipeline"/>.  This will mean that when run the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.Pipeline"/>
            will instantiate and run the given <paramref name="componentType"/>.
            </summary>
            <param name="repository"></param>
            <param name="parent"></param>
            <param name="componentType"></param>
            <param name="order"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.GetAllArguments">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.CreateNewArgument">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.GetClassNameWhoArgumentsAreFor">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.GetClassAsSystemType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.GetClassNameLastPart">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.Clone(Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.CreateArgumentsForClassIfNotExists``1">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.CreateArgumentsForClassIfNotExists(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponentArgument">
            <summary>
            Each PipelineComponent can have 0 or more PipelineComponentArguments, these function exactly like the relationship between ProcessTask and ProcessTaskArgument and
            reflect a [DemandsInitialization] property on a class of type IDataFlowComponent which is built and populated by reflection from the PipelineComponent (serialization)
            
            <para>See Pipeline and PipelineComponent for more information about this</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponentArgument.PipelineComponent_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponentArgument.PipelineComponent">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponentArgument.PipelineComponent_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponentArgument.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponent)">
            <summary>
            Creates a new argument storage object for one of the arguments in <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponentArgument.PipelineComponent"/>.  
            
            <para>You should probably call <see cref="M:Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgumentHost.CreateArgumentsForClassIfNotExists``1"/> intead</para>
            </summary>
            <param name="repository"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponentArgument.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponentArgument.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineComponentArgument.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase">
            <summary>
            Abstract base IPipelineUseCase. Provides basic implementations for filtering compatible pipelines and translating
            a selected IPipeline into an actual executable engine instance via DataFlowPipelineEngineFactory.  Set ExplicitSource / 
            ExplicitDestination / PreInitialize objects etc as needed for your use case.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.GetInitializationObjects">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.GetContext">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.GenerateContext">
            <summary>
            Call this in your constructor 
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.GenerateContextImpl">
            <summary>
            Implement this to generate the compatiblity definition for pipelines that will be used by you.  
            
            <para>IMPORTANT: Make sure you call <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.GenerateContext"/> in every constructor you have</para>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.ExplicitSource">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.ExplicitDestination">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.IsDesignTime">
            <summary>
            True if there there are no objects available for hydrating (e.g. no files to load, no picked cohorts etc).  This is often 
            the case when the user is editing a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> at some arbitrary time.
            
            <para>If this is true then GetInitializationObjects should return Type[] instead of the actually selected objects for the task</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.#ctor">
            <summary>
            The normal (non desing time) constructor.  Add your objects to <see cref="F:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.InitializationObjects"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.#ctor(System.Type[])">
            <summary>
            Use this constructor if you are intending to use the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase"/> for design time activities only (building pipelines
            from compatible components).  Only use if you don't have all the normally required object instances to actually execute a pipeline.
            </summary>
            <param name="designTimeInitializationObjectTypes"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.FilterCompatiblePipelines(System.Collections.Generic.IEnumerable{Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline})">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.GetEngine(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline,ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase.AddInitializationObject(System.Object)">
            <summary>
            Mark the object instance <paramref name="o"/> as available for pipeline components to subscribe to via IPipelineRequirement.
            </summary>
            <param name="o"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUser">
            <summary>
            Helper for standardising access to properties on a class which reference a Pipeline.  Because many classes reference Pipelines and some reference multiple Pipelines 
            we use this class to abstract that away.  For example the CacheProgress constructor says to use "Pipeline_ID" int property.
            
            <para>Currently used primarily by PipelineSelectionUIFactory </para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUser.User">
            <summary>
            The object which references a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> for which you want the user to be able to change selected instance.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUser.Getter">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUser.Setter">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUser.#ctor(System.Reflection.PropertyInfo,Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity,Rdmp.Core.Repositories.ICatalogueRepository)">
            <summary>
            Declares that the given <paramref name="property"/> (which must be nullable int) stores the ID (or null) of a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> declared
            in the RDMP platform databases.  The property must belong to <paramref name="user"/> 
            </summary>
            <param name="property"></param>
            <param name="user"></param>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUser.#ctor(Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress)">
            <summary>
            Gets a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUser"/> targetting <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress.Pipeline_ID"/>
            </summary>
            <param name="cacheProgress"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineSetter">
            <summary>
            Delegate for storing a new value of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> into a class
            </summary>
            <param name="newPipelineOrNull"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineGetter">
            <summary>
            Delegate for retrieving the currently set <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> of a class
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Plugin">
            <summary>
            A collection of LoadModuleAssembly objects that make up a complete Plugin.  The Plugin is the head in which a name, upload location and verison are recorded then each
            dll that makes up the functionality is linked as LoadModuleAssemblies (See LoadModuleAssembly)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Plugin.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Plugin.UploadedFromDirectory">
            <summary>
            Where the plugin files were uploaded from
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Plugin.PluginVersion">
            <summary>
            The master version of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Plugin"/> (not the dlls inside - See <see cref="P:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly.DllFileVersion"/>).
            <para>Not currently used</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Plugin.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.IO.FileInfo,System.Version)">
            <summary>
            Defines a new collection of dlls that provide plugin functionality for RDMP
            </summary>
            <param name="repository"></param>
            <param name="pluginZipFile"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Plugin.ToString">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Plugin.LoadModuleAssemblies">
            <summary>
            Gets all the dlls and source code(if available) stored as <see cref="T:Rdmp.Core.CatalogueLibrary.Data.LoadModuleAssembly"/> in the catalogue database
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Plugin.GetPluginDirectoryName(System.IO.DirectoryInfo)">
            <summary>
            Returns a folder name suitable for storing the dlls for the plugin in as a subdirectory of 
            <paramref name="downloadDirectoryRoot"/>
            </summary>
            <param name="downloadDirectoryRoot"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Referencing.IReferenceOtherObject">
            <summary>
            Interface for all objects which reference a single other object e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Favourite"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Referencing.IReferenceOtherObject.IsReferenceTo(System.Type)">
            <summary>
            Returns true if the object being referenced is of Type <paramref name="type"/>
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Referencing.IReferenceOtherObject.IsReferenceTo(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Returns true if the object being referenced is <paramref name="o"/>
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Referencing.IReferenceOtherObjectWithPersist">
            <summary>
            Interface for all objects which reference a single other object and correctly persist it to the RDMP database
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Referencing.IReferenceOtherObjectWithPersist.ReferencedObjectType">
            <summary>
            The Type of object that was referred to (e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>).  Must be an <see cref="T:MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable"/> object
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Referencing.IReferenceOtherObjectWithPersist.ReferencedObjectID">
            <summary>
            The ID of the object being refered to by this class
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Referencing.IReferenceOtherObjectWithPersist.ReferencedObjectRepositoryType">
            <summary>
            The platform database which is storing the object being referred to (e.g. DataExport or Catalogue)
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity">
            <summary>
            Abstract base class for all database objects that reference a single other arbitrary database object e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Favourite"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.ReferencedObjectType">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.ReferencedObjectID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.ReferencedObjectRepositoryType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.#ctor(MapsDirectlyToDatabaseTable.IRepository,System.Data.Common.DbDataReader)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.IsReferenceTo(System.Type)">
            <summary>
            True if the object referenced by this class is of Type <paramref name="type"/>
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.IsReferenceTo(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            True if the <paramref name="o"/> is the object that is explicitly referenced by this class instance
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.GetReferencedObject(Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator)">
            <summary>
            Returns the instance of the object referenced by this class or null if it no longer exists (e.g. has been deleted)
            </summary>
            <param name="repositoryLocator"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Referencing.ReferenceOtherObjectDatabaseEntity.ReferencedObjectExists(Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator)">
            <summary>
            Returns true if the object referenced by this class still exists in the database
            </summary>
            <param name="repositoryLocator"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP">
            <summary>
            This represent a Remote Installation of RDMP which can accept connections at multiple endpoints
            
            <para>Endpoints are usual REST endpoints with a URL and a type which they can accept.
            The endpoint format is {Url}/api/{typename}
            The typename is used to create the URL for the endpoint.
            If you are sending a collection, append this to the URI: ?asarray=true</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.URL">
            <summary>
            Web service URL for communicating with the remote RDMP instance
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.Username">
            <summary>
            Username to specify when connecting to the remote webservice
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.Password">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.GetDecryptedPassword">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.#ctor(Rdmp.Core.Repositories.ICatalogueRepository)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.#ctor(MapsDirectlyToDatabaseTable.IRepository,System.Data.Common.DbDataReader)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.ToString">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.Name"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.GetUrlFor``1(System.Boolean)">
            <summary>
            Gets the web service sub url for interacting with the object T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="isarray"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.GetUrlForRelease">
            <summary>
            Gets the web service sub url for performing a data release
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP.GetCheckingUrl">
            <summary>
            Gets the web service sub url for value checking?
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.SafeDirectoryCatalog">
            <summary>
            Managed Extensibility Framework (MEF) Catalog of Class Types that are exposed via [InheritedExport(typeof(X))].  Constructing this class will process the directories
            provided (usually the current directory and the %appdata%\MEF directory).  Each dll (Assembly) is classed as either a 'Bad Assembly' (could not be loaded) or a
            'Good Assembly' (was loaded).  GoodAssemblies are exposed as AssemblyCatalogs (MEF) which area  collection of ComposablePartDefinition (Parts).
            
            <para>These can then be constructed/queried like you normally do with MEF (See MEF.LocateExportInContainerByTypeName).</para>
            
            <para>This class deliberately tries to filter interfaces and abstract class exports since the goal is to construct instances of plugin classes</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.SafeDirectoryCatalog.GoodAssemblies">
            <summary>
            Assemblies succesfully loaded
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SafeDirectoryCatalog.BadAssembliesDictionary">
            <summary>
            Assemblies which could not be loaded
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.SafeDirectoryCatalog.PartsByFileDictionary">
            <summary>
            All MEF Export classes found in all assemblies loaded
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SafeDirectoryCatalog.#ctor(System.String[])">
            <summary>
            Creates a new list of MEF plugin classes from the dlls/files in the directory list provided
            </summary>
            <param name="directories"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SafeDirectoryCatalog.#ctor(ReusableLibraryCode.Checks.ICheckNotifier,System.String[])">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.Data.SafeDirectoryCatalog.#ctor(System.String[])"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SafeDirectoryCatalog.Parts">
            <summary>
            Gets all MEF exported classes that were succesfully loaded
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SafeDirectoryCatalog.GetAllTypes">
            <summary>
            Returns <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SafeDirectoryCatalog.Parts"/> as System.Type
            
            <para>Excludes interfaces and abstract classes</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.SelfCertifyingDataAccessPoint">
            <summary>
            Normally to open a connection to an IDataAccessPoint (location of server/database) you also need an optional IDataAccessCredentials (username and encrypted password).  These
            These are usually two separate objects e.g. TableInfo and DataAccessCredentials (optional - if ommmited connections use integrated/windows security).  
            
            <para>Instead of doing that however, you can use this class to store all the bits in one object that implements both interfaces.  It can then be used with a 
            DataAccessPortal.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SelfCertifyingDataAccessPoint.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,FAnsi.DatabaseType)">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.SelfCertifyingDataAccessPoint"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SelfCertifyingDataAccessPoint.Server">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SelfCertifyingDataAccessPoint.Database">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SelfCertifyingDataAccessPoint.Username">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SelfCertifyingDataAccessPoint.DatabaseType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SelfCertifyingDataAccessPoint.GetCredentialsIfExists(ReusableLibraryCode.DataAccess.DataAccessContext)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SelfCertifyingDataAccessPoint.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.DatabaseEntityJsonConverter">
            <summary>
            Handles Serialization of Database Entity classes.  Writing is done by by storing the ID, Type and RepositoryType where the object is stored.  Reading is done by
            using the IRDMPPlatformRepositoryServiceLocator to fetch the instance out of the database.  
            
            <para>Also stores the ObjectExport SharingUID if available which will allow deserializing shared objects that might only exist in a local import form i.e. with a different ID
            (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager"/>)</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.DatabaseEntityJsonConverter.#ctor(Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator)">
            <summary>
            Creates a new serializer for objects stored in RDMP platform databases (only supports <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/>)
            
            </summary>
            <param name="repositoryLocator"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.DatabaseEntityJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Serializes a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/> by sharing it with <see cref="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetObjectFromPersistenceString(System.String)"/>.  This
            creates a pointer only e.g. "Catalogue 123" and if an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport"/> exists then also the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport.SharingUID"/> 
            so that the JSON can be used in other instances (that have imported the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/> of the serialized object)
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="serializer"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.DatabaseEntityJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Deserializes a persisted <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/> by resolving it as a reference and fetching the original 
            object using <see cref="M:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager.GetObjectFromPersistenceString(System.String)"/>.
            </summary>
            <param name="reader"></param>
            <param name="objectType"></param>
            <param name="existingValue"></param>
            <param name="serializer"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.DatabaseEntityJsonConverter.CanConvert(System.Type)">
            <summary>
            True if <paramref name="objectType"/> is a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/> (the only thing this class can serialize)
            </summary>
            <param name="objectType"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.IPickAnyConstructorFinishedCallback">
            <summary>
            For use with classes who intend to be constructed by <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter"/>.  If you implement this interface then the callback notify you after your 
            constructor has been called and properties populated. 
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.IPickAnyConstructorFinishedCallback.AfterConstruction">
            <summary>
            Called after a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter"/> finishes constructing and populating your instance
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.JsonCompatibleDictionary`2">
            <summary>
            Allows Json serialization of complex key Types.
            
            <para>Out of the box Json serializes Dictionary keys using ToString and seems to ignore any custom JsonConverter specified on the key class.  This class works around that behaviour
            by only serializing an array of keys and an array of values.  Once both are populated then the underlying Dictionary Key/Values are created.</para>
            </summary>
            <typeparam name="TK"></typeparam>
            <typeparam name="TV"></typeparam>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Serialization.JsonCompatibleDictionary`2.SerializeableKeys">
            <summary>
            Returns the keys of the dictionary as an Array.  Json loves arrays and hates dictionary keys
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Serialization.JsonCompatibleDictionary`2.SerializeableValues">
            <summary>
            Returns the values of the dictionary as an Array.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.JsonConvertExtensions">
            <summary>
            Facilitates the use of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.DatabaseEntityJsonConverter"/> and <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter"/> by configuring appropriate <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> etc
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.JsonConvertExtensions.SerializeObject(System.Object,Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator)">
            <summary>
            Serialize the given object resolving any properties which are <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/> into pointers using <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.DatabaseEntityJsonConverter"/>
            </summary>
            <param name="value"></param>
            <param name="repositoryLocator"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.JsonConvertExtensions.DeserializeObject(System.String,System.Type,Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator,System.Object[])">
            <summary>
            Deserializes a string created with <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.JsonConvertExtensions.SerializeObject(System.Object,Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator)"/>.  This involves two additional areas of functionality
            beyond basic JSON:
            
            <para>1. Any database pointer (e.g. Catalogue 123 0xab1d) will be fetched and returned from the appropriate platform database (referenced by <paramref name="repositoryLocator"/>)</para>
            <para>2. Objects do not need a default constructor, instead <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter"/> will be used with <paramref name="objectsForConstructingStuffWith"/></para>
            <para>3. Any objects implementing <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.IPickAnyConstructorFinishedCallback"/> will have <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.IPickAnyConstructorFinishedCallback.AfterConstruction"/> called</para>
            </summary>
            <param name="value"></param>
            <param name="type"></param>
            <param name="repositoryLocator"></param>
            <param name="objectsForConstructingStuffWith"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter">
            <summary>
            Supports Json deserialization of objects which don't have default (blank) constructors.  Pass the objects you want to use for constructor
            arguments to classes you want to deserialize.  This JsonConverter will assert that it CanConvert any object for which it finds no default constructor and
            a single constructor which is compatible with the constructorObjects (or a subset of them)
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter.#ctor(System.Object[])">
            <summary>
            Creates a JSON deserializer that can use any constructors on the class which match <paramref name="constructorObjects"/>
            </summary>
            <param name="constructorObjects"></param>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter.CanWrite">
            <summary>
            Cannot write, this class is for deserialization only
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Cannot write, throws NotImplementedException
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="serializer"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Returns a hydrated object from <paramref name="reader"/> by invoking the appropriate constructor identified by <see cref="M:Rdmp.Core.Repositories.Construction.ObjectConstructor.GetConstructors(System.Type,System.Boolean,System.Boolean,System.Object[])"/> 
            whitch matches the parameters provided to <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter"/> when it was constructed.
            
            <para>If the <paramref name="objectType"/> is <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.IPickAnyConstructorFinishedCallback"/> then <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.IPickAnyConstructorFinishedCallback.AfterConstruction"/>
            will be called</para>
            </summary>
            <param name="reader"></param>
            <param name="objectType"></param>
            <param name="existingValue"></param>
            <param name="serializer"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter.CanConvert(System.Type)">
            <summary>
            Returns true if the <paramref name="objectType"/> is a non value Type with one constructor compatible with the parameters provided to
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.PickAnyConstructorJsonConverter"/> when it was constructed.
            </summary>
            <param name="objectType"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition">
            <summary>
            Describes a DatabaseEntity which has been made exportable from RDMP via <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport"/>.  This class includes the properties that are
            directly recorded for the object e.g. Name, SelectSQL etc.  For Foreign Key columns (See <see cref="T:MapsDirectlyToDatabaseTable.Attributes.RelationshipAttribute"/>) e.g. <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue_ID"/> the Guid 
            of another <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/> is given (e.g. of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>).  This means that a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/> is only valid when all it's dependencies are
            also available (See Sharing.Dependency.Gathering.Gatherer for how to do this)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition.SharingGuid">
            <summary>
            The unique number that identifies this shared object.  This is created when the object is first shared as an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport"/> and 
            persisted by all other systems that import the object as an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectImport"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition.ID">
            <summary>
            The <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.ID"/> of the object in the original database the share was created from (this will be different to the ID it has when imported elsewhere)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition.Type">
            <summary>
            The System.Type and therefore database table of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/> that is being shared
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition.Properties">
            <summary>
            The values of all public properties on the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/> (except ID, Relationship and NoMappingToDatabase properties).  This does not include
            any foreign key ID properties e.g. <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue_ID"/> which will instead be stored in <see cref="F:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition.RelationshipProperties"/>
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition.RelationshipProperties">
            <summary>
            The values of all foreign key properties on the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/> (e.g. <see cref="P:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem.Catalogue_ID"/>).  This is the SharingGuid of the referenced object.
            An object cannot be shared unless it is also shared with all such dependencies.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition.#ctor(System.Guid,System.Int32,System.Type,System.Collections.Generic.Dictionary{System.String,System.Object},System.Collections.Generic.Dictionary{MapsDirectlyToDatabaseTable.Attributes.RelationshipAttribute,System.Guid})">
            <inheritdoc cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition.GetDictionaryForImport">
            <summary>
            Removes null entries and fixes problematic value types e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueFolder"/> which is better imported as a string
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedAggregateTopX">
            <summary>
            Spontaneous (memory only) version of AggregateTopX (a DatabaseEntity class).  See AggregateTopX for description.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedAggregateTopX.TopX">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedAggregateTopX.OrderByColumn">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedAggregateTopX.OrderByDirection">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedAggregateTopX.#ctor(MapsDirectlyToDatabaseTable.MemoryRepository,System.Int32,Rdmp.Core.CatalogueLibrary.Data.AggregateTopXOrderByDirection,Rdmp.Core.QueryBuilding.IColumn)">
            <summary>
            Creates a ne memory only TopX constraint for use with <see cref="!:CatalogueLibrary.QueryBuilding.AggregateBuilder"/>.
            </summary>
            <param name="topX"></param>
            <param name="orderByDirection"></param>
            <param name="orderByColumn"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedArgument">
            <summary>
            Spontaneous (memory only) implementation of IArgument.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedColumn">
            <summary>
            Spontaneous (memory only) implementation of IColumn.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedFilter">
            <summary>
            Spontaneous (memory only) implementation of IFilter.  This is the preferred method of injecting lines of WHERE Sql into an ISqlQueryBuilder dynamically in code
            (as opposed to ones the user has created).  This can be used to for example enforce additional constraints on the query e.g. 'generate this Aggregate Graph but
            restrict the results to patients appearing in my cohort list X' (in this case the SpontaneouslyInventedFilter would be the 'patients appearing in my cohort list X'
            
            <para>The other way to inject sql code into an ISqlQueryBuilder is via CustomLine but that's less precise.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedFilter.#ctor(Rdmp.Core.Repositories.MemoryCatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.IContainer,System.String,System.String,System.String,Rdmp.Core.CatalogueLibrary.Data.ISqlParameter[])">
            <summary>
            Creates a new temporary (unsaveable) filter in the given memory <paramref name="repo"/>
            </summary>
            <param name="repo">The repository to store the temporary object in</param>
            <param name="notionalParent"></param>
            <param name="whereSql"></param>
            <param name="name"></param>
            <param name="description"></param>
            <param name="filterParametersIfAny"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedFilter.#ctor(Rdmp.Core.Repositories.MemoryCatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.IFilter)">
            <summary>
            Constructs a new filter by copying out the values from the supplied IFilter
            </summary>
            <param name="repo">The repository to store the temporary object in</param>
            <param name="copyFrom"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedFilterContainer">
            <summary>
            Spontaneous (memory only) implementation of IContainer.  
            
            <para>IContainers are collections of subcontainers and WHERE statements e.g. 
            (
                --age is above 5
                Age > 5
            AND
               --name is bob
                Name like 'Bob%'
            )</para>
            
            <para>Most IContainers come from the DataCatalogue/DataExport Database and are a hierarchical list of filters the user wants to use to create a query.  But sometimes IN CODE,
            we want to create an impromptu container and ram some additional filters we have either also invented or have pulled out of the Catalogue into the container.  This 
            Class lets you do that, it creates a 'memory only' container which cannot be saved/deleted etc but can be used in query building by ISqlQueryBuilders.</para>
            
            <para>See also SpontaneouslyInventedFilter</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedPermissionWindow">
            <summary>
            Spontaneous (non database persisted) version of PermissionWindow.  Use this class when you want to define a runtime only (in memory) window of execution for
            caching / loading etc.  SpontaneouslyInventedPermissionWindow are never locked.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneouslyInventedSqlParameter">
            <summary>
            Spontaneous (memory only) implementation of ISqlParameter.  This class is used extensively when there is a need to inject new ISqlParameters into an ISqlQueryBuilder
            at runtime (or a ParameterManager).  The most common use case for this is merging two or more ISqlParameters that have the exact same declaration/value into a single
            new one (which will be SpontaneouslyInventedSqlParameter to prevent changes to the originals).
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneousObject">
            <summary>
            SpontaneousObjects are 'memory only' versions of IMapsDirectlyToDatabaseTable classes which throw NotSupportedException on any attempt to persist / delete them etc but which
            you can initialize and set properties on towards your own nefarious ends.
            
            <para>E.g. lets say during the course of your programming you want to bolt another container and filter onto an AggregateContainer (in your Catalogue) then you can
            SpontaneouslyInventedFilterContainer, put the AggregateContainer into it and create a SpontaneouslyInventedFilter along side it.  Then pass the Sponted container
            to an ISqlQueryBuilder and watch it treat it just like any other normal collection of (database based) filters / containers.</para>
            
            <para>SpontaneousObjects all have NEGATIVE IDs which are randomly generated, this lets the RDMP software use ID for object equality without getting confused but prevents the
            system from ever accidentally saving a SpontaneousObject into a data table in the Catalogue</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneousObject.#ctor(MapsDirectlyToDatabaseTable.MemoryRepository)">
            <summary>
            Optional repository for tracking the objects relationship to other <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneousObject"/>
            </summary>
            <param name="repository"></param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.StandardRegex">
            <summary>
            A reusable regular expression which is available system wide.  Use these to record important standardised concepts which you need to use in RDMP.  For example if you have a
            blacklist for forbidden column names instead of copying and pasting the definition everywhere and into plugins etc you can define it once in the catalogue database as a 
            StandardRegex with a description and then everyone can link against it and have access to a centralised description.  This prevents you having multiple arguments getting out
            of sync in Pipeline components for example.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.StandardRegex.ConceptName">
            <summary>
            Short human readable name for what the regex identifies e.g. 'chis'
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.StandardRegex.Regex">
            <summary>
            The string that is the Pattern of the Regex, the user can happily type in invalid stuff and it will not break until it is used at runtime (so that we don't bust up at Design Time)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.StandardRegex.Description">
            <summary>
            Verbose user provided description of the Regex, history, purpose, how it works etc
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.StandardRegex.#ctor(Rdmp.Core.Repositories.ICatalogueRepository)">
            <summary>
            Creates a new standardised reusable regular expression in the database that can be referenced by pipeline components (this helps centralise patterns
            rather than having replication between components/pipelines)
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.StandardRegex.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument">
            <summary>
            Describes a document (e.g. PDF / Excel file etc) which is useful for understanding a given dataset (Catalogue).  This can be marked as Extractable in which case 
            every time the dataset is extracted the file will also be bundled along with it (so that researchers can also benefit from the file).
            
            <para>You can also mark SupportingDocuments as Global in which case they will be provided (if Extractable) to researchers regardless of which datasets they have selected
            e.g. a PDF on data governance or a copy of an empty 'data use contract document'</para>
            
            <para>Finally you can tie in the Ticketing system so that you can audit time spent curating the document etc.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.URL">
            <summary>
            Path to the document on disk
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.Description">
            <summary>
            Human readable description of what the document contains and why it is in the system
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.Extractable">
            <summary>
            If true then the file will be copied to the output directory of project extractions that include the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.Catalogue_ID"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.Ticket">
            <summary>
            <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/> identifier of a ticket for logging time curating / updating etc the document
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.IsGlobal">
            <summary>
            If <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.Extractable"/>  and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.IsGlobal"/> then the document will be copied to the ouptut directory of all project extractions
            regardless of whether or not the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.Catalogue_ID"/> dataset is included in the extraction
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.Catalogue_ID">
            <summary>
            The dataset the document relates to
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Catalogue,System.String)">
            <summary>
            Creates a new supporting document for helping understand the dataset <paramref name="parent"/>
            </summary>
            <param name="repository"></param>
            <param name="parent"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.IsReleasable">
            <summary>
            Returns true if <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.Extractable"/> and has a valid <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.URL"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.GetFileName">
            <summary>
            Returns the name of the file referenced by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument.URL"/> or null if it is not a file URL
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable">
            <summary>
            Describes an SQL query that can be run to generate useful information for the understanding of a given Catalogue (dataset).  If it is marked as 
            Extractable then it will be bundled along with the Catalogue every time it is extracted.  This can be used as an alternative to definining Lookups
            through the Lookup class or to extract other useful administrative data etc to be provided to researchers
            
            <para>It is VITAL that you do not use this as a method of extracting sensitive/patient data as this data is run as is and is not joined against a cohort
            or anonymised in anyway.</para>
            
            <para>If the Global flag is set then the SQL will be run and the result provided to every researcher regardless of what datasets they have asked for in 
            an extraction, this is useful for large lookups like ICD / SNOMED CT which are likely to be used by many datasets. </para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.ExtractionFolderName">
            <summary>
            The subfolder of extractions in which to put <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Extractable"/> <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable"/> when doing project extractions
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Catalogue_ID">
            <summary>
            The dataset the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable"/> helps you to understand
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Description">
            <summary>
            Human readable description of what the table referenced by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.SQL"/> contains
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.SQL">
            <summary>
            Sql to execute on the server to return the supplemental table that helps with understanding/interpreting <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Catalogue_ID"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Extractable">
            <summary>
            If true then the query will be executed and the resulting table will be copied to the output directory of project extractions that include the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Catalogue_ID"/>.
            
            <para>This will fail if the query contains mulitple select statements.  Ensure that there is no identifiable data returned by the query since it will not be linked 
            against the project cohort / anonymised in any way.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.ExternalDatabaseServer_ID">
            <summary>
            The server on which the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.SQL"/> should be executed on
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Ticket">
            <summary>
            <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/> identifier of a ticket for logging time curating / updating etc the table
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.IsGlobal">
            <summary>
            If <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Extractable"/>  and <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.IsGlobal"/> then the table will be copied to the ouptut directory of all project extractions
            regardless of whether or not the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Catalogue_ID"/> dataset is included in the extraction
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Catalogue">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.Catalogue_ID"/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.ExternalDatabaseServer">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.ExternalDatabaseServer_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.Catalogue,System.String)">
            <summary>
            Defines a new table that helps in understanding the given dataset <paramref name="parent"/>
            </summary>
            <param name="repository"></param>
            <param name="parent"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.GetServer">
            <summary>
            Returns the decrypted connection string you can use to access the data (fetched from ExternalDatabaseServer_ID - which can be null).  If there is no 
            ExternalDatabaseServer_ID associated with the SupportingSQLTable then a NotSupportedException will be thrown
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.FetchOptions">
            <summary>
            Identifies which collection of extractable resources should be returned from the database
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.FetchOptions.AllGlobalsAndAllLocals">
            <summary>
            All resources
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.FetchOptions.AllGlobals">
            <summary>
            Global resources only
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.FetchOptions.AllLocals">
            <summary>
            Non Global resources only
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.FetchOptions.ExtractableGlobals">
            <summary>
            Global resources only AND only if they are marked Extractable
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.FetchOptions.ExtractableLocals">
            <summary>
            Non Global resources only AND only if they are marked Extractable
            </summary>
        </member>
        <member name="F:Rdmp.Core.CatalogueLibrary.Data.FetchOptions.ExtractableGlobalsAndLocals">
            <summary>
            All resources that are marked Extractable
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo">
            <summary>
            Describes an sql table (or table valued function) on a given Server from which you intend to either extract and/or load / curate data.
            These can be created most easily by using TableInfoImporter.  This entity is the hanging off point for PreLoadDiscardedColumn, ColumnInfo etc
            
            <para>This class represents a constant for the RDMP and allows the system to detect when data analysts have randomly dropped/renamed columns without 
            telling anybody and present this information in a rational context to the systems user (see TableInfoSynchronizer).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.Name">
            <summary>
            Fully specified table name
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.DatabaseType">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.Server">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.Database">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.State">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.ValidationXml">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.IsPrimaryExtractionTable">
            <summary>
            <para>Indicates that this TableInfo should be the first table joined in any query that has multiple other TableInfos</para>
            
            <para>When determining how to join a collection of TableInfos the <see cref="T:Rdmp.Core.QueryBuilding.QueryBuilder"/> will attempt to find <see cref="T:Rdmp.Core.CatalogueLibrary.Data.JoinInfo"/> pairings between <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> in
            the tables.  If it cannot work out how to resolve the join order (e.g. if there are 3+ tables and joins going in both directions) then it will demand that one of the 
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> be picked as the first table from which all other tables should then be joined.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.IdentifierDumpServer_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.IsTableValuedFunction">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.Schema">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.ColumnInfos">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.PreLoadDiscardedColumns">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.IdentifierDumpServer">
            <inheritdoc cref="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.IdentifierDumpServer_ID"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String)">
            <summary>
            Defines a new table reference in the platform database <paramref name="repository"/>.  
            <para>Usually you should use <see cref="T:Rdmp.Core.CatalogueLibrary.DataHelper.TableInfoImporter"/> instead</para>
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetAllParameters">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.CompareTo(System.Object)">
            <summary>
            Sorts two <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> alphabetically
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetRuntimeName">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetFullyQualifiedName">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetDatabaseRuntimeName">
            <summary>
            Returns <see cref="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.Database"/> trimmed of any database qualifiers (e.g. square brackets)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetDatabaseRuntimeName(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage,Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetRuntimeName(Rdmp.Core.CatalogueLibrary.Data.LoadBubble,Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetRuntimeName(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage,Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetCredentialsIfExists(ReusableLibraryCode.DataAccess.DataAccessContext)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.SetCredentials(Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials,ReusableLibraryCode.DataAccess.DataAccessContext,System.Boolean)">
            <summary>
            Declares that the given <paramref name="credentials"/> should be used to access the data table referenced by this 
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> under the given <see cref="T:ReusableLibraryCode.DataAccess.DataAccessContext"/> (loading data etc).
            </summary>
            <param name="credentials">Credentials to use (username / encrypted password)</param>
            <param name="context">When the credentials can be used (Use Any for any case)</param>
            <param name="allowOverwritting">False will throw if there is already credentials declared for the table/context</param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the table referenced exists on the database server and that it's properties and <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> etc are synchronized with the live
            table as it exists on the server.
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.IsLookupTable">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetAllRelatedCatalogues">
            <summary>
            Returns all Catalogues which have any CatalogueItems which are associated with any of the ColumnInfos of this TableInfo.  If this is a lookup table then expect to get back 
            a whole bunch of catalogues.  If you have multiple extractable catalogues that all present different views of a single TableInfo then they will all be returned.  The normal
            behaviour though for a regular data table with one catalogue used for extraction would be for a single Catalogue to get returned.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetColumnsAtStage(Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo[])">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.Discover(ReusableLibraryCode.DataAccess.DataAccessContext)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TableInfo.Is(FAnsi.Discovery.DiscoveredTable,System.Boolean)">
            <summary>
            Returns true if the TableInfo is a reference to the discovered live table (same database, same table name, same server)
            <para>By default servername is not checked since you can have server aliases e.g. localhost\sqlexpress could be the same as 127.0.0.1\sqlexpress</para>
            </summary>
            <param name="discoveredTable">Pass true to also check the servername is EXACTLY the same (dangerous due to the fact that servers can be accessed by hostname or IP etc)</param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.TicketingSystemConfiguration">
             <summary>
             Each Catalogue database can have 0 or 1 TicketingSystemConfiguration, this is a pointer to a plugin that handles communicating with a ticketing/issue system
             such as JIRA.  This ticketing system is used to record ticket numbers of a variety of objects (e.g. SupportingDocuments, extraction projects etc) and allows them
             to accrue man hours without compromising your current workflow.
             
             <para>In addition to tying objects to your ticketing system, the ticketing system will also be consulted about wheter data extraction projects are good to go or should
             not be released (e.g. do not release project X until it has been paid for / signed off by the governancer).  The exact implementation of this is mostly left to the
             ticketing class you write.</para>
             
             <para>The Type field refers to a class that implements PluginTicketingSystem (see LoadModuleAssembly for how to write your own handler or use one of the compatible existing ones).  
             this class will handle all communication with the ticketing system/server.</para>
            
             <para>There is also a reference to DataAccessCredentials record which stores optional username and encrypted password to use in the plugin for communicating with the ticketing system.</para>
             
             </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TicketingSystemConfiguration.IsActive">
            <summary>
            True if the ticketing system should be used/consulted.  Set to false if you want to temporarily disable the ticketing system link to RDMP
            without actually deleting the object. 
            
            <para>See:</para><see cref="M:Rdmp.Core.Repositories.CatalogueRepository.GetTicketingSystem"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TicketingSystemConfiguration.Url">
            <summary>
            The Url for communicating with the <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TicketingSystemConfiguration.Type">
            <summary>
            The C# System.Type of the <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/> which should be used to interact with the ticketing service
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TicketingSystemConfiguration.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TicketingSystemConfiguration.DataAccessCredentials_ID">
            <summary>
            The credentials to use to connect to the ticketing service (username/password)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.TicketingSystemConfiguration.DataAccessCredentials">
            <summary>
            Fetches the credentials to use when connecting to the ticketing service.  Returns null if no credentials have been
            configured.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TicketingSystemConfiguration.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.TicketingSystemConfiguration.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.Data.Common.DbDataReader)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.Data.WindowLayout">
            <summary>
            Persisted window layout of RDMPMainForm as Xml.  This can be used to reload RDMP to a given layout of windows and can be shared between users.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.WindowLayout.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.Data.WindowLayout.LayoutData">
            <summary>
            The Xml representation of the window layout being (e.g. what tabs are open, objects pinned etc)
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.WindowLayout.#ctor(MapsDirectlyToDatabaseTable.IRepository,System.String,System.String)">
            <summary>
            Record the new layout in the database
            </summary>
            <param name="repository"></param>
            <param name="name">Human readable name for the layout</param>
            <param name="layoutXml">The layout Xml of RDMPMainForm, use GetCurrentLayoutXml to get this, cannot be null</param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.WindowLayout.#ctor(MapsDirectlyToDatabaseTable.IRepository,System.Data.Common.DbDataReader)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.Data.WindowLayout.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.AggregateFilterFactory">
            <summary>
            Constructs IFilters etc for AggregateConfigurations (See IFilterFactory)
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.AggregateFilterFactory.#ctor(Rdmp.Core.Repositories.ICatalogueRepository)">
            <summary>
            Sets class up to create <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateFilter"/> objects in the provided <paramref name="repository"/>
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.AggregateFilterFactory.CreateNewFilter(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.AggregateFilterFactory.CreateNewParameter(Rdmp.Core.CatalogueLibrary.Data.IFilter,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.AggregateFilterFactory.GetRootOwnerType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.AggregateFilterFactory.GetIContainerTypeIfAny">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.ExtractionFilterFactory">
            <summary>
            Constructs IFilters etc for main Catalogue database filter (ExtractionFilter).  These are the master filters which are copied out as needed for cohort identification,
            extraction etc and therefore do not have any IContainer type (AND/OR).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.ExtractionFilterFactory.#ctor(Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation)">
            <summary>
            Prepares to create master extraction filters at <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> level which can be reused in cohort generation, project extractions etc.  Filters created
            will be stored under the specific <paramref name="extractionInformation"/> (extractable column) provided.
            </summary>
            <param name="extractionInformation"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.ExtractionFilterFactory.CreateNewFilter(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.ExtractionFilterFactory.CreateNewParameter(Rdmp.Core.CatalogueLibrary.Data.IFilter,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.ExtractionFilterFactory.GetRootOwnerType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.ExtractionFilterFactory.GetIContainerTypeIfAny">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.IFilterFactory">
            <summary>
            Facilitates the creation of IFilter (lines of WHERE Sql) and ISqlParameter (sql parameters - DECLARE @bob as varchar(10)) instances.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.IFilterFactory.CreateNewFilter(System.String)">
            <summary>
            Creates a new blank <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> with the provided <paramref name="name"/>.  Each implementation of this method may return a 
            different Type of filter but should be consistent with a given implementation.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.IFilterFactory.CreateNewParameter(Rdmp.Core.CatalogueLibrary.Data.IFilter,System.String)">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> with the provided <paramref name="parameterSQL"/> for use with the provided <paramref name="filter"/>.
            Each implementation of this method may return a different Type of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> but should be consistent with a given implementation.
            </summary>
            <param name="filter"></param>
            <param name="parameterSQL"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.IFilterFactory.GetRootOwnerType">
            <summary>
            The object Type which owns the root container e.g. if the IFilter is AggregateFilter then the IContainer Type is AggregateFilterContainers and the
            Root Owner Type is AggregateConfiguration
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.IFilterFactory.GetIContainerTypeIfAny">
            <summary>
            If the IFilter Type is designed to be held in IContainers then this method should return the Type of IContainer e.g. AggregateFilters belong in 
            AggregateFilterContainers
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.FilterImporting.FilterImporter">
            <summary>
            Facilitates the import of one IFilter type into the scope of another IFilter collection.  IFilters are lines of WHERE Sql.  This class is what allows you to import
            a Catalogue level filter (ExtractionFilter) into specific deployment containers e.g. during cohort creation task you can import a copy of 'prescribed @drugX' into
            your AggregateFilterContainer (this will actually create an AggregateFilter) and then import 2 more copies of that IFilter.  This class ensures that parameter names
            are unique so you can change the value of @drugX for each new IFilter imported. 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.FilterImporting.FilterImporter.AlternateValuesToUseForNewParameters">
            <summary>
            Specifies overriding definitions for <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> which should be used with all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> built by this class.  When you import
            a master filter that has parameters then this array will be consulted.  If a matching parameter name is found then the imported parameter will have that value
            rather than it's default.
            
            <para><seealso cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilterParameterSet"/></para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.FilterImporter.#ctor(Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.IFilterFactory,Rdmp.Core.CatalogueLibrary.Data.ISqlParameter[])">
            <summary>
            Sets up the factory to import filters which may or may not have parameters on them.
            </summary>
            <param name="factory">Determines which Type of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> is created</param>
            <param name="globals">If filters being imported have parameters that match the names of these globals the global value will be used to override.</param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.FilterImporter.ImportFilter(Rdmp.Core.CatalogueLibrary.Data.IFilter,Rdmp.Core.CatalogueLibrary.Data.IFilter[])">
            <summary>
            Creates a copy of the <paramref name="fromMaster"/> filter and any parameters it might have.  This will handle collisions on parameter name with
            <paramref name="existingFiltersAlreadyInScope"/> and will respect any globals this class was constructed with.
            </summary>
            <param name="fromMaster"></param>
            <param name="existingFiltersAlreadyInScope"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.FilterImporter.ImportAllFilters(Rdmp.Core.CatalogueLibrary.Data.IFilter[],Rdmp.Core.CatalogueLibrary.Data.IFilter[])">
            <summary>
            Imports a collection of IFilters of one type into another type.  Destination type corresponds to the factory.  Returns the newly created filters.
            </summary>
            <param name="allMasters"></param>
            <param name="existingFiltersAlreadyInScope"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.FilterImporter.IsProperlyDocumented(Rdmp.Core.CatalogueLibrary.Data.IFilter,System.String@)">
            <summary>
            Returns true if the <paramref name="filter"/> has a proper description, name etc.  This helps prevent poorly documented master filters.
            </summary>
            <param name="filter"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.FilterImporting.ParameterCreator">
            <summary>
            Handles the creation of new ISqlParameters based on the current WHERE SQL of a given IFilter.  This involves parsing the WHERE SQL for variables (@myVar).  This class
            also takes into account any globals that exist and supports the use of template parameter values for new ISqlParameter created (importFromIfAny)
            
            <para>globals are ISqlParameters which exist in the same scope as the IFilter being edited, if the WHERE Sql contains a parameter with the same name as a global then no new 
            ISqlParameter will be created.  For example if you have an IFilter "myfilter" with WhereSQL "@bob = 'bob'" and there are not already any parameters for the filter with the
            name @bob then a new one will be created (unless there is a global with the name @bob).</para>
            
            <para>importFromIfAny is a collection of template parameters that contain appropriate values to assign to newly created parameters.  The use case for this is when you are importing
            a Catalogue filter (E.g. ExtractionFilter) into a lower level (e.g. DeployedExtractionFilter) and you want to propagate down all the appropriate parameters to the new level.
            In this use case the WhereSQL is parsed and any matching parameter names have the values copied into the newly created parameters.</para>
            
            <para>This class relies on a delegate for creation of the actual parameter instances (See CreateAll method) </para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.ParameterCreator.#ctor(Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.IFilterFactory,System.Collections.Generic.IEnumerable{Rdmp.Core.CatalogueLibrary.Data.ISqlParameter},Rdmp.Core.CatalogueLibrary.Data.ISqlParameter[])">
            <summary>
            Sets up the factory to create parameters of the appropriate type (See <see cref="M:Rdmp.Core.CatalogueLibrary.FilterImporting.Construction.IFilterFactory.CreateNewParameter(Rdmp.Core.CatalogueLibrary.Data.IFilter,System.String)"/>) while respecting any global overriding parameters
            and any explicit <paramref name="importFromIfAny"/>
            </summary>
            <param name="factory">Decides the Type of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> created</param>
            <param name="globals">Globally overriding parameters, if a filter requires a parameter that matches a global no <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> is created</param>
            <param name="importFromIfAny">Desired parameter values, if a filter requires a parameter that matches importFromIfAny then it will get the value from here</param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.ParameterCreator.CreateAll(Rdmp.Core.CatalogueLibrary.Data.IFilter,Rdmp.Core.CatalogueLibrary.Data.ISqlParameter[])">
            <summary>
            Creates all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> required for the given <paramref name="filterToCreateFor"/> (based on it's WHERE Sql).  Will perform rename operations
            where there is already a conflicting <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> declared in the same scope (See <paramref name="existingParametersInScope"/>)
            </summary>
            <param name="filterToCreateFor"></param>
            <param name="existingParametersInScope"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.ParameterCreator.GetRequiredParamaterNamesForQuery(System.String,System.Collections.Generic.IEnumerable{Rdmp.Core.CatalogueLibrary.Data.ISqlParameter})">
            <summary>
            Lists the names of all parameters required by the supplied whereSql e.g. @bob = 'bob' would return "@bob" unless 
            there is already a global parameter called @bob.  globals is optional, pass in null if there aren't any
            </summary>
            <param name="whereSql">the SQL filter WHERE section you want to determine the parameter names in, does.  Should not nclude WHERE (only the boolean logic bit)</param>
            <param name="globals">optional parameter, an enumerable of parameters that already exist in a superscope (i.e. global parametetrs)</param>
            <returns>parameter names that are required by the SQL but are not already declared in the globals</returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.FilterImporting.ParameterCreator.RenameParameterInSQL(System.String,System.String,System.String)">
            <summary>
            Renames all references to a given parameter e.g. @myParam to the supplied <paramref name="parameterNameReplacement"/> e.g. @myParam2
            </summary>
            <param name="haystack">The Sql to find parameter references in</param>
            <param name="parameterName">The parameter name to replace</param>
            <param name="parameterNameReplacement">The new name that should replace it</param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.ForwardEngineerCatalogue">
            <summary>
            Creates a Catalogue from a TableInfo (See TableInfoImporter for how to create a TableInfo from your live database table).  A Catalogue is an extractable dataset
            which can be made by joining multiple underlying tables and often contains only a subset of columns (those that are extractable to researchers).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.ForwardEngineerCatalogue.#ctor(Rdmp.Core.CatalogueLibrary.Data.TableInfo,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo[],System.Boolean)">
            <summary>
            Sets up the class to create a new <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> from the supplied table reference
            </summary>
            <param name="tableInfo"></param>
            <param name="columnInfos"></param>
            <param name="markAllExtractable"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.ForwardEngineerCatalogue.ExecuteForwardEngineering(Rdmp.Core.CatalogueLibrary.Data.Catalogue@,Rdmp.Core.CatalogueLibrary.Data.CatalogueItem[]@,Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation[]@)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.ForwardEngineerCatalogue.ExecuteForwardEngineering"/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.ForwardEngineerCatalogue.ExecuteForwardEngineering">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> with <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/> and <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> with a one-to-one mapping to
             the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> this class was constructed with.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.ForwardEngineerCatalogue.ExecuteForwardEngineering(Rdmp.Core.CatalogueLibrary.Data.Catalogue)">
            <summary>
            Creates new <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/> and <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> with a one-to-one mapping to the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> this class was constructed with.
            
            <para>These new columns are added to an existing <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>.  Use this if you want a dataset that draws data from 2 tables using a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.JoinInfo"/></para>
            </summary>
            <param name="intoExistingCatalogue"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.ForwardEngineerCatalogue.ExecuteForwardEngineering(Rdmp.Core.CatalogueLibrary.Data.Catalogue,Rdmp.Core.CatalogueLibrary.Data.Catalogue@,Rdmp.Core.CatalogueLibrary.Data.CatalogueItem[]@,Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation[]@)">
            <inheritdoc cref="M:Rdmp.Core.CatalogueLibrary.ForwardEngineerCatalogue.ExecuteForwardEngineering"/>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.IEncryptStrings">
            <summary>
            Interface for classes which can encrypt/decrypt strings.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.IEncryptStrings.Encrypt(System.String)">
            <summary>
            Returns an encrypted representation of <paramref name="toEncrypt"/>
            </summary>
            <param name="toEncrypt"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.IEncryptStrings.Decrypt(System.String)">
            <summary>
            Decrypts the provided encrypted string <paramref name="toDecrypt"/> into a clear text string
            </summary>
            <param name="toDecrypt"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.IEncryptStrings.IsStringEncrypted(System.String)">
            <summary>
            Returns true if the provided string <paramref name="value"/> looks like it is encrypted.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.ILoadDirectory">
            <summary>
            Defines a rigid file structure in which there is a \Data\ diretory \ForLoading directory \ForArchiving\ etc.  This structure is used to drive the DLE and allows 
            for standardisation of structure within a dataset directory (i.e. we always load from ForLoading and then move them after loading into ForArchiving).  
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.ForLoading">
            <summary>
            The directory for storing files that should be loaded during DLE execution.  The contents of this folder will be archived after a succesful
            data load.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.ForArchiving">
            <summary>
            The directory for storing archived source files that were loaded during a DLE execution.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.Cache">
            <summary>
            The directory for storing time based cached files that will ultimately be loaded by the DLE.  Caching should occur independently of data loading
            and is designed to be a long running task (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cache.CacheProgress"/>).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.RootPath">
            <summary>
            The base working directory for the RDMP Data Load Engine.  This folder should contain the <see cref="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.DataPath"/> and the <see cref="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.ExecutablesPath"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.DataPath">
            <summary>
            The subdirectory of <see cref="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.RootPath"/> which contains <see cref="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.ForLoading"/>, <see cref="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.ForArchiving"/> and <see cref="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.Cache"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.ExecutablesPath">
            <summary>
            The subdirectory of <see cref="P:Rdmp.Core.CatalogueLibrary.ILoadDirectory.RootPath"/> which contains sql scripts and executables which can be run during the Data Load Engine execution.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.LoadDirectory">
            <summary>
            Basic implementation of ILoadDirectory including support for creating new templates on the file system.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.LoadDirectory.ForLoading">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.LoadDirectory.ForArchiving">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.LoadDirectory.Cache">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.LoadDirectory.RootPath">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.LoadDirectory.DataPath">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.LoadDirectory.ExecutablesPath">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.LoadDirectory.#ctor(System.String)">
            <summary>
            Declares that a new directory contains the folder structure required by the DLE.  Thows Exceptions if this folder doesn't exist or isn't set up yet.
            
            <para>Use static method <see cref="M:Rdmp.Core.CatalogueLibrary.LoadDirectory.CreateDirectoryStructure(System.IO.DirectoryInfo,System.String,System.Boolean)"/> if you want to create a new folder hierarchy on disk</para>
            </summary>
            <param name="rootPath"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.LoadDirectory.CreateDirectoryStructure(System.IO.DirectoryInfo,System.String,System.Boolean)">
            <summary>
            Creates a new directory on disk compatible with <see cref="T:Rdmp.Core.CatalogueLibrary.LoadDirectory"/>.
            </summary>
            <param name="parentDir">Parent folder to create the tree in e.g. c:\temp</param>
            <param name="dirName">Root folder name for the DLE e.g. LoadingBiochem</param>
            <param name="overrideExistsCheck">Determines behaviour if the folder already exists and contains files.  True to carry on, False to throw an Exception</param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.SimpleStringValueEncryption">
            <summary>
            Core RDMP implementation of RSA puublic/private key encryption.  In order to be secure you should create a private key (See PasswordEncryptionKeyLocationUI).  If
            no private key is configured then the default Key will be used (this is not secure and anyone with access to the RDMP source code could decrypt your strings - which
             is open source!). Strings are encrypted based on the key file.  Note that because RSA is a good encryption technique you will get a different output (encrypted) string
            value for repeated calls to Encrypt even with the same input string.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CatalogueLibrary.SimpleStringValueEncryption.PrivateKey">
            <summary>
            The private key file parameters required to encrypt/decrypt strings.  These will either be read from the secure location on disk (<see cref="!:PasswordEncryptionKeyLocation"/>) or
            will match the the default decryption certificate (<see cref="F:Rdmp.Core.CatalogueLibrary.SimpleStringValueEncryption.Key"/>).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.SimpleStringValueEncryption.Encrypt(System.String)">
            <summary>
            Encrypts using its Public Key then returns a the encrypted byte[] as a string by using BitConverter.ToString()
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.SimpleStringValueEncryption.Decrypt(System.String)">
            <summary>
            Takes an encrypted byte[] (in string format as produced by BitConverter.ToString() 
            </summary>
            <param name="toDecrypt"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.SupportingDocumentsFetcher">
            <summary>
            Copies SupportingDocuments associated with a project extraction request to the output directory.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.SynchronizationFailedException">
            <summary>
            Occurs when attempting to synchronize the RDMP catalogue state with a live database state.  For example dropping a table from your live database which
            is referenced by RDMP and attempting to synchronize that reference (See TableInfoSynchronizer)
            </summary>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.TableInfoSynchronizer">
            <summary>
            Synchronizes a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> against the live table on your database server.  This involves confirming it still exists, identifying new ColumnInfos and ones that have
            disapeared as well as checking column types and primary keys etc still match the current RDMP records.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.TableInfoSynchronizer.#ctor(Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <summary>
            Synchronizes the TableInfo against the underlying database to ensure the Catalogues understanding of what columns exist, what are primary keys,
            collation types etc match the reality.  Pass in an alternative 
            </summary>
            <param name="tableToSync"></param>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.TableInfoSynchronizer.Synchronize(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            
            </summary>
            <exception cref="T:Rdmp.Core.CatalogueLibrary.SynchronizationFailedException">Could not figure out how to resolve a synchronization problem between the TableInfo and the underlying table structure</exception>
            <param name="notifier">Called every time a fixable problem is detected, method must return true or false.  True = apply fix, False = don't - but carry on checking</param>
        </member>
        <member name="T:Rdmp.Core.CatalogueLibrary.WordCatalogueExtractor">
            <summary>
            Generates tables in a Microsoft Word document describing a Catalogue, it's CatalogueItems and any Issues associated with it.  This is used in data extraction 
            to generate metadata documents for the researchers to read (See WordDataWriter)
            </summary>
        </member>
        <member name="M:Rdmp.Core.CatalogueLibrary.WordCatalogueExtractor.AddMetaDataForColumns(Rdmp.Core.CatalogueLibrary.Data.CatalogueItem[],System.Collections.Generic.Dictionary{Rdmp.Core.CatalogueLibrary.Data.CatalogueItem,System.Tuple{System.String,System.String}[]})">
            <summary>
            
            </summary>
            <param name="cataItems">The CatalogueItems you want to write out ( should all belong to the same Catalogue) but may be a subset of the whole Catalogue e.g. those columns that were actualy extracted</param>
            <param name="supplementalData">A bunch of key value pairs (Tuple actually) that accompany a CatalogueItem and should be rammed into the table as it is written out, this could contain information only determined at runtime e.g. not part of the Catalogue</param>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.CreateNewCohortDatabaseWizard">
            <summary>
            Creates an ExternalCohortTable database implementation.  The implementation will be based on your live IsExtractionIdentifier columns 
            (PrivateIdentifierPrototype) and a release identifier allocation strategy (<see cref="T:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.IAllocateReleaseIdentifiers"/>)
             e.g. varchar(10) private patient identifier gets mapped to a new GUID.
            
            <para>This implementation is intended to be a basic solution only and lacks advanced features such having the same release identifier for the same primary
            key in subsequent versions of the same cohort (generally you want 1 - m private identifiers because you don't want people to be able to link patients
            across project extracts they are working on).</para>
            
            <para>See UserManual.docx for more information on how to tailor the resulting database to fit your needs.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.CohortCreationRequest">
            <summary>
            All metadata details nessesary to create a cohort including which project it goes into, it's name, version etc.  There are no identifiers for the cohort.
            Also functions as the use case for cohort creation (to which it passes itself as an input object).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.CohortCreationRequest.#ctor(Rdmp.Core.DataExport.Data.ExtractionConfiguration)">
            <summary>
            For refreshing the current extraction configuration CohortIdentificationConfiguration ONLY.  The ExtractionConfiguration must have a cic and a refresh pipeline configured on it.
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.CohortCreationRequest.#ctor">
            <summary>
            Design time types
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.CohortRefreshEngine">
            <summary>
            Executes an ExtractionConfiguration's CohortRefreshPipeline which should result in the CohortIdentificationConfiguration associated with the 
            ExtractionConfiguration (if any) being recalculated and a new updated set of patient identifiers commited as the next version number in the cohort
            database for that ExtractionConfiguration.
            
            <para>Use this class if you want to re-run a the patient identifiers of an ExtractionConfiguration without changing the cohort identification configuration
            query (say 1 month later you want to generate an extract with the new patients fitting cohort criteria).</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.CreateTableFromAggregateUseCase">
            <summary>
            Use case which describes creating a new table in the database containing all rows matched by the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>.
            The source is fixed the destination and middle components are open.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.CreateTableFromAggregateUseCase.#ctor(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,Rdmp.Core.DataExport.Data.ExtractableCohort,FAnsi.Discovery.DiscoveredTable)">
            <summary>
            Defines a new use case in which the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> will be turned into an SQL query and used to generate rows
            that will be released into the pipeline.  The source is fixed the destination and middle components are open.
            </summary>
            <param name="aggregateConfiguration">The aggregate query that will be run to generate the rows</param>
            <param name="constrainByCohort">Only applies if <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> is a patient index table, specifying a cohort will only commit rows 
            in which the patient id appears in the cohort</param>
            <param name="table">The destination table in which to put the matched records.
            <para> (table does not have to exist yet, you can use <see cref="M:FAnsi.Discovery.DiscoveredDatabase.ExpectTable(System.String,System.String,FAnsi.Discovery.TableType)"/> to obtain a reference to a non existant table)</para></param>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.CreateTableFromAggregateUseCase.#ctor">
            <summary>
            Design time types
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination">
            <summary>
            Destination component for Cohort Creation Pipelines, responsible for bulk inserting patient identifiers into the cohort database specified in the
            ICohortCreationRequest.  This 
            </summary>
        </member>
        <member name="P:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination.Request">
            <summary>
            The cohort blueprint we are trying to create.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination.ProcessPipelineData(System.Data.DataTable,ReusableLibraryCode.Progress.IDataLoadEventListener,Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <summary>
            Extracts private identifiers from table <paramref name="toProcess"/> and allocates release identifiers.  Cohort is only finalised and comitted into the database
            in the <see cref="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination.Dispose(ReusableLibraryCode.Progress.IDataLoadEventListener,System.Exception)"/> method (to prevent incomplete cohorts existing in the database).
            
            <para>Method can be called multiple times in the lifetime of a pipeline (e.g. if you have very large cohorts and the pipeline source is batching).</para>
            </summary>
            <param name="toProcess">A batch of private identifiers</param>
            <param name="listener"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination.Dispose(ReusableLibraryCode.Progress.IDataLoadEventListener,System.Exception)">
            <summary>
            Commits the cohort created into the database (assuming no error occured during pipeline processing - See <paramref name="pipelineFailureExceptionIfAny"/>).
            </summary>
            <param name="listener"></param>
            <param name="pipelineFailureExceptionIfAny"></param>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination.Abort(ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Does nothing
            </summary>
            <param name="listener"></param>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination.PreInitialize(Rdmp.Core.CohortCommitting.Pipeline.ICohortCreationRequest,ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Initialises <see cref="P:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination.Request"/>
            </summary>
            <param name="value"></param>
            <param name="listener"></param>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks <see cref="P:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination.ReleaseIdentifierAllocator"/> has been set up and that a properly populated <see cref="P:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination.Request"/> has been set.
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.GuidReleaseIdentifierAllocator">
            <summary>
            Allocates a Guid for each private identifier supplied.  This will not keep track of duplicates (every call results in a new guid regardless of the input).
            </summary>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.GuidReleaseIdentifierAllocator.AllocateReleaseIdentifier(System.Object)">
            <summary>
            Generates a new unique identifier as a string (does not do any form of lookup - every call is a new guid)
            </summary>
            <param name="privateIdentifier"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.GuidReleaseIdentifierAllocator.Initialize(Rdmp.Core.CohortCommitting.Pipeline.ICohortCreationRequest)">
            <summary>
            Does nothing
            </summary>
            <param name="request"></param>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.IAllocateReleaseIdentifiers">
            <summary>
            Class responsible for allocating Release Identifiers for a Cohort that is being committed (see <see cref="T:Rdmp.Core.CohortCommitting.Pipeline.Destinations.BasicCohortDestination"/>) when the user has not supplied any in 
            the file/cohort he is uploading.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.IAllocateReleaseIdentifiers.AllocateReleaseIdentifier(System.Object)">
            <summary>
            Return a new (or existing) anonymous mapping for the provided <paramref name="privateIdentifier"/>.  This will be called for
            novel identifiers only in a given batch being processed so you do not need to track your return values.
            </summary>
            <param name="privateIdentifier"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.IAllocateReleaseIdentifiers.Initialize(Rdmp.Core.CohortCommitting.Pipeline.ICohortCreationRequest)">
            <summary>
            Called before any allocation, lets you know what <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> etc is involved in the cohort creation attempt.
            </summary>
            <param name="request"></param>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.ProjectConsistentGuidReleaseIdentifierAllocator">
            <summary>
            Allocates a Guid for each private identifier supplied.  This is similar to <see cref="T:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.GuidReleaseIdentifierAllocator"/> except that it will preserve previous
            allocations within the <see cref="T:Rdmp.Core.DataExport.Data.Project"/>.  For example if you commit a cohort 'Cases' with private id '123' to project '10' then might get a guid 'abc...',
            if you then submit verison 2 of the cohort you will get the same guid ('abc...') for persion '123'.  
            
            <para>Guids are always different between <see cref="T:Rdmp.Core.DataExport.Data.Project"/> for example person 'abc' in project '10' will have a different Guid release identifier than if he
            was committed to project '11' and it would be impossible to link the two release identifiers</para>
            
            <para>Projects are differentiated by <see cref="P:Rdmp.Core.DataExport.Data.Project.ProjectNumber"/> since this is what is stored in your cohort database</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.ProjectConsistentGuidReleaseIdentifierAllocator.AllocateReleaseIdentifier(System.Object)">
            <summary>
            Returns the existing anonymous release identifier for the <paramref name="privateIdentifier"/> if it has ever been
            uploaded to the given <see cref="T:Rdmp.Core.DataExport.Data.Project"/> before otherwise returns a new unique guid as a string.
            </summary>
            <param name="privateIdentifier"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.ProjectConsistentGuidReleaseIdentifierAllocator.GetReleaseMap">
            <summary>
            Figures out all the previously allocated release identifiers for private identifiers for cohorts assigned to the projectNumber
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CohortCommitting.Pipeline.Destinations.IdentifierAllocation.ProjectConsistentGuidReleaseIdentifierAllocator.Initialize(Rdmp.Core.CohortCommitting.Pipeline.ICohortCreationRequest)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.ICohortCreationRequest">
            <summary>
            See CohortCreationRequest
             </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.ICohortPipelineDestination">
            <summary>
            Destination component interface for Cohort Creation Pipelines.  Must fulfill the ICohortCreationRequest and populate the Cohort Source with the 
            identifiers supplied in the DataTable.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.IPluginCohortDestination">
            <summary>
            MEF discoverble version of ICohortPipelineDestination (See ICohortPipelineDestination).  Implement this interface if you are writing a custom cohort
            storage system and need to populate it with identifiers through the RDMP Cohort Creation Pipeline Processes.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.Sources.AggregateConfigurationTableSource">
            <summary>
            Pipeline source component which executes an AggregateConfiguration query (e.g. Aggregate Graph / Joinable patient index table)
            </summary>
        </member>
        <member name="P:Rdmp.Core.CohortCommitting.Pipeline.Sources.AggregateConfigurationTableSource.TableName">
            <summary>
            The name to give the table produced into the pipeline
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.Sources.CohortIdentificationConfigurationSource">
            <summary>
            Executes a Cohort Identification Configuration query and releases the identifiers read into the pipeline as a single column DataTable.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CohortCommitting.Pipeline.Sources.CohortIdentificationConfigurationSource.ClearCohortIdentificationConfigurationCacheBeforeRunning">
            <summary>
            If you are refreshing a cohort or running a cic which was run and cached a long time ago you might want to clear out the cache.  This will mean that
            when run you will get a view of the live tables (which might be recached as part of building the cic) rather than the (potentially stale) current cache
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.Sources.PatientIdentifierColumnSource">
            <summary>
            Pipeline source component that generates a DataTable containing all the unique patient identifiers in the column referenced by the <see cref="T:Rdmp.Core.DataFlowPipeline.Requirements.IPipelineRequirement`1"/> 
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/>.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.Pipeline.Sources.PatientIndexTableSource">
            <summary>
            Pipeline source component which executes an AggregateConfiguration query in a CohortIdentificationConfiguration which has the role of 
            'Patient Index Table' (JoinableCohortAggregateConfiguration).  A 'Patient Index Table' is what researchers call any table with information
            about patients (e.g. a table containing every prescription date for a given drug) in which the data (not patient identifiers) is directly 
            used to identify their cohort (e.g. cohort query is 'everyone who has been hospitalised with code X within 6 months of having a prescription
            of drug Y - in this case the patient index table is 'the prescribed dates of drug Y').  
            
            <para>Since 'Patient Index Tables' always contain a superset of the final identifiers this component will add an additional filter to the query
            to restrict rows returned only to those patients in your final cohort list (you must already have a committed final cohort list to use this
            component).  This prevents you saving a snapshot of 1,000,000 prescription dates when your final cohort of patients only own 500 of those 
            records (because the cohort identification configuration includes further set operations that reduce the patient count beyond the prescribed drug Y).</para>
            
            <para>The purpose of all this is usually to ship a table ('Patient Index Table') which was used to build the researchers cohort into the saved cohorts 
            database so it can be linked and extracted (as custom data) along with all the normal datasets that make up the researchers extract.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCommitting.PrivateIdentifierPrototype">
            <summary>
            The datatype of an IsExtractionIdentifier column found in (at least) one of your Catalogues.  This is used to help you make an informed descision about
            what datatype to store patient identifiers in when creating a new cohort database (See CreateNewCohortDatabaseWizard).  Every IsExtractionIdentifier column
            datatype will be listed along with a count of the number of columns with that datatype and the user (or system) will be allowed to select one.
            
            <para>This helps if you have for example 30 datasets where the patient identifier is varchar(10) and 5 where it is varchar(max) - logical choice is varchar(10).</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCreation.Execution.AggregationContainerTask">
            <summary>
            The runtime/compile time wrapper for CohortAggregateContainer. UNION,EXCEPT,INTERSECT containers with 0 or more AggregateConfigurations within
            them - also optionally with other sub containers.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCreation.Execution.AggregationTask">
            <summary>
            A single AggregateConfiguration being executed by a CohortCompiler.  The AggregateConfiguration will be a query like 'select distinct patientId from 
            TableX where ...'.  The  query result table can/will be commited as a CacheCommitIdentifierList to  the CachedAggregateConfigurationResultsManager.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCreation.Execution.CohortCompiler">
            <summary>
            Multi threading management class for CohortQueryBuilder.  Supports starting, executing and cancelling multiple cohort builder objects (ICompileable)
            at once.  Every input object (e.g. CohortAggregateContainer) will be assigned a corresponding ICompileable (e.g. AggregationContainerTask) and a
            CohortIdentificationTaskExecution.  The ICompileable records how long the query has been running for, how much of the query is cached, whether it 
            has been cancelled / crashed etc.  The CohortIdentificationTaskExecution handles the actual execution of the query on the data set database.
            
            <para>See CohortCompiler.cd</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CohortCreation.Execution.CohortCompiler.AddAllTasks(System.Boolean)">
            <summary>
            Adds all subqueries and containers that are below the current CohortIdentificationConfiguration as tasks to the compiler
            </summary>
            <param name="addSubcontainerTasks">The root container is always added to the task list but you could skip subcontainer totals if all you care about is the final total for the cohort
            and you don't have a dependant UI etc.  Passing false will add all joinables, subqueries etc and the root container (final answer for who is in cohort) only.</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CohortCreation.Execution.CohortCompiler.AddTasksRecursively(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter[],Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer,System.Boolean)">
            <summary>
            Adds all AggregateConfigurations and CohortAggregateContainers in the specified container or subcontainers. Passing addSubcontainerTasks false will still process the subcontainers
            but will only add AggregateConfigurations to the task list
            </summary>
            <param name="globals"></param>
            <param name="container"></param>
            <param name="addSubcontainerTasks">The root container is always added to the task list but you could skip subcontainer totals if all you care about is the final total for the cohort
            and you don't have a dependant UI etc.  Passing false will add all joinables, subqueries etc and the root container (final answer for who is in cohort) only.</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CohortCreation.Execution.CohortCompiler.AddTask(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable,System.Collections.Generic.IEnumerable{Rdmp.Core.CatalogueLibrary.Data.ISqlParameter})">
            <summary>
            Adds the given AggregateConfiguration, CohortAggregateContainer or JoinableCohortAggregateConfiguration to the compiler Task list or returns the existing
            ICompileable if it is already part of the Compilation list.  This will not start the task, you will have to call Launch... to start the ICompileable executing
            </summary>
            <param name="runnable">An AggregateConfiguration, CohortAggregateContainer or JoinableCohortAggregateConfiguration you want to schedule for execution</param>
            <param name="globals"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CohortCreation.Execution.CohortCompiler.CancelAllTasks(System.Boolean)">
            <summary>
            Stops the execution of all currently executing ICompileable CohortIdentificationTaskExecutions. If it is executing an SQL query this should cancel the ongoing query.  If the
            ICompileable is not executing (it has crashed or finished etc) then nothing will happen.  alsoClearFromTaskList is always respected
            </summary>
            <param name="alsoClearTaskList">True to also remove all ICompileables, False to leave the Tasks intact (allows you to rerun them or clear etc)</param>
        </member>
        <member name="M:Rdmp.Core.CohortCreation.Execution.CohortCompiler.CancelTask(Rdmp.Core.CohortCreation.ICompileable,System.Boolean)">
            <summary>
            Stops execution of the specified ICompileable CohortIdentificationTaskExecutions.  If it is executing an SQL query this should cancel the ongoing query.  If the
            ICompileable is not executing (it has crashed or finished etc) then nothing will happen.  alsoClearFromTaskList is always respected
            </summary>
            <param name="compileable"></param>
            <param name="alsoClearFromTaskList">True to remove the ICompileable from the tasks list, False to leave the Tasks intact (allows you to rerun it or clear etc) </param>
        </member>
        <member name="T:Rdmp.Core.CohortCreation.Execution.CohortCompilerRunner">
            <summary>
            Manages the adding and executing of tasks in a CohortCompiler to execute a CohortIdentificationConfiguration in the most optimised way when a cache server is present.  For example it
            will run all the individual 'Patient Index Tables' first and cache them, then run the individual 'cohort queries' and cache those before finally running the top level set containers
            (which will now execute from the cached lists).
            </summary>
        </member>
        <member name="P:Rdmp.Core.CohortCreation.Execution.CohortCompilerRunner.RunSubcontainers">
            <summary>
            The root container is always added to the task list but you could skip subcontainer totals if all you care about is the final total for the cohort
            and you don't have a dependant UI etc.  Setting false will add all joinables, subqueries etc and the root container (final answer for who is in cohort) 
            but not the other subcontainers (if there were any in the first place!).  Defaults to true.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CohortCreation.Execution.CohortCompilerRunner.#ctor(Rdmp.Core.CohortCreation.Execution.CohortCompiler,System.Int32)">
            <summary>
            Creates a new runner for the given <paramref name="compiler"/> which will facilitate running it's Tasks in a sensible order using result caching if possible
            </summary>
            <param name="compiler"></param>
            <param name="timeout">CommandTimeout for each individual command in seconds</param>
        </member>
        <member name="T:Rdmp.Core.CohortCreation.Execution.CohortIdentificationTaskExecution">
            <summary>
            An ongoing async execution of a cohort identification subquery in the CohortCompiler.  Includes the query used to fetch the cohort identifiers, the 
            identifiers themselves (once complete), cancellation token etc.
            </summary>
        </member>
        <member name="P:Rdmp.Core.CohortCreation.Execution.CohortIdentificationTaskExecution.CountSQL">
            <summary>
            Although this is called CountSQL it is actually a select distinct identifiers!
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCreation.Execution.ICacheableTask">
            <summary>
            Any ICompileable which can be cached once finished.  Typically any ICompileable in a CohortCompiler can be cached unless it is composed of multiple discrete
            sub queries (i.e. an AggregationContainerTask.) 
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCreation.Execution.Joinables.JoinableTask">
            <summary>
            A single AggregateConfiguration being executed by a CohortCompiler which is defined as a JoinableCohortAggregateConfiguration.  The 
            AggregateConfiguration will be a query like 'select distinct patientId, drugName,prescribedDate from  TableX where ...'.  The  query
            result table can/will be commited as a CacheCommitJoinableInceptionQuery to  the CachedAggregateConfigurationResultsManager.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CohortCreation.ICompileable">
            <summary>
            A cohort identification container (AggregateContainer) or sub query (AggregateConfiguration) that is running in a CohortCompiler and will be 
            given the results of the execution (CohortIdentificationTaskExecution).
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandExecution.AtomicCommands.IAtomicCommandWithTarget">
            <summary>
            An executable command with variable target.  SetTarget should be obvious based on your class name e.g. ExecuteCommandRelease (pass a Project to release).
            
            <para>In general you should also provide a constructor overload that hydrates the command properly decorated with [ImportingConstructor] so that it is
            useable with RunUI</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.CommandExecution.AtomicCommands.IAtomicCommandWithTarget.SetTarget(Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity)">
            <summary>
            Defines the object which this command should operate on
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CommandExecution.ExecuteCommandCreateLookup">
            <summary>
            Creates a new Lookup relationship between two <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/>.  This will allow you to optionally extract code descriptions side by side code values (e.g. SexCode, SexCode_Desc)
            by joining the two tables.  It also allows you to extract the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> along side the main dataset when it is extracted for research projects.
            </summary>
        </member>
        <member name="M:Rdmp.Core.CommandExecution.ExecuteCommandCreateLookup.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo[],System.Collections.Generic.List{System.Tuple{Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo}},System.String,System.Boolean)">
            <summary>
            Creates a knowledge that one <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> provides a description for a code in a column of a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/>).  
            There can be multiple join keys and multiple descriptions can be selected at once (e.g. SendingLocationCode=> LocationTable.AddressLine1, LocationTable.AddressLine2) etc.
            
            <para>See parameter descriptions for help</para>
            </summary>
            <param name="catalogueRepository"></param>
            <param name="foreignKeyExtractionInformation">The extractable column in the main dataset which contains the lookup code foreign key e.g. PatientSexCode </param>
            <param name="lookupDescriptionColumns">The column(s) in the lookup that contain the free text description of the code e.g. SexDescription, SexDescriptionLong etc</param>
            <param name="fkToPkTuples">Must have at least 1, Item1 must be the foreign key column in the main dataset, Item2 must be the primary key column in the lookup. 
                <para>MOST lookups have 1 column paring only e.g. genderCode but some crazy lookups have duplication of code with another column e.g. TestCode+Healthboard as primary keys into lookup</para></param>
            <param name="collation"></param>
            <param name="alsoCreateExtractionInformations">True to create a new virtual column in the main dataset so that the code description appears inline with the rest of 
            the column(s) in the dataset (when the SELECT query is built)</param>
        </member>
        <member name="M:Rdmp.Core.CommandExecution.ExecuteCommandCreateLookup.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,System.String,System.Boolean)">
            <summary>
            Creates a knowledge that one <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> provides a description for a code in a column of a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/>).
            </summary>
            <param name="catalogueRepository"></param>
            <param name="foreignKeyExtractionInformation">The extractable column in the main dataset which contains the lookup code foreign key e.g. PatientSexCode </param>
            <param name="lookupDescriptionColumn">The column in the lookup table containing the code description that you want</param>
            <param name="lookupTablePrimaryKey">The column in the lookup which contains the code e.g. LocationCode</param>
            <param name="collation">Optional - the collation to use when linking the columns</param>
            <param name="alsoCreateExtractionInformations">True to create a new virtual column in the main dataset so that the code description appears inline with the rest of 
            the columns in the dataset (when the SELECT query is built)</param>
        </member>
        <member name="M:Rdmp.Core.CommandExecution.ExecuteCommandCreateLookup.Execute">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.CommandExecution.ExecuteCommandExportObjectsToFile">
            <summary>
            Gathers dependencies of the supplied objects and extracts the share definitions to a directory.  This will have the side effect of creating an ObjectExport declaration
            if none yet exists which will prevent accidental deletion of the object and enable updating people who receive the definition later on via the sharing Guid.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.DatabaseCreation.CataloguePipelinesAndReferencesCreation">
            <summary>
            Creates default pipelines required for basic functionality in RDMP.  These are templates that work but can be expanded upon / modified by the user.  For
            example the user might want to add a ColumnBlacklister to the default export pipeline to prevent sensitive fields being extracted etc.
            
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.DatabaseCreation.PlatformDatabaseCreationOptions">
            <summary>
            Command line arguments for DatabaseCreation.exe
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.DatabaseCreation.PlatformDatabaseCreationRepositoryFinder">
            <summary>
            IRDMPPlatformRepositoryServiceLocator which identifies the location of Catalogue and Data Export databases during the runtime of DatabaseCreation.exe
            
            <para>Since these connection strings are part of the command line arguments to DatabaseCreation.exe it's a pretty simple class!</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Options.Abstracts.CacheOptions">
            <summary>
            Command line options for the caching engine
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Options.Abstracts.CohortCreationOptions">
            <summary>
            Command line options for the Cohort Creation Pipelines
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Options.Abstracts.DleOptions">
            <summary>
            Command line options for the Data Load Engine
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Options.Abstracts.ExtractionOptions">
            <summary>
            Options for the Extraction Engine which performs cohort linkage against datasets and extracts anonymous datasets
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Options.Abstracts.PackOptions">
            <summary>
            Command line arguments for PluginPackager.exe
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Options.Abstracts.RDMPCommandLineOptions">
            <summary>
            Abstract base class for all command line options that can be supplied to the rdmp cli (includes overriding app.config to get connection strings to platform metadata databases)
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Options.Abstracts.ReleaseOptions">
            <summary>
            Options for the Release Engine which is responsible for gathering all the artifacts produced by the Extraction Engine (anonymised project extracts, bundled lookups and documents etc)
            and transmitting them somewhere as a final released package.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Packing.Packager">
            <summary>
            Creates a .zip file containing all binary files and (optionally) source code for an RDMP plugin.  The resulting zip file can be committed as a Plugin 
            to the Catalogue database.  Takes as input the .sln file path.  Binaries that are already part of the core RDMP will not be included in the zip (e.g.
            CatalogueLibrary.dll etc). 
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Runners.CacheRunner">
            <summary>
            Automation task that runs a single CacheProgress until it is up-to-date (all available data read) or crashes.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Runners.CohortCreationRunner">
            <summary>
            Runner for Cohort Creation Tasks.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Runners.DleRunner">
            <summary>
            <see cref="T:Rdmp.Core.CommandLine.Runners.IRunner"/> for the Data Load Engine.  Supports both check and execute commands.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Runners.ExtractionRunner">
            <summary>
            Runs the extraction process for an <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/> in which all the datasets are linked and extracted to appropriate destination
            (e.g. CSV, remote database etc)
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Runners.IRunner">
            <summary>
            interface for all processes which satiate an <see cref="T:Rdmp.Core.CommandLine.Options.Abstracts.RDMPCommandLineOptions"/> derrived command by running a given engine on the supplied input objects
            </summary>
        </member>
        <member name="F:Rdmp.Core.CommandLine.Runners.ManyRunner._oLock">
            <summary>
            Lock for all operations that read or write to <see cref="F:Rdmp.Core.CommandLine.Runners.ManyRunner._checksDictionary"/>.  Use it if you want to enumerate / read the results
            </summary>
        </member>
        <member name="M:Rdmp.Core.CommandLine.Runners.ManyRunner.GetSingleCheckerResults``1">
            <summary>
            Returns the ToMemoryCheckNotifier that corresponds to the given checkable Type (of which there must only be one in the dictionary e.g. a globals checker).
            
            <para>Use GetCheckerResults to get multiple </para>
            
            <para>Returns null if there are no checkers of the given Type</para>
            </summary>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.InvalidOperationException">Thrown if there are more than 1 ICheckable of the type T</exception>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CommandLine.Runners.ManyRunner.GetSingleCheckerResults``1(System.Func{``0,System.Boolean})">
            <summary>
            Returns the ToMemoryCheckNotifier that corresponds to the given checkable Type which matches the func.
            
            <para>Returns null if there are no checkers of the given Type matching the func</para>
            </summary>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.InvalidOperationException">Thrown if there are more than 1 ICheckable of the type T</exception>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.CommandLine.Runners.ManyRunner.GetCheckerResults``1(System.Func{``0,System.Boolean})">
            <summary>
            Returns the results for the given <see cref="T:ReusableLibraryCode.Checks.ICheckable"/> type which match the function
            </summary>
            <typeparam name="T"></typeparam>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Runners.ReleaseRunner">
            <summary>
            Runs the release process for one or more <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/> in the same <see cref="T:Rdmp.Core.DataExport.Data.Project"/>.  This is the proces by which we gather all the artifacts
            produced by the Extraction Engine (anonymised project extracts, bundled lookups and documents etc) and transmit them somewhere as a final released package.
            </summary>
        </member>
        <member name="T:Rdmp.Core.CommandLine.Runners.RunnerFactory">
            <summary>
            Constructs the respective <see cref="T:Rdmp.Core.CommandLine.Runners.IRunner"/> based on the supplied <see cref="T:Rdmp.Core.CommandLine.Options.Abstracts.RDMPCommandLineOptions"/> Type
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.BetweenCatalogueAndDataExportObscureDependencyFinder">
            <summary>
            Prevents deleting objects in Catalogue database which are referenced by objects in Data Export database (between databases referential integrity).  Also
            handles cascading deletes between databases e.g. Deleting Project Associations when a Cohort Identification Configuration is deleted (despite records being
            in different databases).
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.BetweenCatalogueAndDataExportObscureDependencyFinder.#ctor(Rdmp.Core.Repositories.IDataExportRepositoryServiceLocator)">
            <summary>
            Sets up class to fobid deleting <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> that are in project extractions etc.
            </summary>
            <param name="serviceLocator"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.BetweenCatalogueAndDataExportObscureDependencyFinder.ThrowIfDeleteDisallowed(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.BetweenCatalogueAndDataExportObscureDependencyFinder.HandleCascadeDeletesForDeletedObject(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Checks.ExtractionConfigurationChecker">
            <summary>
            Checks <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/> to ensure they are in a valid state for execution (have a cohort, linkable patient columns etc).  Optionally also checks
            each dataset in the configuration with a <see cref="T:Rdmp.Core.DataExport.Checks.SelectedDataSetsChecker"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Checks.ExtractionConfigurationChecker.CheckDatasets">
            <summary>
            True to fetch all <see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/> and check with <see cref="T:Rdmp.Core.DataExport.Checks.SelectedDataSetsChecker"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Checks.ExtractionConfigurationChecker.CheckGlobals">
            <summary>
            True to also check all globals with a <see cref="T:Rdmp.Core.DataExport.Checks.GlobalExtractionChecker"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.ExtractionConfigurationChecker.#ctor(Rdmp.Core.DataExport.Data.IExtractionConfiguration)">
            <summary>
            Prepares checking of the given <paramref name="config"/>
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.ExtractionConfigurationChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the configuration is in a valid state.  Supports both released (frozen) <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/> and unreleased ones.
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.Checks.GlobalExtractionChecker">
            <summary>
            Checks that all the globals (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/> / <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable"/>) that would be fetched as part of an
            <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/> are accessible.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.GlobalExtractionChecker.#ctor(Rdmp.Core.DataExport.Data.ExtractionConfiguration)">
            <summary>
            Prepares to check the globals extractable artifacts that should be fetched when extracting the <paramref name="configuration"/>
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.GlobalExtractionChecker.#ctor(Rdmp.Core.DataExport.Data.ExtractionConfiguration,Rdmp.Core.DataExport.ExtractionTime.Commands.ExtractGlobalsCommand,Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline)">
            <inheritdoc cref="M:Rdmp.Core.DataExport.Checks.GlobalExtractionChecker.#ctor(Rdmp.Core.DataExport.Data.ExtractionConfiguration)"/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.GlobalExtractionChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that all globals pass thier respective checkers (<see cref="T:Rdmp.Core.DataExport.Checks.SupportingSQLTableChecker"/> and <see cref="T:Rdmp.Core.CatalogueLibrary.SupportingDocumentsFetcher"/>) and that
            the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> (if any) is capable of extracting the globals.
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.Checks.GlobalsReleaseChecker">
            <summary>
            Checks the release state of the Globals that should have been extracted as part of the given <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/>.  If they
            are missing then the overall release should not be run.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.GlobalsReleaseChecker.#ctor(Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator,Rdmp.Core.DataExport.Data.IExtractionConfiguration[],MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Sets up checking of extracted global artifacts of the <paramref name="extractionConfigurations"/> to ensure that none have been missed and all are in 
            a fit state to be shipped off in a release package.  You require one <see cref="T:Rdmp.Core.DataExport.Checks.GlobalsReleaseChecker"/> per global (which should be passeed as
            <paramref name="globalToCheck"/>).
            </summary>
            <param name="repositoryLocator"></param>
            <param name="extractionConfigurations"></param>
            <param name="globalToCheck">Determines the return of <see cref="M:Rdmp.Core.DataExport.Checks.GlobalsReleaseChecker.GetEvaluator"/>.  Pass a global </param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.GlobalsReleaseChecker.GetEvaluator">
            <summary>
            Only call if globalToCheck was provided during construction.  This method looks up the database to find a <see cref="T:Rdmp.Core.DataExport.Data.SupplementalExtractionResults"/> record
            that audits the extraction of the global.  If no audit exists then a <see cref="T:Rdmp.Core.DataExport.DataRelease.Potential.NoGlobalReleasePotential"/> is returned (not releasable).  Otherwise a 
            <see cref="T:Rdmp.Core.DataExport.DataRelease.Potential.GlobalReleasePotential"/> is generated by the <see cref="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Destinations.IExecuteDatasetExtractionDestination"/> reported in the audit (e.g. if the extraction
            was to database it might check for tables matching a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable"/>).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.GlobalsReleaseChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks extraction directory for unexpected files.  Call <see cref="M:Rdmp.Core.DataExport.Checks.GlobalsReleaseChecker.GetEvaluator"/> if want to know whether a specific global artifact is in a valid 
            state.
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.Checks.ProjectChecker">
            <summary>
            Runs checks on a Project to make sure it has an extraction folder, project number etc.  Also checks ExtractionConfigurations that are part of the project
            to see if valid queries can be built and rows read.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Checks.ProjectChecker.CheckConfigurations">
            <summary>
            True to fetch all <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> and check with <see cref="T:Rdmp.Core.DataExport.Checks.ExtractionConfigurationChecker"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Checks.ProjectChecker.CheckDatasets">
            <summary>
            True to fetch all <see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/> and check with <see cref="T:Rdmp.Core.DataExport.Checks.SelectedDataSetsChecker"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.ProjectChecker.#ctor(Rdmp.Core.DataExport.Data.IProject)">
            <summary>
            Sets up the class to check the state of the <paramref name="project"/>
            </summary>
            <param name="project"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.ProjectChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks the <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> has a valid <see cref="P:Rdmp.Core.DataExport.Data.IProject.ExtractionDirectory"/>, <see cref="P:Rdmp.Core.DataExport.Data.IProject.ProjectNumber"/> etc and runs additional 
            checkers (See <see cref="P:Rdmp.Core.DataExport.Checks.ProjectChecker.CheckConfigurations"/> and <see cref="P:Rdmp.Core.DataExport.Checks.ProjectChecker.CheckDatasets"/>).
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.Checks.SelectedDataSetsChecker">
            <summary>
            Checks that the <see cref="T:Rdmp.Core.DataExport.Data.SelectedDataSets"/> can be built into a valid SQL extraction Query and that the SQL generated can be executed
            without syntax errors.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Checks.SelectedDataSetsChecker.SelectedDataSet">
            <summary>
            The selected dataset being checked
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.SelectedDataSetsChecker.#ctor(Rdmp.Core.DataExport.Data.ISelectedDataSets,System.Boolean,Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline)">
            <summary>
            prepares to check the dataset as it is selected in an <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/>.  Optionally checks an extraction <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.Pipeline"/> and globals
            </summary>
            <param name="selectedDataSet"></param>
            <param name="checkGlobals"></param>
            <param name="alsoCheckPipeline"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.SelectedDataSetsChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks the <see cref="P:Rdmp.Core.DataExport.Checks.SelectedDataSetsChecker.SelectedDataSet"/> and reports success/failures to the <paramref name="notifier"/>
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.Checks.SupportingSQLTableChecker">
            <summary>
            Checks that a given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable"/> is reachable by the current user and that the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable.SQL"/> can be executed and returns data.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.SupportingSQLTableChecker.#ctor(Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable)">
            <summary>
            Sets up checking of the supplied
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Checks.SupportingSQLTableChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the table can be reached on it's listed server and that at least one row can be read from it.
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.CohortDescribing.CohortDescriptionDataTableAsyncFetch">
            <summary>
            Async class for fetching the number of unique patients / custom tables in every cohort (ExtractableCohort) in a cohort database (ExternalCohortTable)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.CohortDescribing.CohortDescriptionFactory">
            <summary>
            Creates ExtractableCohortDescription objects for each of your cohorts, this involves issuing an async request to the cohort endpoints to calcualte things like 
            Count, CountDistinct etc.  The ExtractableCohortDescription objects returned from Create will not be populated with values until the async finishes and will have only
            placeholder values like "Loading..." etc
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.CohortDescribing.CohortDescriptionFactory.#ctor(Rdmp.Core.Repositories.IDataExportRepository)">
            <summary>
            Creates ExtractableCohortDescription objects for each of your cohorts, this involves issuing an async request to the cohort endpoints to calcualte things like 
            Count, CountDistinct etc.  The ExtractableCohortDescription objects returned from Create will not be populated with values until the async finishes and will have only
            placeholder values like "Loading..." etc
            </summary>
            <param name="repository">The DataExportRepository containing all your cohort refrences (ExtractableCohorts)</param>
        </member>
        <member name="M:Rdmp.Core.DataExport.CohortDescribing.CohortDescriptionFactory.Create">
            <summary>
            Starts 1 async fetch request for each cohort endpoint e.g. NormalCohorts ExternalCohortTable database contains 100 cohorts while FreakyCohorts ExternalCohortTable database
            has another 30. 
            
            <para>These async requests are managed by the CohortDescriptionDataTableAsyncFetch object which has a callback for compeltion.  Each ExtractableCohortDescription subscribes to
            the callback to self populate</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.CohortDescribing.ExtractableCohortDescription">
            <summary>
            Summary of all useful information about an ExtractableCohort including the number of unique patients and rowcount (can differ if there are aliases 
            for a patient - 2 private identifiers map to the same release identifier).
            
            <para>Depending on whether you are using an CohortDescriptionDataTableAsyncFetch some properties of this class may start out null/0 and become populated
            after the CohortDescriptionDataTableAsyncFetch completes.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.CohortDescribing.ExtractableCohortDescription.#ctor(Rdmp.Core.DataExport.Data.ExtractableCohort)">
            <summary>
            Creates a non async cohort description, this will block until counts are available for the cohort
            </summary>
            <param name="cohort"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.CohortDescribing.ExtractableCohortDescription.#ctor(Rdmp.Core.DataExport.Data.ExtractableCohort,Rdmp.Core.DataExport.CohortDescribing.CohortDescriptionDataTableAsyncFetch)">
            <summary>
            Creates a new description based on the async fetch request for all cohorts including row counts etc (which might have already completed btw).  If you
            use this constructor then the properties will start out with text like "Loading..." but it will perform much faster, when the fetch completes the 
            values will be populated.  In general if you want to use this feature you should probably use CohortDescriptionFactory and only use it if you are 
            trying to get all the cohorts at once.
             
            </summary>
            <param name="cohort"></param>
            <param name="fetch"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Audit.IReleaseLog">
            <summary>
            See ReleaseLogEntry
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Audit.ReleaseLog">
            <summary>
            Records the fact that a given extracted dataset has been released.  It audits the user performing the release, the environmental release potential,
            destination directory etc.
            
            <para>This is done by linking the CumulativeExtractionResult with a record in the ReleaseLog.  Each SelectedDataSet in an ExtractionConfiguration
            can only have 1 CumulativeExtractionResult at a time (it is a record of the last extracted SQL etc - See CumulativeExtractionResult) and there can be 
            only 1 ReleaseLog entry per CumulativeExtractionResult.  This means that once a dataset has been released it cannot be extracted/released again (this
            is intended behaviour).  If you want to re run a released ExtractionConfiguration then you should clone it.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Pipeline.BasicDataReleaseDestination">
            <summary>
            Default release pipeline destination implementation wraps Release Engine for the supplied ReleaseData.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Pipeline.FixedReleaseSource`1">
            <summary>
            Release pipeline must start with a Fixed Source that will run checks and prepare the source folder.
            Extraction Destinations will return an implementation of this class based on the extraction method used.
            </summary>
            <typeparam name="T">The type which is passed around in the pipeline</typeparam>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Pipeline.FlatFileReleaseSource`1">
            <summary>
            Prepares the Source Global Folder for the ReleaseEngine.
            </summary>
            <typeparam name="T">The ReleaseAudit object passed around in the pipeline</typeparam>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Pipeline.MsSqlReleaseSource`1">
            <summary>
            Prepares the Environment and the Source Database for the ReleaseEngine.
            </summary>
            <typeparam name="T">The ReleaseAudit object passed around in the pipeline</typeparam>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Pipeline.NullReleaseSource`1">
            <summary>
            To be used at design time only. Using this in runtime will generate Not Implemented Exceptions.
            </summary>
            <typeparam name="T">The ReleaseAudit object passed around in the pipeline</typeparam>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Pipeline.ReleaseAudit">
            <summary>
            Nothing to see here
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Pipeline.ReleaseData">
            <summary>
            Collection passed down the Release Pipeline.  Release is the process of taking extracted files for a Project, bundling them together into a release
            structure and sending that artifact to a release directory.  The Releasability of each dataset in the extraction is checked prior to release to confirm 
            that the extracted files match the current system configuration and that all expected files are there (See ReleasePotential).  In addition the ticketing
            system (if any) is consulted to confirm that it is happy for the collection to be released (See EnvironmentPotential)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Pipeline.ReleaseFolderProvider">
            <summary>
            Middle component for preparing the Release Folders for the Release Pipeline.
            Some destination components will complain if this is not present!
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Pipeline.ReleaseUseCase">
            <summary>
            Describes the use case in which a <see cref="N:Rdmp.Core.DataExport.DataRelease.Pipeline"/> takes artifacts produced as part of one or more <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/> for a <see cref="T:Rdmp.Core.DataExport.Data.Project"/>.  
            The artifacts may be CSV files, tables in an extraction database etc.  The artifacts should be gathered and sent to the recipient (e.g. zipped up and moved to FTP
            server / output folder).  
            
            <para>The configurations should be marked as released.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.DataRelease.Pipeline.ReleaseUseCase.#ctor">
            <summary>
            Design time constructor
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Potential.FlatFileGlobalsReleasePotential">
            <summary>
            Determines the releasability of global objects (e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/>) that should have been extracted as
            part of a project extraction.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Potential.FlatFileReleasePotential">
            <summary>
            Determines whether a given ExtractableDataSet in an ExtractionConfiguration, as generated by a Flat File extraction configuration is ready for Release. 
            This includes making sure that the current configuration
            in the database matches the extracted flat files that are destined for release.  It also checks that the user hasn't snuck some additional files into
            the extract directory etc.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Potential.MsSqlExtractionReleasePotential">
            <summary>
            Determines whether a given ExtractableDataSet in an ExtractionConfiguration, as generated by an Extracion To DB pipeline is ready for Release. 
            This includes making sure that the current configuration in the database matches the extracted tables that are destined for release.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Potential.MsSqlGlobalsReleasePotential">
            <summary>
            Determines the releasability of global objects (e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/>) that should have been extracted as
            part of a project extraction.  For <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable"/> it will confirm that the table exists in the database
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Potential.NoGlobalReleasePotential">
            <summary>
            Release potential for global objects (e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/>) that have never been recorded as extracted for a given extraction project 
            (i.e. no <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISupplementalExtractionResults"/> exists for them).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Potential.NoReleasePotential">
            <summary>
            Release Potential class to be used when nothing has ever been extracted
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.DataRelease.Potential.Releaseability.Undefined">
            <summary>
            Releasability has not yet been evaluated (i.e. null)
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.DataRelease.Potential.Releaseability.ExceptionOccurredWhileEvaluatingReleaseability">
            <summary>
            Something went wrong while RDMP was trying to determine the releasability of the dataset (figuring out if the files and current configuration match.)
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.DataRelease.Potential.Releaseability.NeverBeenSuccessfullyExecuted">
            <summary>
            The RDMP has no record of an extraction having taken place on the dataset (including a failed one)
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.DataRelease.Potential.Releaseability.ExtractFilesMissing">
            <summary>
            The RDMP has a record of the dataset being extracted but either the extracted data file or accompanying metadata file(s) was
            not found in the correct location on disk (either it was moved or the extraction crashed halfway through)
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.DataRelease.Potential.Releaseability.ExtractionSQLDesynchronisation">
            <summary>
            Because project extractions can take some time to do it is possible that another data analyst (or you without realising it) makes a change to a dataset
            in the project which has already been extracted (e.g. selecting an additional column for extraction).  If this happens your extracted file will be wrong
            (it no longer reflects the current configuration).  In such a situation you will see this icon.  To resolve this you must either rectify the configuration
            or re-extract the file.
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.DataRelease.Potential.Releaseability.CohortDesynchronisation">
            <summary>
            Similar to <see cref="F:Rdmp.Core.DataExport.DataRelease.Potential.Releaseability.ExtractionSQLDesynchronisation"/> except that the change to the configuration is to switch to a different cohort.  This is the worst 
            case scenario for release error where you supply a file to a researcher when the file doesn't even relate to the cohort he is asking for (or has ethics approval
            for).
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.DataRelease.Potential.Releaseability.ColumnDifferencesVsCatalogue">
            <summary>
            Considered only a warning.  You have changed the definition of columns for your extract (overridden the catalogue version of one or more columns - See 
            ConfigureDatasetUI for how to do this).  Alternatively this can occur if someone has edited the master Catalogue implementation of a transform which is part
            of your configuration (Configuration is outdated vs the catalogue).  You should evaluate the differences and make sure they are intended before doing a release.
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.DataRelease.Potential.Releaseability.Releaseable">
            <summary>
            The files extracted match expectations and can be released to the researcher
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.Potential.ReleasePotential">
            <summary>
            Determines whether a given ExtractableDataSet in an ExtractionConfiguration is ready for Release. 
            Extraction Destinations will return an implementation of this class which will run checks on the releasaility of the extracted datasets
            based on the extraction method used.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.DataRelease.Potential.ReleasePotential.SqlExtracted">
            <summary>
            The SQL that was run when the extraction was last performed (or null if no extraction has ever been performed)
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.DataRelease.Potential.ReleasePotential.SqlCurrentConfiguration">
            <summary>
            The SQL that would be generated if the configuration/dataset were executed today (if this differes from SqlExtracted then there is an Sql Desynchronisation)
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.DataRelease.Potential.ReleasePotential.ExtractDirectory">
            <summary>
            The directory that the extraction configuration last extracted data to (for this dataset).  This may no longer exist if people have been monkeying with the filesystem so check .Exists().  If no extraction has ever been made this will be NULL
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.DataRelease.Potential.ReleasePotential.ExtractFile">
            <summary>
            The file that contains the dataset data e.g. biochemistry.csv (will be null if no extract files were found)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.ReleaseEngine">
            <summary>
            Facilitates the release of anonymous project extracts to researchers including the generation of the release documents / Audit.  This typically involves
            collecting all the extracted files (csv data extracts, docx metadata documents, custom data files and supporting documents etc) and moving them into a single
            release directory followed by deleting all redundant extraction artifacts.
            
            <para>In order to DoRelease you will need to evaluate the environment and each ExtractionConfiguration to confirm they are in a releasable state (extracted files
            match current configuration, ticketing system says that the project has governance approval for release etc).  </para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.ReleaseEngineSettings">
            <summary>
            Options for configuring ReleaseEngine behaviour (To change where files are released to etc)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.ReleaseEnvironmentPotential">
            <summary>
            Evaluates things that are not within the control area of the DataExportManager but which might prevent a release e.g. ticketing system is not available
             / tickets in wrong status / safehaven down for maintencence etc.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.DataRelease.ReleaseFolderSettings">
            <summary>
            Options for configuring ReleaseEngine behaviour (To change where files are released to etc)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.CohortDefinition">
            <summary>
            This data class reflects a single row in a cohortDefinition table (see <see cref="T:Rdmp.Core.DataExport.Data.ExternalCohortTable"/>).  It may also reflect 
            one that does not exist yet in which case it will have a null ID (e.g. in the case where you are trying to create a new cohort 
            using an identifier list).
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CohortDefinition.ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CohortDefinition.Description">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CohortDefinition.Version">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CohortDefinition.ProjectNumber">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CohortDefinition.LocationOfCohort">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CohortDefinition.CohortReplacedIfAny">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CohortDefinition.#ctor(System.Nullable{System.Int32},System.String,System.Int32,System.Int32,Rdmp.Core.DataExport.Data.IExternalCohortTable)">
            <summary>
            Sets up a new row for inserting (or reporting) from an <see cref="T:Rdmp.Core.DataExport.Data.ExternalCohortTable"/>.
            </summary>
            <param name="id">The ID row read from the table (this is not an RDMP ID, it is an <see cref="P:Rdmp.Core.DataExport.Data.IExtractableCohort.OriginID"/>).  Pass null if you 
            are trying to insert a new row and expect the database to allocate the ID itself as an autonum</param>
            <param name="description">Unique string identifying the cohort, this should be the same for all cohorts that are versions of one another</param>
            <param name="version">The version number where there are multiple revisions to a cohort over time (these must share the same <paramref name="description"/>)</param>
            <param name="projectNumber">The <see cref="P:Rdmp.Core.DataExport.Data.IProject.ProjectNumber"/> that the cohort can be used with</param>
            <param name="locationOfCohort">The database where the row will be written to (or read from)</param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CohortDefinition.IsAcceptableAsNewCohort(System.String@)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CohortDefinition.ToString">
            <summary>
            Returns the <see cref="P:Rdmp.Core.DataExport.Data.CohortDefinition.Description"/>, <see cref="P:Rdmp.Core.DataExport.Data.CohortDefinition.Version"/> and <see cref="P:Rdmp.Core.DataExport.Data.CohortDefinition.ID"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.CumulativeExtractionResults">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.ExtractionConfiguration_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.ExtractableDataSet_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.DateOfExtraction">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.DestinationType">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.DestinationDescription">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.RecordsExtracted">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.DistinctReleaseIdentifiersEncountered">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.FiltersUsed">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.Exception">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.SQLExecuted">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.CohortExtracted">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.ExtractableDataSet">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.SupplementalExtractionResults">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.AddSupplementalExtractionResult(System.String,MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.IsFor(Rdmp.Core.DataExport.Data.ISelectedDataSets)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.#ctor(Rdmp.Core.Repositories.IDataExportRepository,Rdmp.Core.DataExport.Data.IExtractionConfiguration,Rdmp.Core.DataExport.Data.IExtractableDataSet,System.String)">
            <summary>
            Creates a new audit record in the data export database for describing an extraction attempt of the given <paramref name="dataset"/> in the 
            extraction <paramref name="configuration"/>.
            </summary>
            <param name="repository"></param>
            <param name="configuration"></param>
            <param name="dataset"></param>
            <param name="sql"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.Data.Common.DbDataReader)">
            <summary>
            Reads an existing audit record out of the data export database
            </summary>
            <param name="repository"></param>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.GetReleaseLogEntryIfAny">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.GetDestinationType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.IsReferenceTo(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.IsReferenceTo(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.CompleteAudit(System.Type,System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.ToString">
            <summary>
            Returns the name of the dataset for which this extraction is an audit of
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.InjectKnown(Rdmp.Core.DataExport.Data.IExtractableDataSet)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.CumulativeExtractionResults.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.DeployedExtractionFilter">
            <summary>
            Sometimes it is necessary to restrict which records are extracted for a given ExtractionConfiguration beyond the linkage against a cohort.  For example you might want to extract
            'only paracetamol prescriptions' for your cohort rather than the entire Prescribing dataset.  This is achieved by using a DeployedExtractionFilter.  DeployedExtractionFilters are
            curated pieces of WHERE SQL with a name and description.  These can either be written bespoke for your extract or copied from a master ExtractionFilter in the Catalogue database.
            In general if a filter concept is reusable and useful across multiple projects / over time then you should create it in the Catalogue database as an ExtractionFilter and then 
            import a copy into your ExtractionConfiguration each time you need it (or mark it as IsMandatory if it should always be used in data extraction of that Catalogue).
            
            <para>DeployedExtractionFilter differs from ExtractionFilter in that DeployedExtractionFilters are 'per Catalogue in an ExtractionConfiguration' while ExtractionFilters are master copies
            stored in the Catalogue database (instead of the DataExportManager database).  When you import a master filter into your ExtractionConfiguration a copy of the WHERE SQL, any 
            parameters and the name and description will be made as a DeployedExtractionFilter which will also contain a reference back to the original (ClonedFromExtractionFilter_ID).  This
            allows you to ensure consistency over time and gives you a central location (the ExtractionFilter) to fix errors in the Filter implementation etc.  </para>
            
            <para>When you open an DeployedExtractionFilter and it differs from the master (either because you have deliberately adjusted your copy or because the master has been updated to fix
            a problem) then you will be alerted via the Filter Checks. </para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.ClonedFromExtractionFilter_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.FilterContainer_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.ExtractionFilterParameters">
            <summary>
            Returns all parameters declared against this filter (does not include other parameters in scope e.g. globals)
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.FilterContainer">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.GetColumnInfoIfExists">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.GetFilterFactory">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.GetCatalogue">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.GetAllParameters">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.String,Rdmp.Core.DataExport.Data.FilterContainer)">
            <summary>
            Creates a new empty WHERE filter in the given <paramref name="container"/> that will be used when 
            extracting the dataset.
            
            <para>This object is created into the data export metadata database</para>
            </summary>
            <param name="repository"></param>
            <param name="name"></param>
            <param name="container"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.Data.Common.DbDataReader)">
            <summary>
            Read an existing WHERE filter out of the database
            </summary>
            <param name="repository"></param>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.ToString">
            <summary>
            Returns Name of filters
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks the filter is properly defined (e.g. not blank).
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.GetDataset">
            <summary>
            Returns the configuration and dataset (<see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/>) in which the filter is declared.  This involves traversing
            up any nested <see cref="P:Rdmp.Core.DataExport.Data.DeployedExtractionFilter.FilterContainer"/>s to the root.
            
            <para>Returns null if the filter is an orphan (not in a container or part of an orphan container tree)</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.DeployedExtractionFilterFactory">
            <summary>
             Constructs IFilters etc for data extraction via SelectedDataSets (See IFilterFactory).  Each SelectedDataSets in an ExtractionConfiguration has (optionally)
             it's own root container IFilters, subcontainers etc.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilterFactory.#ctor(Rdmp.Core.Repositories.IDataExportRepository)">
            <summary>
            Prepares to create extraction filters for project datasets int eh provided <paramref name="repository"/>
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilterFactory.CreateNewFilter(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilterFactory.CreateNewParameter(Rdmp.Core.CatalogueLibrary.Data.IFilter,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilterFactory.GetRootOwnerType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilterFactory.GetIContainerTypeIfAny">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter">
            <summary>
            Stores parameter values for a DeployedExtractionFilter
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.ExtractionFilter_ID">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionFilter"/> against which the parameter is declared.  The WHERE Sql of the filter should
            reference this parameter (e.g. "[mydb]..[mytbl].[hb_extract] = @healthboard").
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.ParameterSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.Value">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.Comment">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.ParameterName">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.String,Rdmp.Core.CatalogueLibrary.Data.IFilter)">
            <summary>
            Creates a new parameter in the metadata database.
            </summary>
            <param name="repository"></param>
            <param name="parameterSQL">Declaration SQL for the parameter e.g. "DECLARE @bob as varchar(10)"</param>
            <param name="parent"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.Data.Common.DbDataReader)">
            <summary>
            Reads an existing parameter out of the database
            </summary>
            <param name="repository"></param>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.ToString">
            <summary>
            returns the <see cref="P:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.ParameterName"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks the parameter syntax (See <see cref="T:Rdmp.Core.QueryBuilding.SyntaxChecking.ParameterSyntaxChecker"/>)
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.DeployedExtractionFilterParameter.GetOwnerIfAny">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ExternalCohortDefinitionData">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortDefinitionData.#ctor(System.Data.Common.DbDataReader,System.String)">
            <summary>
            Reads the externally held cohort descriptive data into memory from the <paramref name="r"/>
            </summary>
            <param name="r"></param>
            <param name="tableName"></param>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortDefinitionData.ExternalProjectNumber">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortDefinitionData.ExternalDescription">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortDefinitionData.ExternalVersion">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortDefinitionData.ExternalCohortTableName">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortDefinitionData.ExternalCohortCreationDate">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortDefinitionData.ObjectToNullableDateTime(System.Object)">
            <summary>
            Returns null for null or DBNull.Value otherwise the <see cref="T:System.DateTime"/> held in <paramref name="o"/>
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ExternalCohortTable">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.Name">
            <summary>
            Human readable name for the type of cohort which is stored in the database referenced by this object (e.g."CHI to Guid Cohorts")
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.DefinitionTableForeignKeyField">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.TableName">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.DefinitionTableName">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.PrivateIdentifierField">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.ReleaseIdentifierField">
            <inheritdoc/>
            <summary>
            When reading this, use GetReleaseIdentifier(ExtractableCohort cohort) where possible to respect cohort.OverrideReleaseIdentifierSQL
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.Data.ExternalCohortTable.CohortDefinitionTable_RequiredFields">
            <summary>
            Fields expected to be part of any table referenced by the <see cref="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.DefinitionTableName"/> property
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.ToString">
            <summary>
            Returns <see cref="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.Name"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.String,FAnsi.DatabaseType)">
            <summary>
            Creates a new blank pointer to a cohort database.
            </summary>
            <param name="repository">Metadata repository in which to create the object</param>
            <param name="name"></param>
            <param name="databaseType"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.Data.Common.DbDataReader)">
            <summary>
            Reads an existing cohort database reference out of the metadata repository database
            </summary>
            <param name="repository"></param>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.Discover">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks that the remote cohort storage database described by this class exists and contains a compatible schema.
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.IDExistsInCohortTable(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.PushToServer(Rdmp.Core.DataExport.Data.ICohortDefinition,FAnsi.Connections.IManagedConnection)">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.Password">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.GetDecryptedPassword">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.Username">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.Server">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.Database">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExternalCohortTable.DatabaseType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.GetCredentialsIfExists(ReusableLibraryCode.DataAccess.DataAccessContext)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.GetCountsDataTableSql">
            <summary>
            Returns SQL query for counting the number of unique patients in each cohort defined in the database
            referenced by this <see cref="T:Rdmp.Core.DataExport.Data.ExternalCohortTable"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.GetExternalDataSql">
            <summary>
            Returns SQL query for listing all cohorts stored in the database referenced by this <see cref="T:Rdmp.Core.DataExport.Data.ExternalCohortTable"/>.
            This includes only the ids, project numbers, version, description etc not the actual patient identifiers themselves.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.GetObjectsThisDependsOn">
            <summary>
            Returns nothing
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.GetObjectsDependingOnThis">
            <summary>
            Returns all cohorts in the source
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExternalCohortTable.IsFullyPopulated">
            <summary>
            returns true if all the relevant fields are populated (table names, column names etc)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ExtractableCohort">
            <inheritdoc/>
        </member>
        <member name="F:Rdmp.Core.DataExport.Data.ExtractableCohort.CohortLoggingTask">
            <summary>
            Logging entry in the RDMP central relational log under which to record all activities that relate to creating cohorts
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableCohort.ExternalCohortTable_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableCohort.OverrideReleaseIdentifierSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableCohort.AuditLog">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableCohort.OriginID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableCohort.IsDeprecated">
            <summary>
            True if the cohort has been replaced by another cohort or otherwise should not be used
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableCohort.Count">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableCohort.CountDistinct">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableCohort.ExternalCohortTable">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ExtractableCohort.ExternalCohortTable_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableCohort.Source">
            <summary>
            Alias field, returns <see cref="!:IExternalCohortTable.Name"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableCohort.ExternalProjectNumber">
            <summary>
            Fetches and returns the project number listed in the remote cohort database for this cohort (results are cached)
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableCohort.ExternalVersion">
            <summary>
            Fetches and returns the version number listed in the remote cohort database for this cohort (results are cached)
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetExternalData">
            <summary>
            Fetches and returns project number, version etc listed in the remote cohort database for this cohort
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.#ctor(Rdmp.Core.Repositories.IDataExportRepository,Rdmp.Core.DataExport.Data.ExternalCohortTable,System.Int32)">
            <summary>
            Creates a new cohort reference in the data export database.  This must resolve (via <paramref name="originalId"/>) to 
            a row in the external cohort database (<paramref name="externalSource"/>).
            </summary>
            <param name="repository"></param>
            <param name="externalSource"></param>
            <param name="originalId"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.ToString">
            <summary>
            Returns the external description of the cohort (held in the remote cohort database <see cref="P:Rdmp.Core.DataExport.Data.ExtractableCohort.ExternalCohortTable"/>) or
            "Broken Cohort" if that database is unreachable
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetSearchString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.FetchEntireCohort">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.WhereSQL">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetImportableCohortDefinitions(Rdmp.Core.DataExport.Data.ExternalCohortTable)">
            <summary>
            Returns details of all cohorts held in <paramref name="externalSource"/> (that have at least one identifier mapping).
            </summary>
            <param name="externalSource"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetImportableCohortDefinitionsTable(Rdmp.Core.DataExport.Data.ExternalCohortTable,System.String@,System.String@,System.String@,System.String@)">
            <summary>
            Returns the remote DataTable row held in <paramref name="externalSource"/> that describes all cohorts held in it (that have at least one identifier mapping).
            </summary>
            <param name="externalSource"></param>
            <param name="displayMemberName"></param>
            <param name="valueMemberName"></param>
            <param name="versionMemberName"></param>
            <param name="projectNumberMemberName"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetReleaseIdentifier(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetPrivateIdentifier(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetPrivateIdentifierDataType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetReleaseIdentifierDataType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetDatabaseServer">
            <inheritdoc/>
        </member>
        <member name="F:Rdmp.Core.DataExport.Data.ExtractableCohort._broken">
            <summary>
            Indicates whether the database described in ExternalCohortTable is unreachable or if the cohort has since been deleted etc.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.ReverseAnonymiseDataTable(System.Data.DataTable,ReusableLibraryCode.Progress.IDataLoadEventListener,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.AppendToAuditLog(System.String)">
            <summary>
            Appends the <paramref name="s"/> to the <see cref="P:Rdmp.Core.DataExport.Data.ExtractableCohort.AuditLog"/> prefixed by the DateTime and Username of the caller and then saves to database
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.InjectKnown(Rdmp.Core.DataExport.Data.IExternalCohortDefinitionData)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.InjectKnown(Rdmp.Core.DataExport.Data.ExternalCohortTable)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableCohort.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ExtractableColumn">
            <summary>
            Sometimes when extracting data in an ExtractionConfiguration of a Project you don't want to extract all the available (extractable) columns in a dataset.  For example you might
            have some columns which require 'special approval' to be released and most extracts will not include the columns.  ExtractableColumn is the object which records which columns in
            a given ExtractionConfiguration are being released to the researcher.  It also allows you to change the implementation of the column, for example a given researcher might want 
            all values UPPERd or he might want the Value field of Prescribing to be passed through his adjustment Scalar Valued Function to normalise or some other wierdness.
            
            <para>When selecting a column for extraction in ExtractionConfigurationUI an ExtractableColumn will be created with a pointer to the original ExtractionInformation 
            (CatalogueExtractionInformation_ID) in the Catalogue database.  The ExtractionInformations SelectSQL will also be copied out.  The ExtractionQueryBuilder will use these records to
            assemble the correct SQL for each Catalogue in your ExtractionConfiguration.</para>
            
            <para>The ExtractableColumn 'copy' process allows not only for you to modify the SelectSQL on a 'per extraction' basis but also it means that if you ever delete an ExtractionInformation
            from the Catalogue or change the implementation then the record in DataExportManager still reflects the values that were actually used to execute the extraction.  This means
            that if you clone a 10 year old extraction you will still get the same SQL (along with lots of warnings about orphan CatalogueExtractionInformation_ID etc).  It even allows you
            to delete entire datasets (Catalogues) without breaking old extractions (this is not a good idea though - you should always just deprecate the Catalogue instead).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableColumn.ExtractableDataSet_ID">
            <summary>
            The dataset to which this column belongs.  This is used with <see cref="P:Rdmp.Core.DataExport.Data.ExtractableColumn.ExtractionConfiguration_ID"/> to specify which dataset in which extraction 
            this line of SELECT sql is used.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableColumn.ExtractionConfiguration_ID">
            <summary>
            The configuration to which this column belongs.  This is used with <see cref="P:Rdmp.Core.DataExport.Data.ExtractableColumn.ExtractableDataSet_ID"/> to specify which dataset in which extraction 
            this line of SELECT sql is used.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableColumn.CatalogueExtractionInformation_ID">
            <summary>
            The original master column definition this object was cloned from.  When you add a dataset to an <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/> all the column
            definitions are copied to ensure the configuration is preserved going forwards.  This enables old extractions to be rerun regardless of changes in 
            the original dataset.  
            
            <para>May be null if the parent catalogue <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> has been deleted</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableColumn.CatalogueExtractionInformation">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ExtractableColumn.CatalogueExtractionInformation_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableColumn.ColumnInfo">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableColumn.#ctor(Rdmp.Core.Repositories.IDataExportRepository,Rdmp.Core.DataExport.Data.IExtractableDataSet,Rdmp.Core.DataExport.Data.ExtractionConfiguration,Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation,System.Int32,System.String)">
            <summary>
            Creates a new line of SELECT Sql for the given <paramref name="dataset"/> as it is extracted in the provided <paramref name="configuration"/>.  The new object will
            be created in the <paramref name="repository"/> database.
            </summary>
            <param name="repository"></param>
            <param name="dataset"></param>
            <param name="configuration"></param>
            <param name="extractionInformation"></param>
            <param name="order"></param>
            <param name="selectSQL"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableColumn.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.CatalogueItem)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableColumn.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableColumn.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableColumn.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableColumn.ToString">
            <summary>
            Returns the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.SelectSQL"/> or <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.Alias"/> of the column (if it has one)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableColumn.HasOriginalExtractionInformationVanished">
            <summary>
            Returns true if the underlying column (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/>) referenced by this class has disapeared since it's creation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableColumn.IsOutOfSync">
            <summary>
            Returns true if the current state of the ExtractableColumn is different from the current state of the original <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> that 
            it was cloned from.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableColumn.UpdateValuesToMatch(Rdmp.Core.QueryBuilding.IColumn)">
            <summary>
            Copies all values (SelectSQL, Order, IsPrimaryKey etc from the specified <see cref="T:Rdmp.Core.QueryBuilding.IColumn"/>) then saves to database.
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ExtractableDataSet">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableDataSet.Catalogue_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableDataSet.DisableExtraction">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableDataSet.Project_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableDataSet.ExtractionConfigurations">
            <summary>
            Returns all <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> in which this dataset is one of the extracted datasets
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableDataSet.Catalogue">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableDataSet.#ctor(Rdmp.Core.Repositories.IDataExportRepository,Rdmp.Core.CatalogueLibrary.Data.Catalogue,System.Boolean)">
            <summary>
            Defines that the given Catalogue is extractable to researchers as a data set, this is stored in the DataExport database
            </summary>
            <returns></returns>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableDataSet.IsCatalogueDeprecated">
            <summary>
            Returns true if the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ICatalogue"/> behind this dataset has been deleted or is marked <see cref="!:ICatalogue.IsDeprecated"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableDataSet.ToString">
            <summary>
            Returns the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ICatalogue"/> behind this dataset's Name or a string describing the object state if the Catalogue is unreachable.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableDataSet.DeleteInDatabase">
            <summary>
            Deletes the dataset, this will make the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ICatalogue"/> non extractable.  This operation fails if
            the dataset is part of any <see cref="P:Rdmp.Core.DataExport.Data.ExtractableDataSet.ExtractionConfigurations"/>.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableDataSet.GetCatalogueExtractabilityStatus">
            <summary>
            Returns an object indicating whether the dataset is project specific or not
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableDataSet.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.ICatalogue)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableDataSet.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage.Name">
            <summary>
            Name for the collection of datasets (e.g. 'Core Datasets').
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage.Creator">
            <summary>
            Environment.UserName of the person who created the <see cref="T:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage.CreationDate">
            <summary>
            When the <see cref="T:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage"/> was created
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.Data.Common.DbDataReader)">
            <summary>
            Reads an <see cref="T:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage"/> out of the data export database
            </summary>
            <param name="dataExportRepository"></param>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.String)">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage"/> in the data export database with the supplied <paramref name="name"/>
            </summary>
            <param name="dataExportRepository"></param>
            <param name="name"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage.ToString">
            <summary>
            Returns <see cref="P:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage.Name"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.CohortRefreshPipeline_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.CohortIdentificationConfiguration_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.DefaultPipeline_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.dtCreated">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.Cohort_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.RequestTicket">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.ReleaseTicket">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.Project_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.Username">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.Separator">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.Description">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.IsReleased">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.ClonedFrom_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.Project">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GlobalExtractionFilterParameters">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.CumulativeExtractionResults">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.SupplementalExtractionResults">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.Cohort">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.SelectedDataSets">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.ReleaseLog">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.DefaultPipeline">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.DefaultPipeline_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.CohortIdentificationConfiguration">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.CohortIdentificationConfiguration_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.CohortRefreshPipeline">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ExtractionConfiguration.CohortRefreshPipeline_ID"/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.#ctor(Rdmp.Core.Repositories.IDataExportRepository,Rdmp.Core.DataExport.Data.IProject)">
            <summary>
            Creates a new extraction configuration in the <paramref name="repository"/> database for the provided <paramref name="project"/>.
            </summary>
            <param name="repository"></param>
            <param name="project"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.Data.Common.DbDataReader)">
            <summary>
            Reads an existing <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> out of the  <paramref name="repository"/> database.
            </summary>
            <param name="repository"></param>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GetSearchString">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GetAllParameters">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.ToString">
            <summary>
            Returns the configuration Name
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.DeepCloneWithNewIDs">
            <summary>
            Creates a complete copy of the <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>, all selected datasets, filters etc.  The copy is created directly into
            the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity.Repository"/> database using a transaction (to prevent a half succesful clone being generated).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GetProject">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GetAllExtractableColumnsFor(Rdmp.Core.DataExport.Data.IExtractableDataSet)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GetFilterContainerFor(Rdmp.Core.DataExport.Data.IExtractableDataSet)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GetExtractableCohort">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GetAllExtractableDataSets">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.AddDatasetToConfiguration(Rdmp.Core.DataExport.Data.IExtractableDataSet)">
            <summary>
            Makes the provided <paramref name="extractableDataSet"/> extractable in the current <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>.  This
            includes selecting it (<see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/>) and replicating any mandatory filters.
            </summary>
            <param name="extractableDataSet"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.RemoveDatasetFromConfiguration(Rdmp.Core.DataExport.Data.IExtractableDataSet)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.AddColumnToExtraction(Rdmp.Core.DataExport.Data.IExtractableDataSet,Rdmp.Core.QueryBuilding.IColumn)">
            <summary>
            Makes the given <paramref name="column"/> SELECT Sql part of the query for linking and extracting the provided <paramref name="forDataSet"/>
            for this <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>.
            </summary>
            <param name="forDataSet"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GetExplicitLoggingDatabaseServerOrDefault">
            <summary>
            Returns the logging server that should be used to audit extraction executions of this <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.Unfreeze">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GetGlobals">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.DeleteInDatabase">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ExtractionConfiguration.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.FilterContainer">
            <summary>
            Sometimes you need to limit which records are extracted as part of an ExtractionConfiguration (See DeployedExtractionFilter).  In order to assemble valid WHERE SQL for this use
            case each DeployedExtractionFilter must be in either an AND or an OR container.  These FilterContainers ensure that each subcontainer / filter beyond the first is seperated by
            the appropriate operator (AND or OR) and brackets/tab indents where appropriate.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.FilterContainer.#ctor(Rdmp.Core.Repositories.IDataExportRepository,Rdmp.Core.CatalogueLibrary.Data.FilterContainerOperation)">
            <summary>
            Creates a new instance with the given <paramref name="operation"/>
            </summary>
            <param name="repository"></param>
            <param name="operation"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.FilterContainer.GetCatalogueIfAny">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.FilterContainer.ToString">
            <summary>
            Returns the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteContainer.Operation"/> "AND" or "OR"
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.FilterContainer.DeepCloneEntireTreeRecursivelyIncludingFilters">
            <summary>
            Creates a deep copy of the current container, all filters and subcontainers (recursively).  These objects will all have new IDs and be new objects
            in the repository database.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.FilterContainer.GetSelectedDataSetIfAny">
            <summary>
            If this container is a top level root container (as opposed to a subcontainer) this will return which <see cref="T:Rdmp.Core.DataExport.Data.SelectedDataSets"/> (which dataset in which configuration)
            in which it applies.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.FilterContainer.GetSelectedDataSetsRecursively">
            <summary>
            /// <summary>
            Return which <see cref="T:Rdmp.Core.DataExport.Data.SelectedDataSets"/> (which dataset in which configuration) this container resides in (or null if it is an orphan).  This
            involves multiple database queries as the container hierarchy is recursively traversed up.
            </summary>
            <returns></returns>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter">
            <summary>
            Sometimes you want to define global parameters that apply to an entire ExtractionConfiguration and all the Catalogues/ExtractableDataSets within it.  For example you might
            want to define @studyStartWindow and @studyEndWindow as global parameters which can be used to restrict the extraction window of each dataset.  GlobalExtractionFilterParameters
            are created and assocaited with a single ExtractionConfiguration after which they are available for use in all DeployedExtractionFilters of all datasets within the configuration.
            
            <para>It also means you have a single point you can change the parameter if you need to adjust it later on.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.ParameterName">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.ParameterSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.Value">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.Comment">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.ExtractionConfiguration_ID">
            <summary>
            Which <see cref="P:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.ExtractionConfiguration"/> the parameter is declared on.  This parameter will be available for referencing in any <see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/> which
            are part of the configuration.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.ExtractionConfiguration">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.ExtractionConfiguration_ID"/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.#ctor(Rdmp.Core.Repositories.IDataExportRepository,Rdmp.Core.DataExport.Data.ExtractionConfiguration,System.String)">
            <summary>
            Creates a new parameter into the <paramref name="repository"/> database acting as a global parameter for all <see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/> in the <paramref name="configuration"/>
            </summary>
            <param name="repository"></param>
            <param name="configuration"></param>
            <param name="parameterSQL"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.Data.Common.DbDataReader)">
            <summary>
            Reads an existing instance out of the database
            </summary>
            <param name="repository"></param>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.ToString">
            <summary>
            Returns <see cref="P:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.ParameterName"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.GetOwnerIfAny">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.InjectKnown(FAnsi.Discovery.QuerySyntax.IQuerySyntaxHelper)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.GlobalExtractionFilterParameter.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.HICProjectSalt">
            <summary>
            Provides the ProjectNumber as the salt for the data export hashing of columns (See ConfigureHashingAlgorithm)
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.HICProjectSalt.#ctor(Rdmp.Core.DataExport.Data.IProject)">
            <summary>
            Creates a hashing salt based on the given <paramref name="project"/>'s <see cref="P:Rdmp.Core.DataExport.Data.IProject.ProjectNumber"/>
            </summary>
            <param name="project"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.HICProjectSalt.GetSalt">
            <summary>
            Returns the <see cref="P:Rdmp.Core.DataExport.Data.IProject.ProjectNumber"/> (set during construction).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ICohortDefinition">
            <summary>
            See CohortDefinition
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICohortDefinition.ID">
            <summary>
            ID of the existing row in the <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.DefinitionTableName"/> or null if this object is trying
            to create a row that doesn't exist yet.  This ID will become <see cref="P:Rdmp.Core.DataExport.Data.IExtractableCohort.OriginID"/> when a reference
            is created in RDMP to the row.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICohortDefinition.Description">
            <summary>
            Value to store in or read from <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.DefinitionTableName"/> 
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICohortDefinition.Version">
            <summary>
            Version number to store in or read from <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.DefinitionTableName"/> 
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICohortDefinition.ProjectNumber">
            <summary>
            Project number to store in or read from <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.DefinitionTableName"/>.  This must match
            any <see cref="P:Rdmp.Core.DataExport.Data.IProject.ProjectNumber"/> that the cohort is to be used with.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICohortDefinition.LocationOfCohort">
            <summary>
            Reference to the remote cohort database in which the row should be saved/read from.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICohortDefinition.CohortReplacedIfAny">
            <summary>
            The cohort replaced if uploading a new version
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ICohortDefinition.IsAcceptableAsNewCohort(System.String@)">
            <summary>
            Returns true if the row described by this class would be novel in the destination database (See <see cref="P:Rdmp.Core.DataExport.Data.ICohortDefinition.LocationOfCohort"/>).
            
            <para>Returns false if the name/description/version look like the user is trying to upload an older version or duplicate name etc</para>
            </summary>
            <param name="matchDescription"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults">
            <summary>
            Data Export Manager keeps a record of the final SQL generated/used to perform an extraction of any ExtractionConfiguration in records called CumulativeExtractionResults.
            These records include the SQL executed, the date, the filters, the number of records extracted etc.  This is in addition to the information logged in the Logging database.
            This record is overwritten if you re-extract the ExtractionConfiguration again.  The record is used to ensure that you cannot release an extract if there have been changes
            to the configuration subsequent to your last extraction.  This is particularly useful if you have many large datasets that you are extracting over a long period of time either
            because they are very large, have complex filters or are liable to crash on a semi regular basis.  Under such circumstances you can extract half of your datasets one day and 
            then adjust the others to correct issues and be confident that the system is tracking those changes to ensure that the current state of the system always matches the extracted
            files at release time.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults.ExtractionConfiguration_ID">
            <summary>
            This class is the audit of a the latest extraction attempt of a given dataset in a given extraction configuration.  
            
            <para>This property is the ID of the <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> being audited</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults.ExtractableDataSet_ID">
            <summary>
            This class is the audit of a the latest extraction attempt of a given dataset in a given extraction configuration.  
            
            <para>This property is the ID of the <see cref="T:Rdmp.Core.DataExport.Data.IExtractableDataSet"/> being audited</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults.DistinctReleaseIdentifiersEncountered">
            <summary>
            Count of the number of unique anonymous release identifiers encountered during extraction.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults.FiltersUsed">
            <summary>
            Description of all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> that existed on the dataset that was extracted (e.g. "Extract only Tayside records").
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults.CohortExtracted">
            <summary>
            The ID of the <see cref="T:Rdmp.Core.DataExport.Data.IExtractableCohort"/> that was linked against the dataset during extraction.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults.ExtractableDataSet">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults.ExtractableDataSet_ID"/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults.GetReleaseLogEntryIfAny">
            <summary>
            If the extracted artifacts have been packaged up and released then this method returns the audit object for that release.
            </summary>
            <returns>Release audit or null if artifacts have not been released</returns>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults.SupplementalExtractionResults">
            <summary>
            If there are supplemental artifacts produced during extraction (e.g. lookup tables) then this method returns the audit object(s) for these
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults.AddSupplementalExtractionResult(System.String,MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Records the fact that a given supplemental artifact has been produced by the extraction process (e.g. a lookup table) 
            </summary>
            <param name="sqlExecuted"></param>
            <param name="extractedObject"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ICumulativeExtractionResults.IsFor(Rdmp.Core.DataExport.Data.ISelectedDataSets)">
            <summary>
            Returns true if the audit described by this class is for the given <see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/>
            </summary>
            <param name="selectedDataSet"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.IExternalCohortDefinitionData">
            <summary>
            Information that is not held in RDMP about an ExtractableCohort but which must be fetched at runtime from the cohort database (ExternalCohortTable)
            
            <para>Because RDMP is designed to support a wide range of cohort/release identifier allocation systems,  it takes a very hands-off approach to cohort tables. 
            Things like Cohort Version, Description and even ProjectNumber are not imported into RDMP because they may be part of an existing cohort management system
            and thus cannot be moved (creating cached/synchronized copies would just be a further pain).  </para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExternalCohortDefinitionData.ExternalProjectNumber">
            <summary>
            The <see cref="P:Rdmp.Core.DataExport.Data.IProject.ProjectNumber"/> stored in the remote definition table for this cohort.  This restricts which
            <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> the cohort can be used with.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExternalCohortDefinitionData.ExternalDescription">
            <summary>
            The human readable description (name) of the cohort held in the remote definition table for this cohort.  This must be the 
            same for all cohorts which are versions  of one another (See <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortDefinitionData.ExternalVersion"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExternalCohortDefinitionData.ExternalVersion">
            <summary>
            The externally held version number for the cohort.  When combined with <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortDefinitionData.ExternalDescription"/> allows you to 
            identify whether there are newer versions of the cohort available.  All cohorts in the same 'version set' must have the 
            same <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortDefinitionData.ExternalDescription"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExternalCohortDefinitionData.ExternalCohortTableName">
            <summary>
            The remote table from which the cohort information was fetched
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExternalCohortDefinitionData.ExternalCohortCreationDate">
            <summary>
            The date (if known) on which the cohort was created (in the remote cohort database)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.IExternalCohortTable">
            <summary>
            Since every agency handles cohort management differently the RDMP is built to supports diverse cohort source schemas.  Unlike the logging, dqe, catalogue databases etc there
            is no fixed managed schema for cohort databases.  Instead you simply have to tell the software where to find your patient identifiers in an ExternalCohortTable record.  This
            stores:
            
            <para>What table contains your cohort identifiers
            Which column is the private identifier
            Which column is the release identifier</para>
            
            <para>In addition to this you must have a table which describes your cohorts which must have columns called id, projectNumber, description, version and dtCreated.  And you must
            have a table which stores custom data for the cohort with a column customTableName containing the names of any data that accompanies cohorts.</para>
            
            <para>Both the cohort and custom table names table must have a foreign key into the definition table.  </para>
            
            <para>You are free to add additional columns to these tables or even base them on views of other existing tables in your database.  You can have multiple ExternalCohortTable sources
            in your database for example if you need to support different identifier datatypes / formats.</para>
            
            <para>If all this sounds too complicated you can use the CreateNewCohortDatabaseWizardUI to automatically generate a database that is compatible with the format requirements and has
            release identifiers assigned automatically either as autonums or GUIDs (I suggest using GUIDs to prevent accidental crosstalk from ever occuring if you handle magic numbers from
            other agencies). </para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.TableName">
            <summary>
            Name of the table in your database that contains the private to release identifier mappings (e.g. 'Cohort').
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.DefinitionTableName">
            <summary>
            Name of the inventory table in your database which records the names and versions of cohorts stored in the cohort table (e.g. 'CohortDefinition').
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.PrivateIdentifierField">
            <summary>
            The column in the cohort table which contains private identifiers (e.g. 'chi').  This column must contain identifiers in the same format 
            as the datasets you want to link with when performing project extractions.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.ReleaseIdentifierField">
            <summary>
            The column in the cohort table which contains release identifiers (e.g. 'ReleaseId).  These are the values that will be substituted in during
            the linkage stage of project extractions.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.DefinitionTableForeignKeyField">
            <summary>
            The name of the field in the cohort (mapping) table which is a foreign key into <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.DefinitionTableName"/> (cohort descriptions) table (e.g. cohortDefinition_id).
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExternalCohortTable.Discover">
            <summary>
            Returns an object for connecting to/interacting with the cohort database referenced by this object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExternalCohortTable.PushToServer(Rdmp.Core.DataExport.Data.ICohortDefinition,FAnsi.Connections.IManagedConnection)">
            <summary>
            Creates a new record in the <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.DefinitionTableName"/> table referenced by this object.
            </summary>
            <param name="newCohortDefinition"></param>
            <param name="connection"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExternalCohortTable.IDExistsInCohortTable(System.Int32)">
            <summary>
            Connects to the cohort database and looks for a cohort definition record with the given <paramref name="originID"/>.  Returns
            true if a record exists.
            </summary>
            <param name="originID"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.IExtractableCohort">
            <summary>
            While actual patient identifiers are stored in an external database (referenced by a ExternalCohortTable), the RDMP still needs to have a reference to each cohort for extaction.
            The ExtractableCohort object is a record that documents the location and ID of a cohort in your ExternalCohortTable.  This record means that the RDMP can record which cohorts
            are part of which ExtractionConfiguration in a Project without ever having to move the identifiers into the RDMP application database.
            
            <para>The most important field in ExtractableCohort is the OriginID, this field represents the id of the cohort in the CohortDefinition table of the ExternalCohortTable.  Effectively
            this number is the id of the cohort in your cohort database while the ID property of the ExtractableCohort (as opposed to OriginID) is the RDMP ID assigned to the cohort.  This
            allows you to have two different cohort sources both of which have a cohort id 10 but the RDMP software is able to tell the difference.  In addition it allows for the unfortunate
            situation in which you delete a cohort in your cohort database and leave the ExtractableCohort orphaned - under such circumstances you will at least still have your RDMP configuration
            and know the location of the original cohort even if it doesn't exist anymore. </para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractableCohort.Count">
            <summary>
            Runs a (non distinct) count on the number of rows in the private/release identifier mapping table 
            stored in the <see cref="P:Rdmp.Core.DataExport.Data.IExtractableCohort.ExternalCohortTable"/> which match this cohorts <see cref="P:Rdmp.Core.DataExport.Data.IExtractableCohort.OriginID"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractableCohort.CountDistinct">
            <summary>
            Runs a count distinct on the release identifier column of the cohort.  Result is
            cached in memory for subsequent calls.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractableCohort.ExternalCohortTable_ID">
            <summary>
            The location of the cohort database in which this cohort is held (outside RDMP metadata databases).
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractableCohort.OriginID">
            <summary>
            The id of the row in the remote <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.DefinitionTableName"/> that stores a description
            of what is in this cohort (See <see cref="T:Rdmp.Core.DataExport.Data.IExternalCohortDefinitionData"/>).
             
            <para>Because you can have multiple cohort databases managed by RDMP, it is possible for 2+ different <see cref="T:Rdmp.Core.DataExport.Data.IExtractableCohort"/>
            to have the same <see cref="P:Rdmp.Core.DataExport.Data.IExtractableCohort.OriginID"/> (i.e. cohort 1 from source 1 is not the same as cohort 1 from source 2).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractableCohort.OverrideReleaseIdentifierSQL">
            <summary>
            Allows you to override the release identifier column setting in <see cref="T:Rdmp.Core.DataExport.Data.IExternalCohortTable"/> when extracting this specific
            cohort list.  Use this only if your mapping table has multiple different types of release identifier (stored in seperate columns).
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractableCohort.AuditLog">
            <summary>
            Log of activities relating to this cohort e.g. what it was created from (e.g. a CohortIdentificationConfiguration, file etc).  This
            field is held in RDMP database (i.e. not fetched from the remote cohort database - <see cref="P:Rdmp.Core.DataExport.Data.IExtractableCohort.ExternalCohortTable"/>).
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractableCohort.ExternalCohortTable">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.IExtractableCohort.ExternalCohortTable_ID"/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractableCohort.FetchEntireCohort">
            <summary>
            Fetches all mappings (private to release identifier) for the cohort (also returns any other columns in the <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.TableName"/>)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractableCohort.GetPrivateIdentifier(System.Boolean)">
            <summary>
            Returns the name of the identifiable private identifier column e.g. "chi".
            </summary>
            <param name="runtimeName">True to return just the name e.g. "chi".  False to return the fully qualified name e.g. "[mydb]..[mytbl].[chi]"</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractableCohort.GetReleaseIdentifier(System.Boolean)">
            <summary>
            Returns the name of the anonymous release identifier column e.g. "ReleaseId".
            </summary>
            <param name="runtimeName">True to return just the name e.g. "ReleaseId".  False to return the fully qualified name e.g. "[mydb]..[mytbl].[ReleaseId]"</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractableCohort.WhereSQL">
            <summary>
            Returns boolean logic for WHERE Sql that will restrict records fetched from <see cref="P:Rdmp.Core.DataExport.Data.IExternalCohortTable.TableName"/> to only those in the current <see cref="T:Rdmp.Core.DataExport.Data.IExtractableCohort"/>
            (by <see cref="P:Rdmp.Core.DataExport.Data.IExtractableCohort.OriginID"/>).
            
            <para>Sql returned does not include the prefix WHERE</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractableCohort.GetExternalData">
            <summary>
            Returns information stored in your cohort database (pointed to by <see cref="T:Rdmp.Core.DataExport.Data.IExternalCohortTable"/>) for the cohort.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractableCohort.GetPrivateIdentifierDataType">
            <summary>
            Returns the data type of the identifiable column (e.g. "varchar(10)")
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractableCohort.GetReleaseIdentifierDataType">
            <summary>
            Returns the data type of the anonymous release identifier column (e.g. "varchar(300)")
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractableCohort.GetDatabaseServer">
            <summary>
            Returns an object for connecting to/interacting with the cohort database in which this cohort's identifiers are stored.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractableCohort.ReverseAnonymiseDataTable(System.Data.DataTable,ReusableLibraryCode.Progress.IDataLoadEventListener,System.Boolean)">
            <summary>
            Looks in <paramref name="toProcess"/> for a column called <see cref="M:Rdmp.Core.DataExport.Data.IExtractableCohort.GetReleaseIdentifier(System.Boolean)"/> and swaps identifiers
            found in that column with the corresponding private identifier.  After replacing all the release identifiers
            the column will be renamed <see cref="M:Rdmp.Core.DataExport.Data.IExtractableCohort.GetPrivateIdentifier(System.Boolean)"/>
            </summary>
            <param name="toProcess"></param>
            <param name="listener"></param>
            <param name="allowCaching"></param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.IExtractableDataSet">
            <summary>
            While the Catalogue Manager database includes support for marking which columns in which Catalogues are extractable (via ExtractionInformation) we need an additional layer
            in the Data Export Manager database.  This layer is the ExtractableDataSet object.  An ExtractableDataSet is 'the permission to perform extractions of a given Catalogue'.  We
            have this second layer for two main reasons.  The first is so that there is no cross database referential integrity problem for example if you delete a Catalogue 5 years after
            performing an extract we can still report to the user the facts in a graceful manner if they clone the old configuration.  The second reason is that you could (if you were crazy)
            have multiple DataExportManager databases all feeding off the same Catalogue database - e.g. one that does identifiable extracts and one which does anonymous extracts.  Some
            datasets (Catalogues) would therefore be extractable in one DataExportManager database while a different set would be extractable in the other DataExportManager database.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractableDataSet.Catalogue_ID">
            <summary>
            The <see cref="P:Rdmp.Core.DataExport.Data.IExtractableDataSet.Catalogue"/> (dataset) which this object allows the extraction of.  The Catalogue object will exist in
            the <see cref="T:Rdmp.Core.Repositories.ICatalogueRepository"/> database (while the <see cref="T:Rdmp.Core.DataExport.Data.IExtractableDataSet"/> exists in the <see cref="T:Rdmp.Core.Repositories.IDataExportRepository"/>).
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractableDataSet.DisableExtraction">
            <summary>
            True to temporarily disable extractions of the dataset.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractableDataSet.Catalogue">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.IExtractableDataSet.Catalogue_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractableDataSet.Project_ID">
            <summary>
            Indicates that the referenced <see cref="P:Rdmp.Core.DataExport.Data.IExtractableDataSet.Catalogue_ID"/> is associated only with one <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> and should not be used outside of that.
            
            <para>Usually this means the data is bespoke project data e.g. questionnaire answers for a cohort etc.  These data tables are treated exactly like regular Catalogues and 
            extracted in the same way as all the regular data.</para>
            
            <para>In addition, you can use the columns in the referenced <see cref="P:Rdmp.Core.DataExport.Data.IExtractableDataSet.Catalogue_ID"/> by joining them to any regular Catalogue being extracted in the Project.  These
            selected columns will be bolted on as additional columns.  You can also reference them in the WhereSQL of filters which will trigger an similar Join>.</para>
            
            <para>For example imagine you have a custom data set which is 'Patient ID,Date Consented' then you could configure an extraction filters that only extracted records from
             Prescribing, Demography, Biochemistry catalogues AFTER each patients consent date.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration">
            <summary>
            Represents a collection of datasets (Catalogues), ExtractableColumns, ExtractionFilters etc and a single ExtractableCohort for a Project.  You can have multiple active
            ExtractionConfigurations at a time for example a Project might have two cohorts 'Cases' and 'Controls' and you would have two ExtractionConfiguration possibly containing
            the same datasets and filters but with different cohorts.
            
            <para>Once you have executed, extracted and released an ExtractionConfiguration then it becomes 'frozen' IsReleased and it is not possible to edit it (unless you unfreeze it 
            directly in the database).  This is intended to ensure that once data has gone out the door the configuration that generated the data is immutable.</para>
            
            <para>If you need to perform a repeat extraction (e.g. an update of data 5 years on) then you should 'Clone' the ExtractionConfiguration in the Project and give it a new name 
            e.g. 'Cases - 5 year update'.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.dtCreated">
            <summary>
            When the configuration was created
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Cohort_ID">
            <summary>
            The cohort that will be linked with datasets in the configuration to produce anonymous data extracts.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.RequestTicket">
            <summary>
            Optional - Ticket in an <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/> (e.g. JIRA) which can be used to record project documents, requirements, governance etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.ReleaseTicket">
            <summary>
            Optional - Ticket in an <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/> (e.g. JIRA) which can be used to record project documents, requirements, governance etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Project_ID">
            <summary>
            The <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> to which this configuration belongs.  A project can have multiple configurations (e.g. "Cases" and "Controls").  You can also
            have mutliple configurations over time in the project (e.g. quarterly data refreshes).
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Project">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Project_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Username">
            <summary>
            The username of the data analyst who originally created this configuration
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Separator">
            <summary>
            The file separator that should be used when extracting this dataset to a delimited flat file destination.  Ignore if extracting to database, excel etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Description">
            <summary>
            User provided description of what the extraction represents, any filters etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.IsReleased">
            <summary>
            True if the configuration has been succesfully extracted and the artifacts have been released to the end researchers.  When true the configuration
            should be treated as immutable.  If the user wants to make further changes the recommended course of action is to clone a new copy of it.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.ClonedFrom_ID">
            <summary>
            If the <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> was cloned from another configuration this will store the ID of the original
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Cohort">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Cohort_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.DefaultPipeline_ID">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline"/> which should be used to extract the linked datasets unless the user specifies a specific alternative.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.CohortIdentificationConfiguration_ID">
            <summary>
            If the <see cref="T:Rdmp.Core.DataExport.Data.IExtractableCohort"/> for this configuration was created by an RDMP cohort query (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/>)
            then this ID can be set to provide a link back.
            
            <para>This field is also used for 'Cohort Refresh' in which a cohort list is updated to match the new state of the query/live clinical database</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.CohortRefreshPipeline_ID">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline"/> which should be executed during 'Cohort Refresh' in order to turn the query 
            (<see cref="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.CohortIdentificationConfiguration_ID"/>) into an <see cref="T:Rdmp.Core.DataExport.Data.IExtractableCohort"/>.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractionConfiguration.GetExtractableCohort">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Cohort_ID"/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractionConfiguration.GetProject">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Project_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.GlobalExtractionFilterParameters">
            <summary>
            Returns all global <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> which can be used in WHERE filters of <see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/> being extracted in this 
            <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>.  This helps avoid replication of values e.g. record extraction window start/end.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.ReleaseLog">
            <summary>
            If the extracted artifacts for this configuration have been released (See <see cref="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.IsReleased"/>) then this will return all the
            audit objects describing that process.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.CumulativeExtractionResults">
            <summary>
            If the user (or an automated system) has attempted to extract any datasets in this <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> then this will
            return all the audit objects describing that extraction.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.SupplementalExtractionResults">
            <summary>
            If the user (or an automated system) has attempted to extract any datasets with supplemental artifacts (e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/>)
            then this will return all the audit objects describing that extraction.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractionConfiguration.GetAllExtractableColumnsFor(Rdmp.Core.DataExport.Data.IExtractableDataSet)">
            <summary>
            Returns all the columns that have been selected for linkage and extraction in the given <paramref name="dataset"/> as it exists in this <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>
            </summary>
            <param name="dataset"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractionConfiguration.GetFilterContainerFor(Rdmp.Core.DataExport.Data.IExtractableDataSet)">
            <summary>
            Returns the root AND/OR container (if any) that provides WHERE logic to restrict which records are extracted
             in the  given <paramref name="dataset"/> as it exists in this <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>.
            
            <para>This does not include the cohort linkage logic (join) which further reduces records extracted</para>
            </summary>
            <param name="dataset"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractionConfiguration.GetAllExtractableDataSets">
            <summary>
            Returns all <see cref="T:Rdmp.Core.DataExport.Data.IExtractableDataSet"/> which have been selected for linkage and extraction in this <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.SelectedDataSets">
            <summary>
            Returns all <see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/> which have been selected for linkage and extraction in this <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>
            
            <para><see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/> is the link object between the dataset and the configuration</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractionConfiguration.RemoveDatasetFromConfiguration(Rdmp.Core.DataExport.Data.IExtractableDataSet)">
            <summary>
            Deletes the <see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/> which records the fact that the given <paramref name="extractableDataSet"/> should be extracted in
            this <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> (removes the dataset from the extraction).
            </summary>
            <param name="extractableDataSet"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractionConfiguration.Unfreeze">
            <summary>
            Clears the <see cref="P:Rdmp.Core.DataExport.Data.IExtractionConfiguration.IsReleased"/> status of the <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> and deletes any audit objects that would prevent
            re-extraction.  This is not the recommended way of changing a released configuration, instead it is advised that you clone the configuration
            to preserve the extraction history.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IExtractionConfiguration.GetGlobals">
            <summary>
            Returns all supplemental artifacts (e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/>) marked IsGlobal which should be extracted whenever the <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>
            is run.  This can include disclaimers, general purpose help materials etc.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.IHICProjectSalt">
            <summary>
            Provides the salt which will be passed for use by the Hashing algorithm in data extraction  (See ConfigureHashingAlgorithm). 
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IHICProjectSalt.GetSalt">
            <summary>
            Returns a salt for hashing.  If you want reproducible extraction outputs then this should be based on an attribute of 
            the <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> being extracted (or the <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/>).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.IProject">
            <summary>
            See Project
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IProject.MasterTicket">
            <summary>
            Optional ticket identifier for auditing time, project requirements etc.  Should be compatible with your currently configured <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IProject.ExtractionDirectory">
            <summary>
            Location on disk that the extracted artifacts for the project (csv files , <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/> etc) are put in.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IProject.ProjectNumber">
            <summary>
            The number you want to associate with Project, a Project is not in a legal state if it doesn't have one (you can't upload cohorts, do extradctions etc).
            You can have multiple <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> with the same number (in which case they will have shared access to the same cohorts, anonymisation mappings etc).
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IProject.ExtractionConfigurations">
            <summary>
            A <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> can have multiple <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> defined (e.g. Cases / Controls or multiple extractions over time).  This
            returns all current and frozen (released) configurations.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IProject.ProjectCohortIdentificationConfigurationAssociations">
            <summary>
            Returns all association links to <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> (cohort queries that are associated with the project).  These are 
            association objects not the actual configuration itself.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.IProject.DataExportRepository">
            <summary>
            The database in which the object is persisted
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IProject.GetAllProjectCatalogues">
            <summary>
            Returns all datasets which are selected in any <see cref="P:Rdmp.Core.DataExport.Data.IProject.ExtractionConfigurations"/> in the project
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.IProject.GetAllProjectCatalogueColumns(Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory)">
            <summary>
            Returns all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> in all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> which are marked as project specific (for this <see cref="T:Rdmp.Core.DataExport.Data.IProject"/>)
            </summary>
            <param name="any"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ISelectedDataSets">
            <summary>
            Usually when creating an ExtractionConfiguration you do not want to extract all the datasets (Catalogues).  SelectedDataSets represents the desire to extract a
            given dataset for a given ExtractableDataSet for a given ExtractionConfiguration.  
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.ExtractionConfiguration_ID">
            <summary>
            <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> in which the <see cref="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.ExtractableDataSet_ID"/> is selected
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.ExtractableDataSet_ID">
            <summary>
            <see cref="T:Rdmp.Core.DataExport.Data.IExtractableDataSet"/> that has been selected for extraction in the <see cref="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.ExtractionConfiguration_ID"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.RootFilterContainer_ID">
            <summary>
            The root AND/OR container which provides WHERE logic that should be included in the query when extracting the <see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.RootFilterContainer">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.RootFilterContainer_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.ExtractionConfiguration">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.ExtractionConfiguration_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.ExtractableDataSet">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.ExtractableDataSet_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ISelectedDataSets.SelectedDataSetsForcedJoins">
            <summary>
            Returns all tables which should be force joined against when extracting the <see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/> (regardless of extracted columns).
            This does not include implicitly joined <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ITableInfo"/> (i.e. if you are extracting a column from that table).
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ISelectedDataSets.GetCumulativeExtractionResultsIfAny">
            <summary>
            If this dataset has been extracted in the past this will return the last extract audit record.  Otherwise it will return null
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ISelectedDataSetsForcedJoin">
            <summary>
            Specifies that the given data export dataset in configuration x (SelectedDataSets) should include a mandatory join on the table TableInfo regardless of 
            what columns are selected in the extraction query.  The most common use case for this is to extract a dataset with WhereSQL that references a custom data
            table e.g. 'Questionnaire answer x > 5'.  In that scenario the <see cref="P:Rdmp.Core.DataExport.Data.ISelectedDataSetsForcedJoin.TableInfo"/> would be the 'Project Specific Catalogue' dataset 'Questionnaire'
            and the <see cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/> would be the dataset you were extracting in your study e.g. 'biochemistry'.
            
            <para>A <see cref="T:Rdmp.Core.CatalogueLibrary.Data.JoinInfo"/> must still exist to tell <see cref="!:CatalogueLibrary.QueryBuilding.QueryBuilder"/> how to write the Join section of the query.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ISelectedDataSetsForcedJoin.SelectedDataSets_ID">
            <summary>
            The dataset in an <see cref="T:Rdmp.Core.DataExport.Data.IExtractionConfiguration"/> which should always be joined against the refered <see cref="P:Rdmp.Core.DataExport.Data.ISelectedDataSetsForcedJoin.TableInfo_ID"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ISelectedDataSetsForcedJoin.TableInfo_ID">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ITableInfo"/> which should always be joined with when extracting the given <see cref="P:Rdmp.Core.DataExport.Data.ISelectedDataSetsForcedJoin.SelectedDataSets_ID"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ISelectedDataSetsForcedJoin.TableInfo">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ISelectedDataSetsForcedJoin.TableInfo_ID"/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.Project">
            <summary>
            All extractions through DataExportManager must be done through Projects.  A Project has a name, extraction directory and optionally Tickets (if you have a ticketing system 
            configured).  A Project should never be deleted even after all ExtractionConfigurations have been executed as it serves as an audit and a cloning point if you 
            ever need to clone any of the ExtractionConfigurations (e.g. to do an update of project data 5 years on).
            
            <para>The ProjectNumber must match the project number of the cohorts in your cohort database.  Therefore it is not possible to share a single cohort between multiple Projects. </para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.Project.Name">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.Project.MasterTicket">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.Project.ExtractionDirectory">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.Project.ProjectNumber">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.Project.ExtractionConfigurations">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.Project.ProjectCohortIdentificationConfigurationAssociations">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.Project.#ctor(Rdmp.Core.Repositories.IDataExportRepository,System.String)">
            <summary>
            Defines a new extraction project this is stored in the Data Export database
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.Project.ToString">
            <summary>
            Returns <see cref="P:Rdmp.Core.DataExport.Data.Project.Name"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.Project.GetSearchString">
            <summary>
            Returns <see cref="P:Rdmp.Core.DataExport.Data.Project.ProjectNumber"/> (if any), <see cref="P:Rdmp.Core.DataExport.Data.Project.Name"/> and <see cref="P:Rdmp.Core.DataExport.Data.Project.MasterTicket"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.Project.GetAssociatedCohortIdentificationConfigurations">
            <summary>
            Returns all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> which are associated with the <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> (usually because
            they have been used to create <see cref="T:Rdmp.Core.DataExport.Data.ExtractableCohort"/> used by the <see cref="T:Rdmp.Core.DataExport.Data.IProject"/>).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.Project.AssociateWithCohortIdentification(Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration)">
            <summary>
            Associates the <paramref name="cic"/> with the <see cref="T:Rdmp.Core.DataExport.Data.IProject"/>.  This is usually done after generating an <see cref="T:Rdmp.Core.DataExport.Data.IExtractableCohort"/>.
            You can associate a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> with multiple <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> (M to M relationship).
            </summary>
            <param name="cic"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.Project.GetAllProjectCatalogues">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.Project.GetAllProjectCatalogueColumns(Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.Project.GetObjectsThisDependsOn">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.Project.GetObjectsDependingOnThis">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.Project_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.CohortIdentificationConfiguration_ID">
            <summary>
            The <see cref="P:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.CohortIdentificationConfiguration"/> which is associated with the given <see cref="P:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.Project_ID"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.Project">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.Project_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.CohortIdentificationConfiguration">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.CohortIdentificationConfiguration_ID"/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.#ctor(Rdmp.Core.Repositories.IDataExportRepository,Rdmp.Core.DataExport.Data.Project,Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration)">
            <summary>
            Declares in the <paramref name="repository"/> database that the given <paramref name="cic"/> cohort query is associated with the supplied <paramref name="project"/>.
            This is usually done after using the query to build an <see cref="T:Rdmp.Core.DataExport.Data.IExtractableCohort"/> (But it can be done manually by the user too).
            </summary>
            <param name="repository"></param>
            <param name="project"></param>
            <param name="cic"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.ToString">
            <summary>
            Returns the associated <see cref="P:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.CohortIdentificationConfiguration_ID"/> Name
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.GetDeleteMessage">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.MasqueradingAs">
            <summary>
            Returns the <see cref="P:Rdmp.Core.DataExport.Data.ProjectCohortIdentificationConfigurationAssociation.CohortIdentificationConfiguration_ID"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.SelectedDataSets">
            <inheritdoc cref="T:Rdmp.Core.DataExport.Data.ISelectedDataSets"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SelectedDataSets.ExtractionConfiguration_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SelectedDataSets.ExtractableDataSet_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SelectedDataSets.RootFilterContainer_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SelectedDataSets.RootFilterContainer">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.SelectedDataSets.RootFilterContainer_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SelectedDataSets.ExtractionConfiguration">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.SelectedDataSets.ExtractionConfiguration_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SelectedDataSets.ExtractableDataSet">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.SelectedDataSets.ExtractableDataSet_ID"/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SelectedDataSets.SelectedDataSetsForcedJoins">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SelectedDataSets.#ctor(Rdmp.Core.Repositories.IDataExportRepository,Rdmp.Core.DataExport.Data.ExtractionConfiguration,Rdmp.Core.DataExport.Data.IExtractableDataSet,Rdmp.Core.DataExport.Data.FilterContainer)">
            <summary>
            Declares in the <paramref name="repository"/> database that the given <paramref name="dataSet"/> should be extracted as part of the given <see cref="!:configuration"/>.
            </summary>
            <param name="repository"></param>
            <param name="configuration"></param>
            <param name="dataSet"></param>
            <param name="rootContainerIfAny">Adds the restriction that the extraction SQL should include the WHERE logic in this container</param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SelectedDataSets.ToString">
            <summary>
            Returns the <see cref="P:Rdmp.Core.DataExport.Data.SelectedDataSets.ExtractableDataSet"/> name
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SelectedDataSets.GetDeleteMessage">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SelectedDataSets.InjectKnown(Rdmp.Core.DataExport.Data.IExtractableDataSet)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SelectedDataSets.InjectKnown(Rdmp.Core.DataExport.Data.IExtractionConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SelectedDataSets.InjectKnown(Rdmp.Core.DataExport.Data.ISelectedDataSetsForcedJoin[])">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SelectedDataSets.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SelectedDataSets.GetCumulativeExtractionResultsIfAny">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.SelectedDataSetsForcedJoin">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SelectedDataSetsForcedJoin.SelectedDataSets_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SelectedDataSetsForcedJoin.TableInfo_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SelectedDataSetsForcedJoin.TableInfo">
            <inheritdoc cref="P:Rdmp.Core.DataExport.Data.SelectedDataSetsForcedJoin.TableInfo_ID"/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SelectedDataSetsForcedJoin.#ctor(Rdmp.Core.Repositories.IDataExportRepository,Rdmp.Core.DataExport.Data.SelectedDataSets,Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <summary>
            Creates a new declaration in the <paramref name="repository"/> database that the given <paramref name="tableInfo"/> should
            always be joined against when extract the <paramref name="sds"/>.
            </summary>
            <param name="repository"></param>
            <param name="sds"></param>
            <param name="tableInfo"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SelectedDataSetsForcedJoin.InjectKnown(Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SelectedDataSetsForcedJoin.ClearAllInjections">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataExport.Data.SupplementalExtractionResults">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.CumulativeExtractionResults_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.ExtractionConfiguration_ID">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.DestinationDescription">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.RecordsExtracted">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.DateOfExtraction">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.Exception">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.SQLExecuted">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.ExtractedName">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.DestinationType">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.IsGlobal">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.#ctor(MapsDirectlyToDatabaseTable.IRepository,Rdmp.Core.DataExport.Data.IExtractionConfiguration,System.String,MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Starts a new audit in the database of a supplemental artifact (<paramref name="extractedObject"/>).  This is a GLOBAL artifact that is not associated
            with any one dataset but with the extraction as a whole.
            </summary>
            <param name="repository"></param>
            <param name="configuration">The configuration being extracted</param>
            <param name="sql">The SQL executed to generate the artifact or null if not appropriate (e.g. if it is a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/>)</param>
            <param name="extractedObject">The owner of the artifact being extracted (e.g. a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/> or <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable"/>)</param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.#ctor(MapsDirectlyToDatabaseTable.IRepository,Rdmp.Core.DataExport.Data.ICumulativeExtractionResults,System.String,MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Starts a new audit in the database of a supplemental artifact (<paramref name="extractedObject"/>).  This is a NON GLOBAL artifact that is associated only
            with the dataset being extracted.
            </summary>
            <param name="repository"></param>
            <param name="mainAudit">The dataset extraction audit for the dataset to which this supplemental artifact belongs</param>
            <param name="sql">The SQL executed to generate the artifact or null if not appropriate (e.g. if it is a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/>)</param>
            <param name="extractedObject">The owner of the artifact being extracted (e.g. a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingDocument"/> or <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable"/>)</param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.#ctor(MapsDirectlyToDatabaseTable.IRepository,System.Data.Common.DbDataReader)">
            <summary>
            Reads an existing audit record out of the data export database
            </summary>
            <param name="repository"></param>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.GetDestinationType">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.CompleteAudit(System.Type,System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.ToString">
            <summary>
            Returns <see cref="P:Rdmp.Core.DataExport.Data.SupplementalExtractionResults.ExtractedName"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.Commands.ExtractCommandCollection">
            <summary>
            Collection of all the datasets and custom tables that are available for extraction.  Since datasets can take a long time to extract sometimes a user
            will opt to only extract a subset of datasets (or he may have already succesfully extracted some datasets).  This collection should contain a full
            set of all the things that can be run for a given ExtractionConfiguration (including dataset specific lookups etc).
            
            <para>Use ExtractCommandCollectionFactory to create instances of this class.</para>
            
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.Commands.ExtractCommandCollectionFactory">
            <summary>
            Identifies all extractable components of a given ExtractionConfiguration (all datasets).  These are returned as an ExtractCommandCollection.  
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.Commands.ExtractCommandState">
            <summary>
            The current state an IExtractCommand has reached in an Extraction Pipeline.  Datasets in an ExtractionConfiguration are typically extracted in parallel.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.Commands.ExtractDatasetCommand">
            <summary>
            Command representing a desire to extract a given dataset in an ExtractionConfiguration through an extraction pipeline.  This includes bundled content 
            (Lookup tables, SupportingDocuments etc).  Also includes optional settings (e.g. IncludeValidation) etc.  You can realise the request by running the 
            QueryBuilder SQL. 
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.ExtractionTime.Commands.ExtractDatasetCommand.#ctor(Rdmp.Core.DataExport.Data.IExtractionConfiguration,Rdmp.Core.DataExport.ExtractionTime.UserPicks.IExtractableDatasetBundle,System.Boolean,System.Boolean)">
            <summary>
            This version has less arguments because it goes back to the database and queries the configuration and explores who the cohort is etc, it will result in more database
            queries than the more explicit constructor
            </summary>
            <param name="configuration"></param>
            <param name="datasetBundle"></param>
            <param name="includeValidation"></param>
            <param name="includeLookups"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.Commands.ExtractGlobalsCommand">
            <summary>
            Extraction command for the data export engine which mandates the extraction of all global (not dataset specific) files in an <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/> (e.g.
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.SupportingSQLTable"/>)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.Commands.IExtractCommand">
            <summary>
            Input object to Extraction Pipelines.  Typically this is a dataset that needs to be linked with a cohort and extracted into the ExtractionDirectory. 
            Also includes the ongoing ExtractCommandState that the IExtractCommand is in in the Pipeline e.g. WaitingForSQLServer etc.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.Commands.IExtractDatasetCommand">
            <summary>
            See ExtractDatasetCommand
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionDirectory">
            <summary>
            The target directory for a given ExtractionConfiguration on a given day.  This is where linked anonymised project extracts will appear when 
            an ExtractionConfiguration is executed.  It is also the location where the Release Engine will pick them up from when it bundles together a
            release package.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Destinations.ExecuteDatasetExtractionFlatFileDestination">
            <summary>
            Writes the pipeline DataTable (extracted dataset/custom data) to disk (as ExecuteExtractionToFlatFileType e.g. CSV).  Also copies SupportingDocuments, 
            lookups etc into accompanying folders in the ExtractionDirectory.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Destinations.ExecuteFullExtractionToDatabaseMSSql">
            <summary>
            Alternate extraction pipeline destination in which the DataTable containing the extracted dataset is written to an Sql Server database
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Destinations.IExecuteDatasetExtractionDestination">
            <summary>
            Destination for Extraction Pipelines.  Saves the extracted (anonymous) data contained in the DataTables received (which arrive in batches) to some location
            (depending on implementation).  Destinations must also support one off calls (per ExtractionConfiguration) to ExtractGlobals
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.ExtractionPipelineUseCase">
            <summary>
            Use case for linking and extracting Project Extraction Configuration datasets and custom data (See IExtractCommand).
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.ExtractionPipelineUseCase.Destination">
            <summary>
            If Destination is an IExecuteDatasetExtractionDestination then it will be initialized properly with the configuration, cohort etc otherwise the destination will have to react properly 
            / dynamically based on what comes down the pipeline just like it would normally e.g. SqlBulkInsertDestination would be a logically permissable destination for an ExtractionPipeline
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.DistinctStrategy">
            <summary>
            Range of strategies to eliminate identical record duplication when extracting data sets from RDMP
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.DistinctStrategy.None">
            <summary>
            Do not distinct the records extracted
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.DistinctStrategy.SqlDistinct">
            <summary>
            Apply a DISTINCT keyword to the SELECT statement
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.DistinctStrategy.OrderByAndDistinctInMemory">
            <summary>
            Apply an ORDER BY release id and apply the DISTINCT in memory as batches are read
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.ExecuteCrossServerDatasetExtractionSource">
            <summary>
            Data Extraction Source which can fulfill the IExtractCommand even when the dataset in the command is on a different server from the cohort.  This is done
            by copying the Cohort from the cohort database into tempdb for the duration of the pipeline execution and doing the linkage against that instead of
            the original cohort table.
            
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.ExecuteDatasetExtractionSource">
            <summary>
            Executes a single Dataset extraction by linking a cohort with a dataset (either core or custom data - See IExtractCommand).  Also calculates the number
            of unique identifiers seen, records row validation failures etc.
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.ExecuteDatasetExtractionSource.ExtractTimeTransformationsObserved">
            <summary>
            This is a dictionary containing all the CatalogueItems used in the query, the underlying datatype in the origin database and the
            actual datatype that was output after the transform operation e.g. a varchar(10) could be converted into a bona fide DateTime which
            would be an sql Date.  Finally
            a recommended SqlDbType is passed back.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.ExecuteDatasetExtractionSource.MakeDistinct(System.Data.DataTable,ReusableLibraryCode.Progress.IDataLoadEventListener,Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <summary>
            Makes the current batch ONLY distinct.  This only works if you have a bounded batch (see OrderByAndDistinctInMemory)
            </summary>
            <param name="chunk"></param>
            <param name="listener"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.ExecutePkSynthesizerDatasetExtractionSource">
            <summary>
            Extraction source which creates a PrimaryKey on the DataTable being extracted.  This is based on <see cref="P:Rdmp.Core.QueryBuilding.IColumn.IsPrimaryKey"/> of the
            columns extracted and is not garuanteed to actually be unique (depending on how you have configured the flags).  
            
            <para>The primary use case for this is when extracting to database where you want to have meaningful primary keys</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.RowPeeker">
            <summary>
            Class for selectively reading from a <see cref="T:Rdmp.Core.DataLoad.Engine.Pipeline.Sources.DbDataCommandDataFlowSource"/> until a condition
            is met (and preserving the unmatching DataRow so it is not missed later).
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.RowPeeker.AddPeekedRowsIfAny(System.Data.DataTable,System.Boolean)">
            <summary>
            Returns a DataTable with the peeked record, you should use the return value.  Returns peeked row
            even if the <paramref name="chunk"/> is null.
            </summary>
            <param name="chunk"></param>
            <param name="clearPeek">True to clear the peeked records</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Sources.RowPeeker.AddWhile(Rdmp.Core.DataLoad.Engine.Pipeline.Sources.IDbDataCommandDataFlowSource,System.Func{System.Data.DataRow,System.Boolean},System.Data.DataTable)">
            <summary>
            Reads records one at a time from the <paramref name="source"/> until a record is read where the
            <paramref name="equalityFunc"/> returns false.  Rows read (that passed <paramref name="equalityFunc"/>)
            are added to <paramref name="chunk"/> while the failing row becomes the new peeked row.
            </summary>
            <param name="source"></param>
            <param name="equalityFunc"></param>
            <param name="chunk"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionTimeTimeCoverageAggregator">
            <summary>
            Counts the number of unique patients / records encountered while executing an ExtractionConfiguration's dataset (linked to the project cohort).  The input
            to this is a DataRow rather than an SQL query because the class is used at extraction time as we are writing records out to the ExtractionDirectory.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.ExtractionTime.ExtractionTimeTimeCoverageAggregator.ExtendBucketsToEncompas(System.DateTime)">
            <summary>
            we want a consistent line of buckets with difference of BucketSize.  Use this method when you identify a DateTime that is (after
            rounding to the BucketSize, not in Buckets.  This method will add additional buckets up until the key has been reached (either 
            adding new higher buckets if the key is > than the current maximum or adding additional lower buckets if it is lower.
            </summary>
            <param name="key"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionTimeTimeCoverageAggregatorBucket">
            <summary>
            The number of unique patients and record count on a given day of an ExtractionTimeTimeCoverageAggregator.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionTimeValidator">
            <summary>
            Applies Catalogue.ValidationXML to rows extracted during a Data Extraction Pipeline (See ExecuteDatasetExtractionSource).  Because the columns which 
            are extracted can be a subset of the columns in the Catalogue and can include transforms the validation rules have to be adjusted (some are not applied).
            
            <para>A count of the number of rows failing validation is stored in VerboseValidationResults (divided by column) and is available for writing to the word
            metadata document that accompanies the extracted records (See WordDataWriter). </para>
            
            <para>This is similar to CatalogueConstraintReport (DQE) but is applied to a researchers extract instead of the Catalogue as a whole.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractTableVerbatim">
            <summary>
            Helper class for fetching entire tables from a database and writing them to CSV.  It uses CSVOutputFormat.CleanString to strip out problem characters.
            Records are read one at a time rather than downloading as a DataTable to allow any size of table to be processed without running out of memory.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.ExtractionTime.ExtractTableVerbatim.#ctor(FAnsi.Discovery.DiscoveredServer,System.String,System.String,System.IO.DirectoryInfo,System.String,System.String)">
            <summary>
            Runs the supplied SQL and puts it out to the file specified (in the outputDirectory), will deal with stripping separators etc automatically
            </summary>
            <param name="server"></param>
            <param name="sql">Some SQL you want to run (instead of a specific table)</param>
            <param name="outputName">The name of the csv file you would like to create in the outputDirectory.  Do not include.csv in your string it will be put on automatically</param>
            <param name="outputDirectory"></param>
            <param name="separator"></param>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.ExtractTimeTransformationObserved">
            <summary>
            Documents the extraction time data type of an extracted column.  This is done by inspecting the Type of the DataTable column fetched when executing the
            extraction SQL.  This can be different from the Database/Catalogue Type because there can be transformation SQL entered (e.g. LEFT etc).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.FileOutputFormats.CSVOutputFormat">
            <summary>
            Helper class for writing data to CSV files.  This is a simplified version of Rfc4180Writer in that it simply strips out all problem fields rather
            than applying proper escaping etc.  This is done because some researcher end point tools / scripts do not support the full specification of CSV and
            it is easier to provide them with a file where problem symbols are not present than explain that they have to join multiple lines together when it is
            bounded by quotes.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.IExtractionDirectory">
            <summary>
            See ExtractionDirectory
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.Listeners.ElevateStateListener">
            <summary>
            A simple DataLoadEventListener to be used during extraction so that the state can be moved to "crashed" if any component raises an error without an exception.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.UserPicks.Bundle">
            <summary>
            Ostensibly data extraction is simple: 1 Extraction Configuration, x datasets + 1 cohort.  In practice there are bundled Lookup tables, SupportingDocuments
            for each dataset, Global SupportingDocuments and even Custom Cohort Data.  The user doesn't nessesarily want to extract everything all the time.  
            Bundles are the collection classes for recording what subset of an ExtractionConfiguration should be run.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.UserPicks.BundledLookupTable">
            <summary>
            Identifies a TableInfo that acts as a Lookup for a given dataset which is being extracted.  Lookup tables can be extracted along with the extracted data
            set (See ExtractableDatasetBundle).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.UserPicks.ExtractableDatasetBundle">
            <summary>
            The dataset and all additional content related to that dataset within an ExtractionConfiguration which is about to be extracted.  This includes
            SupportingDocuments, Lookup tables etc).  This is a mutable class and allows you to 'DropContent' if you do not want to extract given parts (e.g. skip
            the lookups).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.UserPicks.GlobalsBundle">
            <summary>
            Bundle containing references to all the globally extractable (supplied with every project extraction regardless of dataset) documents and tables that need
            to be extracted/copied to the output ExtractionDirectory.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.UserPicks.IBundledLookupTable">
            <summary>
            See BundledLookupTable
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.UserPicks.IExtractableDatasetBundle">
            <summary>
            See ExtractableDatasetBundle
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataExport.ExtractionTime.WordDataWriter">
            <summary>
            Generates a Microsoft Word docx file containing information about a researchers extract including the file generated, the number of rows, distinct patients, the
            filters used in the extraction query, any parameters etc.  Optionally includes a validation table which counts the number of rows extracted that passed ValidationXML 
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataExport.ExtractionTime.WordDataWriter.GenerateWordFile">
            <summary>
            Generates a new meta data word file in the extraction directory and populates it with information about the extraction.
            It returns the open document as an object so that you can supplement it e.g. with catalogue information
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataExport.ProjectNumberException">
            <summary>
            Thrown when a given <see cref="T:Rdmp.Core.DataExport.Data.IProject"/> doesn't have a <see cref="P:Rdmp.Core.DataExport.Data.IProject.ProjectNumber"/> configured yet (null) or that number
            did not match an expected value (e.g. <see cref="P:Rdmp.Core.DataExport.Data.ExternalCohortDefinitionData.ExternalProjectNumber"/>).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1">
            <summary>
            Generic implementation of IDataFlowPipelineEngine (See IDataFlowPipelineEngine).  You can create a DataFlowPipelineEngine by manually constructing the context,
            source, destination etc but more often you will want to use an IPipeline configured by the user and an IPipelineUseCase to stamp out the pipeline into an instance
            of the engine (See IDataFlowPipelineEngineFactory).  IPipeline is the user configured set of components they think will achieve a given task.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.Components">
            <summary>
            Readonly cast of <see cref="P:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.ComponentObjects"/>. If you need to add components, add them to <see cref="P:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.ComponentObjects"/> instead.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.Destination">
            <summary>
            The last component in the pipeline, responsible for writing the chunks (of type {T}) to somewhere (E.g. to disk, to database etc)
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.Source">
            <summary>
            The first component in the pipeline, responsible for iteratively generating chunks (of type {T}) for feeding to downstream pipeline components
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.ComponentObjects">
            <summary>
            Middle components of the pipeline, must be <see cref="T:Rdmp.Core.DataFlowPipeline.IDataFlowComponent`1"/> with T appropriate to the context.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.DestinationObject">
            <inheritdoc cref="P:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.Destination"/>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.SourceObject">
            <inheritdoc cref="P:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.Source"/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.#ctor(Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext{`0},Rdmp.Core.DataFlowPipeline.IDataFlowSource{`0},Rdmp.Core.DataFlowPipeline.IDataFlowDestination{`0},ReusableLibraryCode.Progress.IDataLoadEventListener,Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline)">
            <summary>
            Creates a new pipeline engine ready to run under the <paramref name="context"/> recording events that occur to <paramref name="listener"/>.
            </summary>
            <param name="context"></param>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="listener"></param>
            <param name="pipelineSource"></param>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.Initialize(System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.ExecutePipeline(Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.ExecuteSinglePass(Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Runs checks on all components in the pipeline that support <see cref="T:ReusableLibraryCode.Checks.ICheckable"/>
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngine`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngineFactory">
            <summary>
            Creates DataFlowPipelineEngines from IPipelines.  An IPipeline is the persistent user configured reusable list of components (and arguments for those components) which
            will achieve a given task for the user (e.g. import a csv file).  The DataFlowPipelineContext defines both the Generic flow object of the engine (T) and which IPipelines
            will be judged compatible (based on PreInitialize requirements etc).  Some contexts require a specific source/destination component that is available only at runtime
            and cannot be changed/configured by the user (FixedDestination/FixedSource).  If the context requires a FixedSource or FixedDestination then you must pass the ExplicitSource
            object / ExplicitDestination object into the constructor.
            
            <para>In general rather than trying to use this class directly you should package up your requirements/initialization objects into a PipelineUseCase and call GetEngine. </para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngineFactory.#ctor(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase,Rdmp.Core.Repositories.MEF)">
            <summary>
            Creates a new factory which can translate <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline"/> blueprints into runnable <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine"/> instances.
            </summary>
            <param name="useCase">The use case which describes which <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline"/> are compatible, which objects are available for hydration/preinitialization etc</param>
            <param name="mefPlugins">Class for generating Types by name, use <see cref="P:Rdmp.Core.Repositories.ICatalogueRepository.MEF"/> to get this </param>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngineFactory.#ctor(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineUseCase,Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngineFactory.Create(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline,ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngineFactory.GetBest``1(``0,``0,System.String)">
            <summary>
            Returns the thing that is not null or throws an exception because both are blank.  also throws if both are populated
            </summary>
            <typeparam name="T2"></typeparam>
            <param name="explicitThing"></param>
            <param name="pipelineConfigurationThing"></param>
            <param name="descriptionOfWhatThingIs"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngineFactory.TryCreateComponent(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent,System.Exception@)">
            <summary>
            Attempts to construct an instance of the class described by <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.Class"/> and fulfil it's <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DemandsInitializationAttribute"/>.
            Returns null and populates <paramref name="ex"/> if this is not possible/errors.
            </summary>
            <param name="component"></param>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngineFactory.SetPropertyIfDemanded(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent,System.Object,System.Reflection.PropertyInfo,Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument[],System.Reflection.PropertyInfo)">
            <summary>
            Sets the value of a property on instance toReturn. 
            </summary>
            <param name="toBuild">IPipelineComponent which is the persistence record - the template of what to build</param>
            <param name="toReturn">An instance of the Class referenced by IPipelineComponent.Class (or in the case of [DemandsNestedInitializationAttribute] a reference to the nested property)</param>
            <param name="propertyInfo">The specific property you are trying to populate on toBuild</param>
            <param name="arguments">IArguments of toBuild (the values to populate toReturn with)</param>
            <param name="nestedProperty">If you are populating a sub property of the class then pass the instance of the sub property as toBuild and pass the nesting property as nestedProperty</param>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngineFactory.CreateSourceIfExists(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline)">
            <summary>
            Retrieves and creates an instance of the class described in the blueprint <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.Source"/> if there is one.  Pipelines do not have
            to have a source if the use case requires a fixed source instance generated at runtime.
            </summary>
            <param name="pipeline"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngineFactory.CreateDestinationIfExists(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline)">
            <summary>
            Retrieves and creates an instance of the class described in the blueprint <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.Destination"/> if there is one.  Pipelines do not have
            to have a destination if the use case requires a fixed destination instance generated at runtime
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.DataFlowPipelineEngineFactory.Check(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline,ReusableLibraryCode.Checks.ICheckNotifier,System.Object[])">
            <summary>
            Attempts to create an instance of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine"/> described by the blueprint <paramref name="pipeline"/>.  Components are then checked if they
            support <see cref="T:ReusableLibraryCode.Checks.ICheckable"/> using the <paramref name="checkNotifier"/> to record the results.
            </summary>
            <param name="pipeline">The blueprint to attempt to generate</param>
            <param name="checkNotifier">The event notifier to record how it went</param>
            <param name="initizationObjects">The objects available for fulfilling IPipelineRequirements</param>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.Events.PipelineEngineEventHandler">
            <summary>
            Handler for events which relate to an IDataFlowPipelineEngine (starting / completing etc)
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.Events.PipelineEngineEventArgs">
            <summary>
            Events that relate to an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.Events.PipelineEngineEventArgs.PipelineEngine">
            <summary>
            The sender of the event
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Events.PipelineEngineEventArgs.#ctor(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine)">
            <summary>
            Describes an event happening on <paramref name="sender"/>
            </summary>
            <param name="sender"></param>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken">
            <summary>
            Wrapper for two System.Threading.CancellationTokens.  One for Stopping (please stop when you are finished with the current job) and one for Aborting (please stop 
            as soon as possible).  If you like you can just specify the same token twice and nobody will be any the wiser. Remember that System.Threading.CancellationToken is
            for checking if cancellation is requested, in order to create and trigger cancellation you need a System.Threading.CancellationTokenSource handily you can use
            GracefulCancellationTokenSource to do that and then just reference .Token property.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.StopToken">
            <summary>
            CancellationToken for stopping where convenient (e.g. at the end of a data load)
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.AbortToken">
            <summary>
            CancellationToken for stopping as soon as possible
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.#ctor">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken"/> that will never be cancelled
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.#ctor(System.Threading.CancellationToken,System.Threading.CancellationToken)">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken"/> using the provided stop and abort tokens.  You can pass
            the same CancellationToken for both parameters if you only want to support abort.
            </summary>
            <param name="stopToken"></param>
            <param name="abortToken"></param>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.IsAbortRequested">
            <summary>
            True if <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.AbortToken"/> has been set
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.IsStopRequested">
            <summary>
            True if <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.StopToken"/> has been set
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.IsCancellationRequested">
            <summary>
            True if either <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.AbortToken"/> or <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.StopToken"/> has been set
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.ThrowIfCancellationRequested">
            <summary>
            Throws OperationCanceledException if either <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.AbortToken"/> or <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.StopToken"/> has been set
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.ThrowIfAbortRequested">
            <summary>
            Throws OperationCanceledException if <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.AbortToken"/> has been set
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.ThrowIfStopRequested">
            <summary>
            Throws OperationCanceledException if <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.StopToken"/> has been set
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.CreateLinkedSource">
            <summary>
            Creates a single CancellationTokenSource which will be triggered if either <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.StopToken"/> or <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.AbortToken"/> is set
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.GracefulCancellationTokenSource">
            <summary>
            Source for creating a GracefulCancellationToken.  See GracefulCancellationToken for description of this two level Cancellation strategy.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationTokenSource.Token">
            <summary>
            The object for checking whether stop / abort have been triggered
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.GracefulCancellationTokenSource.#ctor">
            <summary>
            Creates a new source for issuing a <see cref="T:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken"/> and triggering stop/abort later on.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.GracefulCancellationTokenSource.Stop">
            <summary>
            Triggers the stop flag of <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationTokenSource.Token"/> (<see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.StopToken"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.GracefulCancellationTokenSource.Abort">
            <summary>
            Triggers the abort flag of <see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationTokenSource.Token"/> (<see cref="P:Rdmp.Core.DataFlowPipeline.GracefulCancellationToken.AbortToken"/>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.IDataFlowComponent`1">
            <summary>
            A single component in an IDataFlowPipelineEngine T.  The component should do a single operation on the flowing data (e.g. if T is a System.Data.DataTable the component
            could delete duplicate rows) then return the results of the operation via ProcessPipelineData.
            
            <para>Where possible, you should implement IPluginDataFlowComponent instead of this class so that you are MEF discoverable</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.IDataFlowComponent`1.ProcessPipelineData(`0,ReusableLibraryCode.Progress.IDataLoadEventListener,Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <summary>
            Contains the code that will be executed to modify the T object passing through the component.  E.g. ColumnRenamer component would take each DataTable (T is a 
            DataTable for this example) and rename the column it is configured for (at Design Time).  This method will be called once for each T served by the IDataFlowSource.
            
            <para>Do not keep references to toProcess since it will interfere with garbage collection.</para>
            </summary>
            <param name="toProcess"></param>
            <param name="listener"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.IDataFlowComponent`1.Dispose(ReusableLibraryCode.Progress.IDataLoadEventListener,System.Exception)">
            <summary>
            Called after your pipeline has been fully executed (even if it resulted in a crash).  If the pipeline crashed then the Exception will be populated.
            </summary>
            <param name="listener"></param>
            <param name="pipelineFailureExceptionIfAny"></param>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.IDataFlowComponent`1.Abort(ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Invoked when the user (or program) attempts to cancel the pipeline execution.  This is used in addition to the GracefulCancellationToken since it can be called
            out of order (i.e. your component might not be currently executing at the abort time.
            </summary>
            <param name="listener"></param>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.IDataFlowDestination`1">
            <summary>
            Functions like a normal IDataFlowComponent except you should always return null from T ProcessPipelineData, allows the component to be used as the final component in a 
            DataFlowPipelineContext
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.IDataFlowPipelineEngineFactory">
            <summary>
            Factory for turning an IPipeline into a runnable engine.  See IDataFlowPipelineEngineFactory Generic T for full description
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.IDataFlowPipelineEngineFactory.Create(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline,ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Turns the blueprint <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline"/> into a runnable instance of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IDataFlowPipelineEngine"/>.  This engine will be uninitialized
            to start with. 
            </summary>
            <param name="pipeline"></param>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.IDataFlowSource`1">
            <summary>
            First component in an IDataFlowPipelineEngine, responsible for producing objects of type T via GetChunk until there are no new Ts available (e.g. reading from a
            csv file 50,000 lines at a time and generating System.Data.Table(s) until the file is exhausted).
            
            <para>Where possible, you should implement IPluginDataFlowSource instead of this class so that you are MEF discoverable</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.IDataFlowSource`1.GetChunk(ReusableLibraryCode.Progress.IDataLoadEventListener,Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <summary>
            Called iteratively during pipeline execution, this method should return chunks of data T which will then be processed further down the pipeline.  Do not
            retain references to the T object you return or that can interfere with garbage collection.  When you are unable to yield any more T objects return null
            to indicate that there is no more data to source
            </summary>
            <param name="listener"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.IDataFlowSource`1.Dispose(ReusableLibraryCode.Progress.IDataLoadEventListener,System.Exception)">
            <summary>
            Called after your pipeline has been fully executed (even if it resulted in a crash).  If the pipeline crashed then the Exception will be populated.
            </summary>
            <param name="listener"></param>
            <param name="pipelineFailureExceptionIfAny"></param>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.IDataFlowSource`1.Abort(ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Invoked when the user (or program) attempts to cancel the pipeline execution.  This is used in addition to the GracefulCancellationToken since it can be called
            out of order (i.e. your component might not be currently executing at the abort time.
            </summary>
            <param name="listener"></param>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.IDataFlowSource`1.TryGetPreview">
            <summary>
            This method is used at Design Time to help the user building a valid pipeline.  In theory the method should return a sample DataTable (or T) which is then 
            available programatically for checks and stuff.
            
            <para>In practice just returning null will work fine (it means no preview is available) or you can return an empty object with the compatible schema.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.IPluginDataFlowComponent`1">
            <summary>
            MEF discoverable version of for IDataFlowComponent.  Also forces you to write a Check implementation in which you confirm or deny that your component is in a runnable
            state.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.IPluginDataFlowSource`1">
            <summary>
            MEF discoverable version of IDataFlowSource
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1">
            <summary>
            Low level description of what an IPipeline must look like to be compatible with a given use case for a IDataFlowPipelineEngine.  This includes whether there must be
            a specific base type / interface for source / destination components as well as what the flow T object is (e.g. System.Data.DataTable).  
            
            <para>This class also handles distributing initialization object instances to subscribers (components implementing IPipelineRequirement X).  You can create one of these
            with DataFlowPipelineContextFactory but really you should only be doing this if you are building a new IPipelineUseCase.  If you are trying to run an IPipeline that
            is used elsewhere in RDMP then you need to find the IPipelineUseCase that matches the job you are trying to achieve.</para>
            
            <para>DataFlowPipelineContext is symantically similar to IPipelineUseCase, the difference is that the context only contains low level rules about what is compatible while
            the IPipelineUseCase also has the specific objects that will be used for initialization, fixed source instances etc (as well the context).</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.MustHaveSource">
            <summary>
            Optional.  Specifies that in order for an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline"/> to be compatible with the context, it's <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.Source"/> must inherit/implement the given Type
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.MustHaveDestination">
            <summary>
            Optional.  Specifies that in order for an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline"/> to be compatible with the context, it's <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline.Destination"/> must inherit/implement the given Type
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.CannotHave">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.#ctor">
            <summary>
            Creates a new empty context for determining <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline"/> compatibility
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.IsAllowable(System.Type)">
            <summary>
            Returns true the Type <paramref name="t"/> would be allowed by the context e.g. it doesn't implement an <see cref="P:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.CannotHave"/> and it is compatible with the flow Type {T} etc
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.IsAllowable(System.Type,System.String@)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.IsAllowable(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline,System.String@)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.IsAllowable(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.PreInitialize(ReusableLibraryCode.Progress.IDataLoadEventListener,Rdmp.Core.DataFlowPipeline.IDataFlowComponent{`0},System.Object[])">
            <summary>
            Initializes the given <paramref name="component"/> by calling all <see cref="T:Rdmp.Core.DataFlowPipeline.Requirements.IPipelineRequirement`1"/> it implements with the appropriate
            input object <paramref name="parameters"/>
            </summary>
            <param name="listener"></param>
            <param name="component"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.PreInitialize(ReusableLibraryCode.Progress.IDataLoadEventListener,Rdmp.Core.DataFlowPipeline.IDataFlowSource{`0},System.Object[])">
            <summary>
            Initializes the given <paramref name="component"/> by calling all <see cref="T:Rdmp.Core.DataFlowPipeline.Requirements.IPipelineRequirement`1"/> it implements with the appropriate
            input object <paramref name="parameters"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.PreInitializeGeneric(ReusableLibraryCode.Progress.IDataLoadEventListener,System.Object,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.GetIPipelineRequirementsForType(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.GetFlowType">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContextFactory`1">
            <summary>
            Factory for constructing DataFlowPipelineContexts based on some handy presets.  Particularly helpful because of the wierd way we enforce FixedDestination
            (basically we forbid the IPipeline from having any IDataFlowDestination).  Feel free to adjust your context after the factory creates it.  This is very low
            level functionality you should only need it if you are trying to define a new IPipelineUseCase for an entirely novel kind of pipeline usage.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContextFactory`1.Create(Rdmp.Core.DataFlowPipeline.Requirements.PipelineUsage)">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1"/> set up with appropriate <see cref="P:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.CannotHave"/> /
            <see cref="P:Rdmp.Core.DataFlowPipeline.Requirements.DataFlowPipelineContext`1.MustHaveSource"/> etc for the given <paramref name="flags"/>.
            </summary>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.Requirements.Exceptions.MultipleMatchingImplmentationException">
            <summary>
            Occurs when multiple input objects in a data flow pipeline match a given IPipelineRequirement e.g. IPipelineRequirement of object (never do this!) will match every single input object which will throw this exception
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.Exceptions.MultipleMatchingImplmentationException.#ctor(System.String)">
            <summary>
            Creates a new Exception with the provided message
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.Requirements.Exceptions.OverlappingImplementationsException">
            <summary>
            Occurs when there are 2 or more interfaces which both are compatible with a single input object during initialization of a pipeline component
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.Exceptions.OverlappingImplementationsException.#ctor(System.String)">
            <summary>
            Creates a new Exception with the provided message
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.Requirements.Exceptions.PropertyDemandNotMetException">
            <summary>
            Thrown when a component blueprint (<see cref="P:Rdmp.Core.DataFlowPipeline.Requirements.Exceptions.PropertyDemandNotMetException.PipelineComponent"/>) could not be resolved into an instance because a given property on the
            class was not set up correctly (<see cref="P:Rdmp.Core.DataFlowPipeline.Requirements.Exceptions.PropertyDemandNotMetException.PropertyInfo"/>)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.Requirements.FlatFileToLoad">
            <summary>
            Wrapper for FileInfo that can be used in the IPipelineRequirement interface to indicate that component expects a FileInfo that is specifically going to have data loaded
            out of it.  Having an IPipelineRequirement for a FileInfo on a component could be confusing, we might also want to allow multiple different types of FileInfo.  Having
            this wrapper ensures that there is no confusion about what a FlatFileToLoad Initialization Object is for. 
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.FlatFileToLoad.#ctor(System.IO.FileInfo)">
            <summary>
            Creates a new instance pointed at the given <paramref name="file"/>
            </summary>
            <param name="file"></param>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.Requirements.FlatFileToLoad.File">
            <summary>
            The file you are trying to load
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.FlatFileToLoad.ToString">
            <summary>
            Returns the filename of the file you are trying to load
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.Requirements.IDataFlowPipelineContext">
            <summary>
            See DataFlowPipelineContext T Generic
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.IDataFlowPipelineContext.GetFlowType">
            <summary>
            Returns the Type which must flow down pipeline engines assembled under this context e.g. DataTable, ReleaseAudit etc.  This determines the T that all
            <see cref="T:Rdmp.Core.DataFlowPipeline.IDataFlowComponent`1"/> must be implement in order to be compatible.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.IDataFlowPipelineContext.IsAllowable(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline)">
            <summary>
            Determines whether ever single component in the pipeline (blueprint) is compatible with the current context (based on Types, no instances are constructed).
            </summary>
            <param name="pipeline"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.IDataFlowPipelineContext.IsAllowable(Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipeline,System.String@)">
            <summary>
            Determines whether ever single component in the pipeline (blueprint) is compatible with the current context (based on Types, no instances are constructed).
            </summary>
            <param name="pipeline"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.IDataFlowPipelineContext.IsAllowable(System.Type)">
            <summary>
            Determines whether a given IDataFlowComponent Type is compatible with the current context
            </summary>
            <param name="t">The Type of an IDataFlowComponent</param>
            <returns>true if the component is compatible with the context</returns>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.IDataFlowPipelineContext.IsAllowable(System.Type,System.String@)">
            <summary>
            Determines whether a given IDataFlowComponent Type is compatible with the current context
            </summary>
            <param name="type">The Type of an IDataFlowComponent</param>
            <param name="reason">Null or the reason why the component is not compatible with the context e.g. it implements interface X which is forbidden by the context</param>
            <returns>true if the component is compatible with the context</returns>
        </member>
        <member name="P:Rdmp.Core.DataFlowPipeline.Requirements.IDataFlowPipelineContext.CannotHave">
            <summary>
            Types which <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent"/> classes (<see cref="P:Rdmp.Core.CatalogueLibrary.Data.Pipelines.IPipelineComponent.Class"/>) are not allowed to implement.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.IDataFlowPipelineContext.GetIPipelineRequirementsForType(System.Type)">
            <summary>
            Returns all IPipelineRequirement Types (T) which the given class implements e.g. class bob : IPipelineRequirement&lt;Project&gt;, IPipelineRequirement&lt;ExtractableCohort&gt;
            would return typeof(Project) and typeof(ExtractableCohort)
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.IDataFlowPipelineContext.PreInitializeGeneric(ReusableLibraryCode.Progress.IDataLoadEventListener,System.Object,System.Object[])">
            <summary>
            Calls all <see cref="M:Rdmp.Core.DataFlowPipeline.Requirements.IPipelineRequirement`1.PreInitialize(`0,ReusableLibraryCode.Progress.IDataLoadEventListener)"/> methods on the <paramref name="component"/> (which must be an <see cref="T:Rdmp.Core.DataFlowPipeline.IDataFlowComponent`1"/> or <see cref="T:Rdmp.Core.DataFlowPipeline.IDataFlowSource`1"/>)
            </summary>
            <param name="listener"></param>
            <param name="component"></param>
            <param name="initializationObjects"></param>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.Requirements.IPipelineRequirement`1">
            <summary>
            Used to model Runtime initialization.  IDataFlowComponents which implement this interface (you can implement for multiple T) will be Initialized with a compatible Initialization
             Object available in the IPipelineUseCase.
            
            <para>It specifies that an IDataFlowComponent or IDataFlowSource requires a particular object at execution time to function properly e.g.  a source which extractes linked data
            for a cohort might require an ExtractionRequest object (which must be provided by the hosting environment).  You can only currently have 1 object of each type.  </para>
            
            <para>IMPORTANT: If you can store the value you require Immutably instead e.g. Extraction Format CSV/TSV then you should instead use a [DemandsInitialization].  The difference
            between this and DemandsInitialization is that this interface is dynamic and dependent on who is executing it and what they are executing it on while DemandsInitialization 
            is configured once in the Catalogue (although it can be changed later) and is a constant at construction time.</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Rdmp.Core.DataFlowPipeline.Requirements.IPipelineRequirement`1.PreInitialize(`0,ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Initializes your object with some object of type T that corresponds to the usage context you are about to be executed under.  You can implement multiple copies of this 
            interface if you need for example an ExtractionRequest and an AuditObject and a EmailAddressOfAuthorizor or something.
            
            <para>IMPORTANT: You might be being checked and not actually run so when implementing this method you should not make any system changes or advanced auditing stuff.</para>
            </summary>
            <param name="value">An object</param>
            <param name="listener"></param>
        </member>
        <member name="T:Rdmp.Core.DataFlowPipeline.Requirements.PipelineUsage">
            <summary>
            Default options for creating common pipeline contexts
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataFlowPipeline.Requirements.PipelineUsage.None">
            <summary>
            There are no special flags for this pipeline context yet
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataFlowPipeline.Requirements.PipelineUsage.FixedDestination">
            <summary>
            The usage context of the pipeline is that program will always set it's own destination therefore no Pipelines can be configured which have their own user defined
            destination. When used in DataFlowPipelineContextFactory this prevents the addition of IDataFlowDestination components
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataFlowPipeline.Requirements.PipelineUsage.LoadsSingleTableInfo">
            <summary>
            Pipeline puts data into a single <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/>
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataFlowPipeline.Requirements.PipelineUsage.LogsToTableLoadInfo">
            <summary>
            Pipeline must log to an already existing <see cref="T:Rdmp.Core.Logging.TableLoadInfo"/>
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataFlowPipeline.Requirements.PipelineUsage.LoadsSingleFlatFile">
            <summary>
            Pipeline takes as input a file which is expected to be read by the source
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataFlowPipeline.Requirements.PipelineUsage.FixedSource">
            <summary>
            The pipeline cannot have a source, the source instance is provided at runtime by the environment
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Attachers.Attacher">
            <summary>
            A Class which will run during Data Load Engine execution and result in the creation or population of a RAW database, the database may or not require 
            to already exist (e.g. MDFAttacher would expect it not to exist but AnySeparatorFileAttacher would require the tables/databases already exist).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Attachers.IAttacher">
            <summary>
            See Attacher
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Attachers.IPluginAttacher">
            <summary>
            MEF discoverable version of IAttacher (See Attacher).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Checks.CheckEntireDataLoadProcess">
            <summary>
            Checks a LoadMetadata it is in a fit state to be executed (does it have primary keys, backup trigger etc).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Checks.Checkers.AnonymisationChecks">
            <summary>
            Wrapper class for checking Anonymisation configurations (if any) of a TableInfo.  The wrapped classes are ANOTableInfoSynchronizer and IdentifierDumper.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Checks.Checkers.CommandLineParser.ParseQuotedWord">
            <summary>
            Parse a quoted word
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Checks.Checkers.CommandLineParser.ParseBareWord">
            <summary>
            Parse a bareword
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Checks.Checkers.CommandLineParser.ParseEscapeSequence">
            <summary>
            Parse an escape sequence of one or more backslashes followed an an optional trailing quotation mark
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Checks.Checkers.CommandLineParser.ConsumeWhitespace">
            <summary>
            Consume inter-argument whitespace
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Checks.Checkers.PreExecutionChecker">
            <summary>
            Checks DLE databases (RAW, STAGING, LIVE) are in a correct state ahead of running a data load (See LoadMetadata).
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Engine.Checks.Checkers.PreExecutionChecker.HardFail">
            <summary>
            True if when running <see cref="M:Rdmp.Core.DataLoad.Engine.Checks.Checkers.PreExecutionChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)"/> there was a catastrophic problem e.g. unable to reach tables which means you shouldn't bother
            running any other kinds of checks
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Checks.Checkers.ProcessTaskChecks">
            <summary>
            Checks all ProcessTasks that the user has configured for a given data load (See LoadMetadata).  This involves both constructing and initializing 
            the instances (which can fail if Type names don't resolve etc) and calling check on the instantiated ProcessTask.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.DatabaseManagement.DatabaseOperations">
            <summary>
            SMO (Microsoft.SqlServer.Management.Smo) powered class for scripting tables, creating constraint free copies (e.g. RAW bubble) etc.  This is
            Microsoft only stuff (as opposed to the ReusableLibraryCode.DatabaseHelpers.Discovery namespace).  The class powers the data load engine.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.DatabaseManagement.EntityNaming.HICDatabaseConfiguration">
            <summary>
            Wrapper for StandardDatabaseHelper (which tells you where RAW, STAGING and LIVE databases are during data load execution).  This class exists for two reasons
            
            <para>Firstly to decide (based on IAttachers) whether RAW tables need to be scripted or whether they will appear magically during DLE execution (e.g. by attaching 
            an MDF file).</para>
            
            <para>Secondly to allow for overriding the RAW database server (which defaults to localhost).  It is a good idea to have RAW on a different server to LIVE/STAGING
            in order to reduce the risk incorrectly referencing tables in LIVE in Adjust RAW scripts etc.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Engine.DatabaseManagement.EntityNaming.HICDatabaseConfiguration.UpdateButDoNotDiff">
            <summary>
            Optional Regex for fields which will be ignored at migration time between STAGING and LIVE (e.g. hic_ columns).  This prevents incidental fields like
            valid from, data load run id etc from resulting in live table UPDATEs.
            
            <para>hic_ columns will always be ignored regardless of this setting</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.DatabaseManagement.EntityNaming.HICDatabaseConfiguration.#ctor(Rdmp.Core.CatalogueLibrary.Data.DataLoad.ILoadMetadata,Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads)">
            <summary>
            Preferred Constructor, creates RAW, STAGING, LIVE connection strings based on the data access points in the LoadMetadata, also respects the ServerDefaults for RAW override (if any)
            </summary>
            <param name="lmd"></param>
            <param name="namer"></param>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.DatabaseManagement.EntityNaming.HICDatabaseConfiguration.#ctor(FAnsi.Discovery.DiscoveredServer,Rdmp.Core.CatalogueLibrary.Data.EntityNaming.INameDatabasesAndTablesDuringLoads,Rdmp.Core.CatalogueLibrary.Data.Defaults.IServerDefaults,Rdmp.Core.CatalogueLibrary.Data.IExternalDatabaseServer)">
            <summary>
            Constructor for use in tests, if possible use the LoadMetadata constructor instead
            </summary>
            <param name="liveServer">The live server where the data is held, IMPORTANT: this must contain InitialCatalog parameter</param>
            <param name="namer">optionally lets you specify how to pick database names for the temporary bubbles STAGING and RAW</param>
            <param name="defaults">optionally specifies the location to get RAW default server from</param>
            <param name="overrideRAWServer">optionally specifies an explicit server to use for RAW</param>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.DatabaseManagement.Operations.DatabaseCloner">
            <summary>
            Clones databases and tables using ColumnInfos, and records operations so the cloning can be undone.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.DatabaseManagement.Operations.TableInfoCloneOperation">
            <summary>
            Creates RAW / STAGING tables during a data load (See LoadMetadata).  Tables created are based on the live schema.  Depending on stage though certain
            changes will be made.  For example RAW tables will not have any constraints (primary keys, not null etc) and will also contain all PreLoadDiscardedColumns.
            
            <para>This class is powered by SMO and is Microsoft Sql Server specific.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.DatabaseManagement.StandardDatabaseHelper">
            <summary>
            Stores the location of all the databases (RAW, STAGING, LIVE) available during a Data Load (See LoadMetadata).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.DataProvider.FromCache.BasicCacheDataProvider">
            <summary>
            Simple implementation of abstract CachedFileRetriever which unzips/copies data out of the cache into the ForLoading directory according to
            the current IDataLoadJob coverage dates (workload).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.DataProvider.FromCache.CachedFileRetriever">
            <summary>
            Fetches all the ILoadProgresss in the ILoadMetadata, it then selects the first scheduled task which has work to be done (e.g. data is cached but not yet loaded).  
            Cached data is unzipped to the forLoading directory.  The Dispose method (which should be called after the entire DataLoad has completed successfully) will clear
            out the cached file(s) that were loaded and update the schedule to indicate the successful loading of data
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.DataProvider.FromCache.DeleteCachedFilesOperation">
            <summary>
            UpdateProgressIfLoadsuccessful (See UpdateProgressIfLoadsuccessful) which also deletes files in the ForLoading directory that were generated during the
            load e.g. by a CachedFileRetriever.  Files are only deleted if the ExitCodeType.Success otherwise they are left in ForLoading for debugging / inspection.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.DataProvider.FromCache.ICachedDataProvider">
            <summary>
            MEF discoverable plugin implementation of IDataProvider intended to read from the ILoadProgress cache directory (e.g. and unzip into 
            LoadDirectory.ForLoading) during data loading.  This is only required if you want to be able to change the way you interact with
            your cache (e.g. if you have a proprietary archive format).  In general you should try to ensure any caches you create are compatible with
            BasicCacheDataProvider and just use that instead.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.DataProvider.IDataProvider">
            <summary>
            DLE component ostensibly responsible for 'fetching data'.  This typically involves fetching data and saving it into the ILoadDirectory (e.g. into 
            ForLoading) ready for loading by later components.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.DataProvider.IPluginDataProvider">
            <summary>
            MEF discoverable (Plugin) version of IDataProvider
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.IDisposeAfterDataLoad">
            <summary>
            Interface for all data load components which allows for post load cleanup (even if the load crashed).  See DataLoadProcess.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.DataLoadJob">
            <summary>
            Documents an ongoing load that is executing in the Data Load Engine.  This includes the load configuration (LoadMetadata), Logging object (DataLoadInfo),
            file system (LoadDirectory) etc.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.IDataLoadJob">
            <summary>
            See DataLoadJob
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Engine.Job.IDataLoadJob.Payload">
            <summary>
            Optional externally provided object to drive the data load.  For example if you have an explicit list of objects in memory to process and
            a custom Attacher which expects to be magically provided with this list then communicate the list to the Attacher via this property.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Job.IDataLoadJob.CreateTablesInStage(Rdmp.Core.DataLoad.Engine.DatabaseManagement.Operations.DatabaseCloner,Rdmp.Core.CatalogueLibrary.Data.LoadBubble)">
            <summary>
            Orders the job to create the tables it requires in the given stage (e.g. RAW/STAGING), the job will also take ownership of the cloner for the purposes
            of disposal (DO NOT DISPOSE OF CLONER YOURSELF)
            </summary>
            <param name="cloner"></param>
            <param name="stage"></param>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.IJobFactory">
            <summary>
            Creates the DataLoadJob which will run in a given DataLoadProcess (either one off load or an iterative load of a specific range of dates - See LoadProgress).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.JobFactory">
            <summary>
            Basic IJobFactory for creating an 'OnDemand', one off, self contained (not date based) IDataLoadJob.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.DataLoadProgressUpdateException">
            <summary>
            Thrown when there is a problem updating the date of a LoadProgress during a ScheduledDataLoadJob (or identifying a suitable date to use for the update).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.Exceptions.CacheDataProviderFindingException">
            <summary>
            Thrown when we are attempting to determine the loadable date range of a Scheduled data load (See LoadProgress) by looking at the Cache.  For example if the
            load doesn't have any ICachedDataProvider components.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.Exceptions.LoadOrCacheProgressUnclearException">
            <summary>
            Thrown when it is not possible to determine the starting date of a scheduled data load e.g. when there is a LoadProgress record where there is no 
            LoadProgress.OriginDate or LoadProgress.DataLoadProgress recorded (so we don't know when the data allegedly started being available/loadable).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.IJobDateGenerationStrategy">
            <summary>
            Determines how DateTimes for a Scheduled load are determined.  Scheduled loads are those where the LoadMetadata has one or more LoadProgresses.  We
            could simply add the next 'batchSize' days to the head date of the LoadProgress.  Alternatively we could inspect the cache to make sure that there
            are files for those dates and skip any holes. 
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.IUpdateLoadProgress">
            <summary>
            See UpdateProgressIfLoadsuccessful
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.JobDateGenerationStrategyFactory">
            <summary>
            Decides the date generation strategy (e.g. pick next X days from the head of the LoadProgress or base dates loaded on next files available in cache)
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Job.Scheduling.JobDateGenerationStrategyFactory.#ctor(Rdmp.Core.DataLoad.Engine.LoadProcess.Scheduling.Strategy.ILoadProgressSelectionStrategy)">
            <summary>
            Always respects the LoadProgress dates and crashes if there arent any load progresses associated with the given load metadata
            Uses SingleScheduleCacheDateTrackingStrategy if there is a cache associated with any of the load progresses otherwise uses SingleScheduleConsecutiveDateStrategy (meaning for example each day for the next 5 days)
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.MultipleScheduleJobFactory">
            <summary>
            Return a ScheduledDataLoadJob hydrated with appropriate dates for the LoadProgress supplied.  This class differs from SingleScheduledJobFactory only
            in that it lets you pass multiple ILoadProgress instead of only one, the class will decide which is the next most sensible one to run.  For example
            you might have 'Load Biochem For Tayside' and 'Load Biochem For Fife' as two LoadProgress in the LoadMetadata 'Loading Biochemistry', this class would 
            pick which one to execute next. 
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Job.Scheduling.MultipleScheduleJobFactory.HasJobs">
            <summary>
            Returns false only if no schedule has any jobs associated with it
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.ScheduledDataLoadJob">
            <summary>
            DataLoadJob that is part of an ongoing data load where only specific dates are loaded.  Typically this involves advancing the head of a LoadProgress
            (e.g. 'Load the next 5 days of LoadProgress - Tayside Biochemistry Load').
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.SingleScheduleCacheDateTrackingStrategy">
            <summary>
            This returns dates by examining cache filenames whilst honouring the Load and Cache Progress information
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Job.Scheduling.SingleScheduleCacheDateTrackingStrategy.CalculateLastLoadDate(Rdmp.Core.CatalogueLibrary.Data.ILoadProgress)">
            <summary>
            
            </summary>
            <param name="loadProgress"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">Caching has not been configured correctly or the caching process has not begun</exception>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Job.Scheduling.SingleScheduleCacheDateTrackingStrategy.GetCacheDestinationPipelineComponent(Rdmp.Core.CatalogueLibrary.Data.Cache.ICacheProgress)">
            <summary>
            Retrieves the destination component from the caching pipeline associated with the ICacheProgress object. The destination component is required to be an ICacheFileSystemDestination.
            </summary>
            <param name="cacheProgress"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">Caching pipeline is not configured properly/doesn't exist</exception>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.SingleScheduleConsecutiveDateStrategy">
            <summary>
            Returns dates consecutively with reference to a LoadProgress, starting from the last successful load (DataLoadProgress) or OriginDate if no load has yet
            been successfully completed
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Job.Scheduling.SingleScheduleConsecutiveDateStrategy.GetDates(System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="batchSize"></param>
            <param name="allowLoadingFutureDates">if true then dates can be loaded that are in the future otherwise the returned list of dates will only contain dates in teh past</param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.SingleScheduledJobFactory">
            <summary>
            Return a ScheduledDataLoadJob hydrated with appropriate dates for the LoadProgress supplied (e.g. load the next 5 days of Load Progress 'Tayside Biochem
            Loading').
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.Scheduling.UpdateProgressIfLoadsuccessful">
            <summary>
            Data Load Engine disposal step for scheduled data loads (See ScheduledDataLoadJob) in which the LoadProgress head pointer date is updated.  E.g. if the 
            job was to load 5 days then the LoadProgress.DataLoadProgress date would be updated to reflect the loaded date range.  This is non trivial because it might
            be that although the job was to load 100 days the source data read ended after 10 days so you might only want to update the DataLoadProgress date by 10
            days on teh assumption that more data will appear later to fill that gap.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Job.ThrowImmediatelyDataLoadJob">
            <summary>
            Empty implementation of IDataLoadJob that can be used during Checking / Tests etc 
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Arguments.CommandLineHelper">
            <summary>
            Helper class for assembling a command line parameters strings for an .exe.  This will wrap with quotes when there is whitespace etc.  Class can
            be used when you have generic key value pairs you want to send to an exe as startup parameters.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Arguments.IStageArgs">
            <summary>
            See StageArgs
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Arguments.LoadArgsDictionary">
            <summary>
            Creates StageArgs for each LoadStage based on the supplied LoadMetadata (load configuration).  This tells the DLE where each database is etc in the 
            RAW => STAGING => LIVE model rdmp uses for data loading.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Arguments.RuntimeArgumentCollection">
            <summary>
            Stores all the user defined arguments of a ProcessTask (See DemandsInitializationAttribute) and all the runtime arguments for the stage it is in 
            within the data load (See StageArgs).  For example an IAttacher of type DelimitedFlatFileAttacher could be declared as a ProcessTask in the Mounting
            stage of a DLE configuration (LoadMetadata).  At runtime a RuntimeArgumentCollection would be created with the user specified IArguments (e.g. Delimiter
            is comma, file pattern is *.csv) and the IStageArgs (where RAW database to load is and what the ForLoading directory is where the flat files can be found).
            
            <para>This class is used by RuntimeTask to hydrate the hosted instance (IAttacher, IDataProvider, IMutilateDataTables etc) dictated by the user (in the 
            ProcessTask).</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Arguments.RuntimeArgumentCollection.#ctor(Rdmp.Core.CatalogueLibrary.Data.DataLoad.IArgument[],Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Arguments.IStageArgs)">
            <summary>
            Transition from the arguments defined in the data source (Catalogue Database) into a runtime state
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Arguments.StageArgs">
            <summary>
            Identifies the database target of a given DLE LoadStage (e.g. AdjustRaw would contain a DiscoveredDatabase pointed at the RAW database). Also includes
            the location of the load directory
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.CompositeDataLoadComponent">
            <summary>
            DataLoadComponent (DLE) that consists of running multiple subcomponents (also DataLoadComponents).  This is used for composite stages e.g. 
            adjustStagingAndMigrateToLive where you want to run all or none (skip) of the components and pass the collection around as a single object.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.DeleteForLoadingFilesOperation">
            <summary>
            DLE post load disposal operation which deletes all the files in the ForLoading directory.  This is added to the disposal stack and should be executed
            after the archiving of ForLoading (See ArchiveFiles).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.IDataLoadComponent">
            <summary>
            A discrete step in DLE execution either configured by the user (ProcessTask=>RuntimeTask) or a fixed step e.g. MigrateRAWTableToStaging.  See
            DataLoadEngine.cd for how all the various components interact in the larger scheme of the DLE IDataLoadExecution.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.LoadFiles">
            <summary>
            DLE component responsible for the LoadStage.GetFiles.  This includes running any user configured ProcessTask (which will be RuntimeTasks in _components).
            Also pushes DeleteForLoadingFilesOperation onto the disposal stack so that any files accumulated in ForLoading are cleared at the end of the DLE run (After
            archiving).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.PopulateRAW">
            <summary>
            DLE component responsible for creating the RAW (first database in the RAW=>STAGING=>LIVE model of DLE loading) database (if required).  Also runs
            all LoadStage.Mounting and components.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.RuntimeTaskPackager">
            <summary>
            Converts multiple user defined DLE ProcessTasks into a single hydrated CompositeDataLoadComponent.  This involves converting the ProcessTasks
            (which are user defined class names, argument values etc) into instances of IRuntimeTask.  You can either call CreateCompositeDataLoadComponentFor
            to create a generic CompositeDataLoadComponent containing all the IRuntimeTasks or you can get the IRuntimeTask list directly and use it yourself in
            a more advanced DataLoadComponent (e.g. PopulateRAW - See usages in HICDataLoadFactory)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.AttacherRuntimeTask">
            <summary>
            RuntimeTask that hosts an IAttacher.  The instance is hydrated from the users configuration (ProcessTask and ProcessTaskArguments) See
            RuntimeArgumentCollection
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.DataProviderRuntimeTask">
            <summary>
            RuntimeTask that hosts an IDataProvider.  The instance is hydrated from the users configuration (ProcessTask and ProcessTaskArguments) See
            RuntimeArgumentCollection
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.ExecutableRuntimeTask">
            <summary>
            RuntimeTask that executes a single .exe file specified by the user in a ProcessTask with ProcessTaskType Executable.  The exe will be given command line
            arguments for the database connection / loading directory via RuntimeArgumentCollection
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.ExecuteSqlFileRuntimeTask">
            <summary>
            RuntimeTask that executes a single .sql file specified by the user in a ProcessTask with ProcessTaskType SQLFile.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.ExecuteSqlFileRuntimeTaskException">
            <summary>
            Exception thrown when there is an error in assembling/running an <see cref="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.ExecuteSqlFileRuntimeTask"/>.  This does not include SqlExceptions thrown as a result
            of running the final script on the database.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.IMEFRuntimeTask">
            <summary>
            RuntimeTask for all 'class based' ProcessTaskTypes (IAttacher, IDataProvider etc).  See RuntimeTask for full Description.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.IRuntimeTask">
            <summary>
            See RuntimeTask
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.MandatoryPropertyChecker">
            <summary>
            Checks that all Properties on the supplied classInstanceToCheck that are decorated with a [DemandsInitialization] where the Mandatory flag is true have 
            a value.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.MutilateDataTablesRuntimeTask">
            <summary>
            RuntimeTask that hosts an IMutilateDataTables.  The instance is hydrated from the users configuration (ProcessTask and ProcessTaskArguments) See
            RuntimeArgumentCollection
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.RuntimeTask">
            <summary>
            Runtime realisation of a ProcessTask.  ProcessTask is the DesignTime template configured by the user.  RuntimeTask is the 'ready to execute' version.
            There are two main kinds of RuntimeTask in the RDMP data load engine (See DataLoadEngine.cd).
            
            <para>The first are those that host a class instance (IMEFRuntimeTask) e.g. IAttacher, IDataProvider.  In this case the ProcessTask is expected to be configured
            with the class Type and have IArguments that specify all values for hydrating the instance created (See ProcessTaskArgument).</para>
            
            <para>The second are those that do not have a MEF class powering them.  This includes ProcessTaskTypes like Executable and SQLFile where the ProcessTask.Path
            is simply the location of the exe/sql file to run at runtime. </para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Runtime.RuntimeTaskFactory">
            <summary>
            Translates a data load engine ProcessTask (design time template) configured by the user into the correct RuntimeTask (realisation) based on the
            ProcessTaskType (Attacher, Executable etc).  See DataLoadEngine.cd
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Standard.ArchiveFiles">
            <summary>
            Copies all files in ForLoading directory of a DLE load into the ForArchiving folder zipped up in a file named x.zip where x is the ID of the data load run
            (unique logging number for the data load execution).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Standard.MigrateRAWTableToStaging">
            <summary>
            Streams records from a single table in the RAW database and writes it to the corresponding table in the STAGING database during data load.  RAW is an 
            unconstrained identifiable version of the LIVE table created at the start of an RMDP data load (the RAW=>STAGING=>LIVE model).  STAGING is a constrained
            (has primary keys / not nulls etc) version of the LIVE table.  This class uses a DataFlowPipelineEngine to stream the records and this includes (optionally)
            any anonymisation operations (dropping columns, substituting identifiers etc) configured on the TableInfo (See BasicAnonymisationEngine).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Standard.MigrateRAWToStaging">
            <summary>
            DLE component resonsible for streaming data off the RAW database and writing it to the STAGING database.  Happens one table at a time with the actual
            implementation of moving data in MigrateRAWTableToStaging (See MigrateRAWTableToStaging).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.Components.Standard.MigrateStagingToLive">
            <summary>
            DLE component resonsible for merging records in the STAGING database into the LIVE database table(s) during a Data Load Engine execution.  The actual
            implementation of migrating records done by MigrationHost and MigrationConfiguration.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.HICDataLoadFactory">
            <summary>
            This is factored out more for documentation's sake. It is a description of the HIC data load pipeline, in factory form!
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.IDataLoadExecution">
            <summary>
            See SingleJobExecution
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadExecution.SingleJobExecution">
            <summary>
            Pipeline which processes a single job through all stages before accepting another.  Execution involves running each DataLoadComponent with the current 
            IDataLoadJob and then disposing them. 
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.LoadExecution.SingleJobExecution.Run(Rdmp.Core.DataLoad.Engine.Job.IDataLoadJob,Rdmp.Core.DataFlowPipeline.GracefulCancellationToken)">
            <summary>
            
            </summary>
            <returns></returns>
            <exception cref="T:System.OperationCanceledException"></exception>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadProcess.DataLoadProcess">
            <summary>
            Container class for an IDataLoadExecution.  This class records the ILoadMetadata that is being executed and the current state (whether it has crashed etc).
            When you call run then an IDataLoadJob will be generated by the JobProvider will be executed by the LoadExecution (See IDataLoadExecution).
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Engine.LoadProcess.DataLoadProcess.JobProvider">
            <summary>
            Provides jobs for the data load process, allows different strategies for what jobs will be loaded e.g. single job, scheduled
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Engine.LoadProcess.DataLoadProcess.LoadExecution">
            <summary>
            The load execution that will be used to load the jobs provided by the JobProvider
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadProcess.HICLoadConfigurationFlags">
            <summary>
            Options for controlling which sections of a Data Load are skipped/executed (e.g. for user debugging purposes you might want to stop a load after 
            populating RAW if you think there is a problem with the load configuration).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadProcess.IDataLoadProcess">
            <summary>
            See DataLoadProcess
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadProcess.Scheduling.IterativeScheduledDataLoadProcess">
            <summary>
            DataLoadProcess for LoadMetadata's which have one or more LoadProgresses (See ScheduledDataLoadProcess).  This version of ScheduledDataLoadProcess will
            run loads one after another until all LoadProgresses are exhausted (they have loaded all data up to today / when available data stops).  For example
            if you have a load 'Load biochemistry records' with a LoadProgress which 'loads 5 days at a time' and is currently at LoadProgress.DataLoadProgress of
            2001-01-01 it will keep running data loads iteratively until the IDataLoadExecution returns OperationNotRequired (i.e. the load is up-to-date).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadProcess.Scheduling.ScheduledDataLoadProcess">
            <summary>
            Loads data according to a data-based schedule, e.g. Biochemistry.
            Needs to know: how to generate dates for the job, how to select a load schedule
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadProcess.Scheduling.SingleJobScheduledDataLoadProcess">
            <summary>
            DataLoadProcess for LoadMetadata's which have one or more LoadProgresses (See ScheduledDataLoadProcess).  This version of ScheduledDataLoadProcess will
            run a single execution of a LoadProgress.  For example if you have a load 'Load biochemistry records' with a LoadProgress which 'loads 5 days at a time'
            and is currently at LoadProgress.DataLoadProgress of 2001-01-01 it will run a single load (See ScheduledDataLoadJob) for the next 5 days and then stop.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadProcess.Scheduling.Strategy.AnyAvailableLoadProgressSelectionStrategy">
            <summary>
            ILoadProgressSelectionStrategy in which all LoadProgresses are suggested and all are locked.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadProcess.Scheduling.Strategy.ILoadProgressSelectionStrategy">
            <summary>
            Decides which LoadProgress (if any) to advance in a ScheduledDataLoadProcess.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.LoadProcess.Scheduling.Strategy.ILoadProgressSelectionStrategy.GetAllLoadProgresses">
            <summary>
            Return a list of the runnable load progresses
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.LoadProcess.Scheduling.Strategy.SingleLoadProgressSelectionStrategy">
            <summary>
            Hacky ILoadProgressSelectionStrategy in which only the specific LoadProgress in the constructor to this class is ever suggested.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.BackfillMigrationFieldProcessor">
            <summary>
            IMigrationFieldProcessor for StagingBackfillMutilator (See StagingBackfillMutilator).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.DatabaseMigrationStrategy">
            <summary>
            See OverwriteMigrationStrategy
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.IMigrationFieldProcessor">
            <summary>
            Handles the routing of columns in a MigrationColumnSet to either FieldsToDiff or FieldsToUpdate during a MERGE query in which records are written into
            LIVE from STAGING.  Note that this interface is also usable to describe a reverse flow of records in which records in STAGING are modified depending
            on records/fields in LIVE (See StagingBackfillMutilator).
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Migration.IMigrationFieldProcessor.AssignFieldsForProcessing(FAnsi.Discovery.DiscoveredColumn,System.Collections.Generic.List{FAnsi.Discovery.DiscoveredColumn},System.Collections.Generic.List{FAnsi.Discovery.DiscoveredColumn})">
            <summary>
            Assigns the current field to either Diff and/or Update (or neither).
            </summary>
            <param name="field">the field to assign to one/none/both lists</param>
            <param name="fieldsToDiff">Fields that will have their values compared for change, to decide whether to overwrite destination data with source data.
            (some fields might not matter if they are different e.g. dataLoadRunID)</param>
            <param name="fieldsToUpdate">Fields that will have their values copied across to the new table (this is usually a superset of fields to diff, and also
            includes all primary keys).</param>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.MigrationColumnSet">
            <summary>
            Defines the role of every field involved in a STAGING to LIVE migration during DLE execution.  When performing a selective UPDATE it is important not to
            overwrite current records with new records where the 'newness' is an artifact of data loading rather than source data.  For example the field 
            hic_dataLoadRunID will always be different between STAGING and LIVE.  This class stores which columns should be used to identify records which exist
            in both (PrimaryKeys), which columns indicate significant change and should be promoted (FieldsToDiff) and which are not significant changes but should 
            be copied across anyway in the event that the row is new or there is a difference in another significant field in that record (FieldsToUpdate).
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Engine.Migration.MigrationColumnSet.FieldsToDiff">
            <summary>
            Fields that will have their values compared for change, to decide whether to overwrite destination data with source data. (some fields might not matter
            if they are different e.g. dataLoadRunID)
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Engine.Migration.MigrationColumnSet.FieldsToUpdate">
            <summary>
            Fields that will have their values copied across to the new table (this is a superset of fields to diff, and also includes all primary keys).  Note
            that the non-standard columns (data load run and valid from do not appear in this list, you are intended to handle their update yourself)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.MigrationConfiguration">
            <summary>
            Converts a list of TableInfos into MigrationColumnSets to achieve migration of records from STAGING to LIVE during a DLE execution.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.MigrationHost">
            <summary>
            Migrates records from STAGING database tables to LIVE database tables by applying the OverwriteMigrationStrategy (MERGE statement - colloquially known
            as UPSERT) using a shared database transaction for all tables (if one fails they will all rollback).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.QueryBuilding.LiveMigrationQueryHelper">
            <summary>
            See MigrationQueryHelper
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.QueryBuilding.MigrationColumnSetQueryHelper">
            <summary>
            Helper class for generating SQL fragments that relate to columns in a MigrationColumnSet.  This is used by MigrationQueryHelper to generate SQL
            for merging STAGING into LIVE during a data load.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.QueryBuilding.MigrationQueryHelper">
            <summary>
            Generates the MERGE and UPDATE SQL queries responsible for migrating records from STAGING to LIVE as part of a data load.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.QueryBuilding.OverwriteMigrationStrategy">
            <summary>
            Migrates from STAGING to LIVE a single table (with a MigrationColumnSet).  This is an UPSERT (new replaces old) operation achieved (in SQL) with MERGE and 
            UPDATE (based on primary key).  Both tables must be on the same server.  A MERGE sql statement will be created using LiveMigrationQueryHelper and executed
            within a transaction.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.QueryBuilding.ReverseMigrationQueryHelper">
            <summary>
            Reverse  of LiveMigrationQueryHelper.  Builds 'migration' query for updating STAGING to match LIVE when doing a backfill data load (See 
            StagingBackfillMutilator).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Migration.StagingToLiveMigrationFieldProcessor">
            <summary>
            Checks that LIVE has appropriate fields to support the migration of records from STAGING to LIVE and assigns fields roles such that artifact fields
            that are generated as part of the load (i.e. computed columns) denoted by the prefix hic_ are not treated as differences in the dataset.  This means
            that records in STAGING with a new hic_dataLoadRunID (all of them because each load gets a unique number) will not be identified as UPDATES to the 
            LIVE data table and will be ignored (assuming that there are no differences in other fields that are Diffed).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Mutilators.IMutilateDataTables">
            <summary>
            A user configurable component which will run during Data Load Engine execution and result in the modification of an existing table in of the load
            stages (RAW, STAGING or LIVE).  For example a PrimaryKeyCollisionResolverMutilation will delete records out of the table such that the Primary Key
            is unique (based on a column preference order). 
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Mutilators.IMutilateDataTables.Initialize(FAnsi.Discovery.DiscoveredDatabase,Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadStage)">
            <summary>
            Called after construction to tell you where you will be running.  Note that at Checks time this might not exist yet (if you are in RAW/STAGING)
            </summary>
            <param name="dbInfo"></param>
            <param name="loadStage"></param>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Mutilators.IPluginMutilateDataTables">
            <summary>
            MEF discoverable version of IMutilateDataTables
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Components.Anonymisation.ANOConfigurationException">
            <summary>
            Thrown when there is a problem with the configuration of an ANOTable / Identifier Dump.  This can include datatype mismatches, dump not having correct
            columns / backup trigger etc.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Components.Anonymisation.ANOTableInfoSynchronizer">
            <summary>
            Checker for validating the anonymisation configuration of a TableInfo.  This includes iterating all columns which have ANOTables configured (See ANOTable)
            and checking that the database has the correct columns / datatypes etc).  Also checks the IdentifierDumper.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Components.Anonymisation.ANOTransformer">
            <summary>
            Substitutes identifiers in a DataTable for ANO mapped equivalents (for a single DataColumn/ANOTable only).  For example storing all LabNumbers stored in
            DataColumn LabNumber into the ANO Store database table and adding a new column to the DataTable called ANOLabNumber and putting in the appropriate 
            replacement values.  All the heavy lifting (identifier allocation etc) is done by the stored proceedure SubstitutionStoredprocedure.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Components.Anonymisation.BasicAnonymisationEngine">
            <summary>
            Pipeline component for anonymising DataTable batches in memory according to the configuration of ANOTables / PreLoadDiscardedColumn(s) in the TableInfo.
            Actual functionality is implemented in IdentifierDumper and ANOTransformer(s).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Components.Anonymisation.ColumnInfoToANOTableConverter">
            <summary>
            Engine class for converting a ColumnInfo and all the data in it into ANO equivalents (See ColumnInfoToANOTableConverterUI).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Components.Anonymisation.IdentifierDumper">
            <summary>
            Anonymises data during a Data Load by dropping columns prior to it reaching the LIVE table.  This is done for all PreLoadDiscardedColumns configured
            on the TableInfo.  Depending on the PreLoadDiscardedColumn.Destination the dropped values may be stored in an 'identifier dump' database.  This is
            usually done to seperate identifiable data (patient name, dob etc) from data (prescription of drug X on date Y) or drop sensitive data entirely.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Components.CleanStrings">
            <summary>
            Pipeline component which trims all strings (removes leading and trailing whitespace) and turns blank strings into proper nulls (DBNull.Value).  Columns
            are only processed if they are destined to go into a char field in the database (According to the TableInfo being processed).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Components.RemoveDuplicates">
            <summary>
            PipelineComponent which removes 100% duplicate rows from a DataTable during Pipeline execution based on row hashes.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Engine.Pipeline.Components.RemoveDuplicates.NoLogging">
            <summary>
            Turns off notify messages about number of duplicates found/replaced
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Pipeline.Components.RemoveDuplicates.GetHashCode(System.Object[])">
            <summary>
            Gets the hash code for the contents of the array since the default hash code
            for an array is unique even if the contents are the same.
            </summary>
            <remarks>
            See Jon Skeet (C# MVP) response in the StackOverflow thread 
            http://stackoverflow.com/questions/263400/what-is-the-best-algorithm-for-an-overridden-system-object-gethashcode
            </remarks>
            <param name="array">The array to generate a hash code for.</param>
            <returns>The hash code for the values in the array.</returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Destinations.DataTableUploadDestination">
            <summary>
            Pipeline component (destination) which commits the DataTable(s) (in batches) to the DiscoveredDatabase (PreInitialize argument).  Supports cross platform 
            targets (MySql , Sql Server etc).  Normally the SQL Data Types and column names will be computed from the DataTable and a table will be created with the
            name of the DataTable being processed.  If a matching table already exists you can choose to load it anyway in which case a basic bulk insert will take 
            place.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Pipeline.Destinations.DataTableUploadDestination.ClearPrimaryKeyFromDataTableAndExplicitWriteTypes(System.Data.DataTable)">
            <summary>
            Clears the primary key status of the DataTable / <see cref="P:Rdmp.Core.DataLoad.Engine.Pipeline.Destinations.DataTableUploadDestination.ExplicitTypes"/>.  These are recorded in <see cref="F:Rdmp.Core.DataLoad.Engine.Pipeline.Destinations.DataTableUploadDestination._primaryKey"/> and applied at Dispose time
            in order that primary key in the destination database table does not interfere with ALTER statements (see <see cref="M:Rdmp.Core.DataLoad.Engine.Pipeline.Destinations.DataTableUploadDestination.ResizeColumnsIfRequired(System.Data.DataTable,ReusableLibraryCode.Progress.IDataLoadEventListener)"/>)
            </summary>
            <param name="toProcess"></param>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Pipeline.Destinations.DataTableUploadDestination.AddExplicitWriteType(System.String,System.String,FAnsi.Discovery.ISupplementalColumnInformation)">
            <summary>
            Declare that the column of name columnName (which might or might not appear in DataTables being uploaded) should always have the associated database type (e.g. varchar(59))
            The columnName is Case insensitive.  Note that if AllowResizingColumnsAtUploadTime is true then these datatypes are only the starting types and might get changed later to
            accomodate new data.
            </summary>
            <param name="columnName"></param>
            <param name="explicitType"></param>
            <param name="columnFlags"></param>
            <returns>The Column Request that has been added to the array</returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Destinations.SqlBulkInsertDestination">
            <summary>
            Bulk inserts data into an (already existing) table, one chunk at a time
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Sources.DbDataCommandDataFlowSource">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Pipeline.Sources.DbDataCommandDataFlowSource.ReadOneRow">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.Sources.IDbDataCommandDataFlowSource">
            <summary>
            Reads records in Batches (of size BatchSize) from the remote database (DbConnectionStringBuilder builder) by executing the specified _sql.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Engine.Pipeline.Sources.IDbDataCommandDataFlowSource.ReadOneRow">
            <summary>
            Reads and returns a single row.  GetChunk must have been called at least once to function
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Engine.Pipeline.UploadFileUseCase">
            <summary>
            Describes the use case of uploading a <see cref="T:System.IO.FileInfo"/> to a target database server.  Compatible pipelines for achieving this must have a destination
            of (or inheriting from) <see cref="T:Rdmp.Core.DataLoad.Engine.Pipeline.Destinations.DataTableUploadDestination"/> and a source that implements IPipelineRequirement&lt;FlatFileToLoad&gt;.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.ExitCodeType">
            <summary>
            Final code a Data Load exits with
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.ExitCodeType.Success">
            <summary>
            The load was succesful, there should be new/updated rows in the live database
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.ExitCodeType.Error">
            <summary>
            The load failed, no new data should be in live (Due to the RAW=>STAGING=>LIVE containment system).
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.ExitCodeType.Abort">
            <summary>
            The load was cancelled mid way through by the user or a load component in an unexpected manner
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.ExitCodeType.OperationNotRequired">
            <summary>
            The load was ended mid way through by a load component which decided the load wasn't required after all (e.g. an FTP 
            server was empty).  This is considered to be a clean shutdown and not an error.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.AnySeparatorFileAttacher">
            <summary>
            Data load component for loading flat files into RAW tables (flat files must be delimited by a specific character (or sequence) e.g. csv)
            
            <para>Allows you to load zero or more flat files which are delimited by a given character or sequence of characters.  For example comma
             separated (use Separator ',') or Tab separated (Use Separator '\t').
            </para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.DelimitedFlatFileAttacher">
            <summary>
            See AnySeparatorFileAttacher
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.ExcelAttacher">
            <summary>
            Data load component for loading Microsoft Excel files into RAW tables.  This class relies on pipeline source component ExcelDataFlowSource for the actual
            reading and handles only the rationalisation of columns read vs RAW columns available.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.FixedWidthAttacher">
            <summary>
            Data load component for loading 'fixed width' files into RAW tables.  Fixed width files are those where there are no separators in the file and columns
            are instead denoted by the character position in the line e.g. 'first 10 characters of a line are patient identifier, next 8 are date of birth etc'. In 
            such a file all lines should be equal length and whitespace should be included in field values to ensure this.  Fixed width files are common in ancient
            lab systems and places where large volumes of data are outputted.
            
            <para>To use this attacher you will need a 'FormatFile' which describes the length/type of each field (See FixedWidthFormatFile).</para>
            
            <para>The width of the file MUST match exactly the width of the data table being loaded - although the table may contain varchar columns in which case the 
            max width specified on the varchar will be assumed as the width of the flat file column e.g. varchar(5) will be mapped to column width of 5</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.Attachers.FixedWidthAttacher.IterativelyBatchLoadDataIntoDataTable(System.Data.DataTable,System.Int32)">
            <summary>
            
            </summary>
            <param name="destination"></param>
            <param name="maxBatchSize"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.FixedWidthFormatFile">
            <summary>
            User generated file describing the layout of a fixed width file (See FixedWidthAttacher).  Includes the character positions of each named field and date
            format (where applicable).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.FlatFileAttacher">
            <summary>
            Base class for an Attacher which expects to be passed a Filepath which is the location of a textual file in which values for a single DataTable are stored
             (e.g. csv or fixed width etc).  This attacher requires that the RAW database server be setup and contain the correct tables for loading (it is likely that 
            the DataLoadEngine handles all this - as a user you dont need to worry about this).
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.Attachers.FlatFileAttacher.ConfirmFlatFileHeadersAgainstDataTable(System.Data.DataTable,Rdmp.Core.DataLoad.Engine.Job.IDataLoadJob)">
            <summary>
            DataTable dt is a copy of what is in RAW, your job (if you choose to accept it) is to look in your file and work out what headers you can see
            and then complain to job (or throw) if what you see in the file does not match the RAW target
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.Attachers.FlatFileAttacher.IterativelyBatchLoadDataIntoDataTable(System.Data.DataTable,System.Int32)">
            <summary>
            
            </summary>
            <param name="dt"></param>
            <param name="maxBatchSize"></param>
            <returns>return the number of rows read, if you return >0 then you will be called again to get more data (if during this second or subsequent call there is no more data to read from source, return 0)</returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.KVPAttacher">
            <summary>
            Data load component for loading very wide files into RAW tables by translating columns into key value pairs.  Relies on a user configured pipeline for
            reading from the file (so it can support csv, fixed width, excel etc).  Once the user configured pipeline has read a DataTable from the file (which is
            expected to have lots of columns which might be sparsely populated or otherwise suitable for key value pair representation rather than traditional 
            relational/flat format.
            
            <para>Component converts each DataTable row into one or more rows in the format pk,key,value where pk are the column(s) which uniquely identify the source
            row (e.g. Labnumber).  See KVPAttacher.docx for a full explanation.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.KVPAttacherPipelineUseCase">
            <summary>
            Use case for the user configured pipeline for reading from a flat file.  Used by KVPAttacher (See KVPAttacher) to allow the user control over how the 
            source file format is read (e.g. csv, fixed width, excel etc).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.MDFAttacher">
            <summary>
            Data load component for loading a detatched database file into RAW.  This attacher does not load RAW tables normally (like AnySeparatorFileAttacher etc)
            instead it specifies that it is itself going to act as RAW.  Using this component requires that the computer running the data load has file system access
            to the RAW Sql Server data directory (and that the path is the same).
            
            <para>The mdf file will be copied to the Sql Server data directory of the RAW server and attached with the expected name of RAW.  From this point on the load
            will function normally.  It is up to the user to ensure that the table names/columns in the attached MDF match expected LIVE tables on your server (or 
            write AdjustRAW scripts to harmonise).</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.MdfFileAttachLocations">
            <summary>
            Container class for recording the various directories involved in attaching a microsoft database file (MDF) to an Sql Server Instance.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.RemoteDatabaseAttacher">
            <summary>
            Data load component for loading RAW tables with records read from a remote database server. 
            Fetches all table from the specified database to load all catalogues specified.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Attachers.RemoteTableAttacher">
            <summary>
            Data load component for loading RAW tables with records read from a remote database server.  Runs the specified query (which can include a date parameter)
            and inserts the results of the query into RAW. 
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowDestinations.DoNothingCacheDestination">
            <summary>
            Cache destination component which creates 10 files, one per minute, in the CacheDirectory. It can use a DoNothingCacheChunk if told to run multiple runs.
            It will respect Stop and Abort commands. Can be used by user to build a caching pipeline even when there is nothing to do.  Basically wraps
            BasicCacheLayout so that you can read from the cache even though you have no valid pipeline for writing to it.  Use this destination only if you have
            some bespoke process for populating / updating the cache progress and you only want a caching pipeline to exist for validation reasons not to actually
            run it.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowOperations.Aliases.AliasHandler">
            <summary>
            Pipeline component for resolving the situation where a given unique patient identifier isn't unique (i.e. a person has aliases) by applying an
            AliasResolutionStrategy (See AliasHandler.docx)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowOperations.Aliases.Exceptions.AliasException">
            <summary>
            Exception thrown by pipeline component AliasHandler when the AliasResolutionStrategy is CrashIfAliasesFound and Aliases exist for one or more records
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowOperations.Aliases.Exceptions.AliasTableFetchException">
            <summary>
            Exception thrown by AliasHandler when it is unable to reach the Alias fact table (See AliasHandler class and AliasHandler.docx).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowOperations.ColumnBlacklister">
            <summary>
            Pipeline component designed to prevent unwanted data existing within DataTables passing through the pipeline.  The component will crash the entire pipeline
            if it sees columns which match the blacklist.  Use cases for this include when the user wants to prevent private identifiers being accidentally released
            due to system misconfiguration e.g. you might blacklist all columns containing the strings starting "Patient" on the grounds that they are likely to be
            identifiable (PatientName, PatientDob etc).
            
            <para>Crashes the pipeline if any column matches the regex e.g. '^(mCHI)|(chi)$'</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowOperations.ColumnRenamer">
            <summary>
            Pipeline component for renaming a single column in DataTables passing through the component.
            <para>Renames a column with a given name to have a new name e.g. 'mCHI' to 'CHI'</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowOperations.ExtractCatalogueMetadata">
            <summary>
            Extraction component that will generate share definition files for the catalogues involved in the extraction.
            
            <para>The Metadata Naming Pattern will also override the table name in the DataTable flow object.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowOperations.ReleaseMetadata">
            <summary>
            Data release pipeline component which generates <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/> files for all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> being
            extracted.  These contain the dataset and column descriptions in a format that can be loaded by any remote RDMP instance via ExecuteCommandImportShareDefinitionList.
            
            <para>This serialization includes the allocation of SharingUIDs to allow for later updates and to prevent duplicate loading in the destination.  In addition it handles
            system boundaries e.g. it doesn't serialize <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata"/> of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> or other deployment specific objects</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowOperations.Swapping.ColumnSwapper">
            <summary>
            Swaps values stored in a given column for values found in a mapping table (e.g. swap ReleaseID for PrivateID)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowOperations.TableVersionNamer">
            <summary>
            Renames DataTables in the pipeline so that they do not collide with any tables at the destination database.  This is done by appending V1,V2,V3 etc to the table
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowOperations.Transposer">
            <summary>
            Pipeline component which rotates DataTables flowing through it by 90 degrees such that the first column becomes the new headers.  Only use this if you have
            been given a file in which proper headers are vertical down the first column and records are subsequent columns (i.e. adding new records results in the 
            DataTable growing horizontally).
            
            <para>IMPORTANT: Only works with a single load batch if you have a chunked pipeline you cannot use this component unless you set the chunk size large enough
            to read the entire file in one go
            </para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.DelimitedFlatFileDataFlowSource">
            <summary>
            Pipeline component (source) for reading from a flat file delimited by by a specific character (or string) e.g. csv.  The file is batch processed into
            DataTables of size MaxBatchSize (to avoid memory problems in large files).
            
            <para>Values read are fed into the pipeline as a DataTable with the Name of the DataTable being the name of the file being read.  Example usage would 
            be setting the separator to , to read CSV files.</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.DelimitedFlatFileDataFlowSource._workingTable">
            <summary>
            The database table we are trying to load
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.DelimitedFlatFileDataFlowSource._fileToLoad">
            <summary>
            File we are trying to load
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.DelimitedFlatFileDataFlowSource._prohibitedExtensions">
            <summary>
            things we know we definetly cannot load!
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.DelimitedFlatFileDataFlowSource._lineNumberBatch">
            <summary>
            Used to split the records read into chunks to avoid running out of memory
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.DelimitedFlatFileDataFlowSource.HackValueReadFromFile(System.String)">
            <summary>
            Override this if you want to mess with values as they are read from the source file in some freaky way.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.DelimitedFlatFileDataFlowSource.SetDataTable(System.Data.DataTable)">
            <summary>
            Sets the target DataTable that we are loading from the csv/tsv etc
            </summary>
            <param name="dt"></param>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.DoNothingCacheSource">
            <summary>
            Cache source component which does nothing.  Can be used by user to build a caching pipeline even when there is nothing to do.  Use this source only if
            you have some bespoke process for populating / updating the cache progress and you only want a caching pipeline to exist for validation reasons not to
            actually run it.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.ExcelDataFlowSource">
            <summary>
            Pipeline component for reading from Microsoft Excel files.  Reads only from a single worksheet (by default the first one in the workbook).  Data read
            is returned as a DataTable all read at once in one big batch.  This component requires Microsoft Office to be installed since it uses Interop.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.ExcelDataFlowSource.GetAllData(NPOI.SS.UserModel.ISheet,ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Returns all data held in the current <paramref name="worksheet"/>.  The first row of data becomes the headers.  Throws away fully blank columns/rows.
            </summary>
            <param name="worksheet"></param>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.ExcelDataFlowSource.GetCellValue(NPOI.SS.UserModel.ICell,NPOI.SS.UserModel.CellType)">
            <summary>
            Retruns the C# value that best represents the contents of the cell.
            </summary>
            <param name="cell">The cell whose value you want to retrieve</param>
            <param name="treatAs">Leave blank, used in recursion for dealing with Formula cells</param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.ExplicitTypingCollection">
            <summary>
            A collection of column names with explicitly defined column types that the user wants to force where present.  e.g. they loading a CSV and they get values 
            "291","195" but they know that some codes are like "012" and wish to preserve this leading 0s so they can explicitly define the column as being a string.
            
            <para>This class can be used by [DemandsInitialization] properties and it will launch it's custom UI: ExplicitTypingCollectionUI</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.ExplicitTypingCollection.ExplicitTypesCSharp">
            <summary>
            A dictionary of names (e.g. column names) which must have specific C# data types
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.ExplicitTypingCollection.RestoreStateFrom(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.ExplicitTypingCollection.SaveStateToString">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection">
            <summary>
            This class is a sub component of <see cref="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.DelimitedFlatFileDataFlowSource"/>, it is responsible for processing the headers (or overriding headers) 
            of a CSV (TSV etc) file.
            
            <para>The component has two main operational modes after it has read headers: <see cref="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection.GetDataTableWithHeaders(ReusableLibraryCode.Progress.IDataLoadEventListener)"/> and  <see cref="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection.MakeDataTableFitHeaders(System.Data.DataTable,ReusableLibraryCode.Progress.IDataLoadEventListener)"/></para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection.IgnoreColumnsList">
            <summary>
            The columns from the file the user does not want to load into the destination (this will not help 
            you avoid bad data).
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection._headers">
            <summary>
            The Headers found in the file / overridden by ForceHeaders
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection.UnamedColumns">
            <summary>
            Column headers that appear in the middle of the file (i.e. not trailing) but that don't have a header name.  These get thrown away
            and they must never have data in them.  This lets you have a full blank column in the middle of your file e.g. if you have inserted
            it via Excel
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection._commonSeparators">
            <summary>
            used to advise user if he has selected the wrong separator
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection.CountNotNull">
            <summary>
            Counts the number of headers that are not null
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection.Length">
            <summary>
            The number of headers including null ones (but not trailing null headers)
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection.GetDataTableWithHeaders(ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Creates a new empty DataTable has only the columns found in the headers that were read during <see cref="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection.GetHeadersFromFile(CsvHelper.CsvReader)"/>
            </summary>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection.MakeDataTableFitHeaders(System.Data.DataTable,ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Takes an existing DataTable with a fixed schema and validates the columns read during <see cref="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection.GetHeadersFromFile(CsvHelper.CsvReader)"/> against it making minor changes
            where appropriate to match the schema
            </summary>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection.ShowForceHeadersAsciiArt(System.String[],ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Use only when ForceHeaders is on and ForceHeadersReplacesFirstLineInFile is true.  Pass the header line that was read from the file
            that will be ignored (<paramref name="strings"/>).  This method will show the user what replacements were made.
            </summary>
            <param name="strings"></param>
            <param name="listener"></param>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileEventHandlers">
            <summary>
            This class is a sub component of <see cref="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.DelimitedFlatFileDataFlowSource"/>, it is responsible for responding to errors processing the file
            being loaded according to the <see cref="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.BadDataHandlingStrategy"/>. It also includes settings for how to respond to empty files.
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileEventHandlers.DivertErrorsFile">
            <summary>
            File where we put error rows
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileLine">
            <summary>
            Point in time record of a line read from CsvHelper including ReadingContext information such as <see cref="P:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileLine.LineNumber"/>.  Can include multiple lines
            of the underlying file if there is proper qualifying quotes and newlines in the csv e.g. when including free text columns.
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileLine.LineNumber">
            <summary>
            The RAW file line number that this line reflects.  Where a record spans multiple lines (e.g. when it has newlines in quote qualified fields) it 
            seems to be the last line number in the record
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileLine.Cells">
            <summary>
            The values as interpreted by CsvHelper for the current line
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileLine.RawRecord">
            <summary>
            The absolute text as it appears in the flat file being read for this 'line'
            </summary>
        </member>
        <member name="P:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileLine.ReadingContext">
            <summary>
            The state of the CSVReader when the line was read
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileToDataTablePusher">
            <summary>
            This class is a sub component of <see cref="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.DelimitedFlatFileDataFlowSource"/>, it is responsible for adding rows read from the CSV file to
            the DataTable built by <see cref="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileColumnCollection"/>.
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileToDataTablePusher.PeekedRecord">
            <summary>
            Used in the event of reading too few cells for the current line.  The pusher will peek at the next lines to see if they
            make up a coherent row e.g. if a free text field is splitting up the document with newlines.  If the peeked lines do not
            resolve the problem then the line will be marked as BadData and the peeked records must be reprocessed by <see cref="T:Rdmp.Core.DataLoad.Modules.DataFlowSources.DelimitedFlatFileDataFlowSource"/>
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileToDataTablePusher.BadLines">
            <summary>
            All line numbers of the source file being read that could not be processed.  Allows BadDataFound etc to be called multiple times without skipping
            records by accident.
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileToDataTablePusher._bufferOverrunsWhereColumnValueWasBlank">
            <summary>
            This is incremented when too many values are read from the file to match the header count BUT the values read were null/empty
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.DataFlowSources.SubComponents.FlatFileToDataTablePusher._haveComplainedAboutColumnMismatch">
            <summary>
            We only complain once about headers not matching the number of cell values
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataProvider.DoNothingDataProvider">
            <summary>
            IDataProvider that announces itself to the event stream during data load Fetch but otherwise does nothing.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataProvider.FlatFileManipulation.ExcelToCSVFilesConverter">
            <summary>
            DLE component which converts Microsoft Excel Workbooks into CSV files.  Workbooks can have multiple worksheets in which case 1 csv will be created for
            each worksheet.  Uses Interop to SaveAs csv format so runs faster for large / complex workbooks than using an ExcelAttacher.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataProvider.ImportFilesDataProvider">
             <summary>
             Data load component that copies files into the ForLoading directory from the remote directory (that match the file pattern e.g. *.csv).  A good use case
             for this is if you want to expose a network location as a share for data provders to send you files to but want the DLE to take a copy of the files at 
             runtime for the purposes of loading.
            
             <para>Optionally deletes files from the fetch location if the data load is successful</para>
             </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataProvider.ShareDefinitionImporter">
            <summary>
            Data Provider Process Task for DLE which will look for *.sd files and import them into RDMP
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.DataProvider.WebServiceConfiguration">
            <summary>
            Describes a website / webservice endpoint which can be accessed with an optional username / password.  Use this Type when you need a [DemandsInitialization]
            property on a component (e.g. IAttacher) which is a remote website/webservice.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.DataProvider.WebServiceConfiguration.#ctor">
            <summary>
            For XML Serialization
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Exceptions.FlatFileLoadException">
            <summary>
            Thrown by flat file reading components (e.g. DelimitedFlatFileDataFlowSource) when there is a structural problem with the file (e.g. 3 headers and 3 cells
            per line but suddenly 4 cells appear on line 30).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Exceptions.MultipleMatchingFilesException">
            <summary>
            Thrown when a file pattern expected to identify only a single file matches multiple files.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.FileOperations.FileUnzipper">
            <summary>
            load component which Unzips files in ForLoading
            <para>Searches the forLoading directory for *.zip and unzips all entries in all zip archives found.  If the forLoading directory already contains a file with the same name then 
            it is overwritten (unless the file size is also the same in which case the entry is skipped)</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.FTP.FTPDownloader">
            <summary>
            load component which downloads files from a remote FTP server to the ForLoading directory
            
            <para>Attempts to connect to the FTP server and download all files in the landing folder of the FTP (make sure you really want everything in the
             root folder - if not then configure redirection on the FTP so you land in the correct directory).  Files are downloaded into the ForLoading folder</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.FTP.SFTPDownloader">
            <summary>
            load component which downloads files from a remote SFTP (Secure File Transfer Protocol) server to the ForLoading directory
            
            <para>Operates in the same way as <see cref="T:Rdmp.Core.DataLoad.Modules.FTP.FTPDownloader"/> except that it uses SSH.  In addition this 
            class will not bother downloading any files that already exist in the forLoading directory (have the same name - file size is NOT checked)</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.LoadProgressUpdating.DataLoadProgressUpdateInfo">
            <summary>
            Represents a user made descision about how to upload a LoadProgress after a succesful data load.  LoadProgress has a field DataLoadProgress which stores
            the last date that was loaded.  However you can overreach during a load e.g. run a load for 30 days but find only 5 days worth of data streamed through 
            the load, in such cases you might want to update the DataLoadProgress to the 5 day mark on the assumption that there is a delay in data provision and it
            will arrive later.  There are multiple ways to determine what dates were actually loaded during a data load (See DataLoadProgressUpdateStrategy). 
            
            <para>You can declare a [DemandsInitialization] decorated property of this Type in a data load component (IAttacher) etc in order to illicit a decision about
            what to update the DataLoadProgress with from the user at design time.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.LoadProgressUpdating.DataLoadProgressUpdateInfo.AddAppropriateDisposeStep(Rdmp.Core.DataLoad.Engine.Job.Scheduling.ScheduledDataLoadJob,FAnsi.Discovery.DiscoveredDatabase)">
            <summary>
            Only call this method when you hav finished populating RAW (since the strategy ExecuteScalarSQLInRAW requires to calculate date from populated RAW database right now and it is known that RAW won't even exist post load time)
            </summary>
            <param name="job"></param>
            <param name="rawDatabase"></param>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.LoadProgressUpdating.DataLoadProgressUpdateStrategy">
            <summary>
            Approaches user/system can use to determine what Date to update a LoadProgress to after a succesful data load (See UpdateProgressIfLoadsuccessful for 
            description of why this is non trivial).
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.LoadProgressUpdating.DataLoadProgressUpdateStrategy.UseMaxRequestedDay">
            <summary>
            Regardless of what data actually flowed through the data load, always use the maximum requested date 
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.LoadProgressUpdating.DataLoadProgressUpdateStrategy.ExecuteScalarSQLInRAW">
            <summary>
            Run a piece of SQL in the RAW environment after AdjustRAW has completed to determine what the maximum date where data was available.
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.LoadProgressUpdating.DataLoadProgressUpdateStrategy.ExecuteScalarSQLInLIVE">
            <summary>
            Run a piece of SQL in the LIVE environment after the data load has completed to determine what the maximum date where data was available. 
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.LoadProgressUpdating.DataLoadProgressUpdateStrategy.DoNothing">
            <summary>
            Do not update the DataLoadProgress at all after succesfully load.  This might result in repeatedly loading the same batch of dates over and
            over if you are running an IterativeScheduledDataLoadProcess
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.LoadProgressUpdating.UpdateProgressToResultOfDelegate">
            <summary>
            UpdateProgressIfLoadsuccessful which executes an arbitrary Func in order to determine what date to update the LoadProgress.DataLoadProgress to 
            (See UpdateProgressIfLoadsuccessful).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.LoadProgressUpdating.UpdateProgressToSpecificValueIfLoadsuccessful">
            <summary>
            UpdateProgressIfLoadsuccessful which uses a fixed 'specificValue' to update the LoadProgress.DataLoadProgress to 
            (See UpdateProgressIfLoadsuccessful).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.BackupDatabaseMutilation">
             <summary>
             Creates a database backup of the LIVE database which contains the specified TableInfo.  Do a test of this component with your server/user configuration
             before assuming it will simply work and writing anything drastic.
            
             <para>This mutilation should only be put into AdjustStaging otherwise it will fill up your backup storage as debug load errors in RAW and Migration to STAGING</para>
             </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.Coalescer">
            <summary>
            Resolves primary key collisions that are the result of non primary key fields being null in some records and not null in others (where primary keys of those records
            are the same).  Or to put it simpler, resolves primary key collisions by making records less null.  This can only be applied in the Adjust RAW stage of a data load.
            This creates deviation from ground truth of the data you are loading and reducing nullness might not always be correct according to your data.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.Dilution.Dilution">
            <summary>
            load component responsible for diluting data.  For example data might be diluted from date of birth to a bit flag indicating only whether it is known or 
            not (alternatively it might round the date to the first of the month etc).  This mutilation occurs after migration from RAW to STAGING (at which point
            the undiluted values will have been stored in the IdentifierDump).  The mutilation might change the data type of the column (e.g. from date to bit in the
            above example) based on the user specified IDilutionOperation.
            
            <para>This operation MUST only appear in AdjustStaging.  It works in concert with <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn"/>s.  Create a PreLoadDiscardedColumn 
            with Destination=Dilution, this operation can then be used to mutilate the value (for example cutting off the ends of postcodes).  The pristene (un-mutilated)
            value will be stored in the IdentifierDump along with all the other dumped columns but the LIVE will also contain the mutilated value</para>
            
            <para>Checking for this component is quite good and should detect incompatible Types (where LIVE column does not match the IDilutionOperation), missing columns
            / dump server configuration etc.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.Dilution.DilutionOperationFactory">
            <summary>
            Creates IDilutionOperations by reflection based on Type name and hydrates with the target IPreLoadDiscardedColumn.  See Dilution.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.Dilution.Exceptions.DilutionColumnNotSetException">
            <summary>
            Thrown when you try to use a DilutionOperation when the target ColumnToDilute has not been set.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.Dilution.Operations.CrushToBitFlag">
            <summary>
             Dilutes data in the ColumnToDilute by replacing all non null values with 1 and all null values with 0 then alters the column type to bit
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.Dilution.Operations.DilutionOperation">
            <summary>
            See IDilutionOperation
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.Dilution.Operations.ExcludeRight3OfUKPostcodes">
            <summary>
            Dilutes data in the ColumnToDilute which is expected to contain postcodes by replacing stripping the last 3 digits such that DD3 7LX becomes DD3.
            See TestExcludeRight3OfUKPostcodes for expected inputs/outputs.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.Dilution.Operations.IPluginDilutionOperation">
            <summary>
            MEF discoverable version of IDilutionOperation
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.Dilution.Operations.RoundDateToMiddleOfQuarter">
            <summary>
             Dilutes data in the ColumnToDilute by rounding all dates to the middle of the quarter they appear in (column type must be date and is not changed by
            this DilutionOperation). Data type of column must be date and will not be changed by this DilutionOperation.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.Distincter">
            <summary>
            This component will make all tables matching the <see cref="P:Rdmp.Core.DataLoad.Modules.Mutilators.MatchingTablesMutilator.TableRegexPattern"/> distinct.  It should only be run in RAW.
            
            <para>The RAW=>STAGING migration will already take care of identical records.  This means this component is only useful for
            debugging failed RAW batches or running SQL that is intented to resolve PK collisions / data integrity issues where identical 
            duplicates make the process slow / difficult.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.PrematureLoadEndCondition">
            <summary>
            Conditions under which a PrematureLoadEnder should decide to end the ongoing load early
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.Mutilators.PrematureLoadEndCondition.Always">
            <summary>
            As soon as the PrematureLoadEnder is hit the load should be stopped
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.Mutilators.PrematureLoadEndCondition.NoRecordsInAnyTablesInDatabase">
            <summary>
            Stop the load if there are no records in any database tables in the current stage (e.g. if PrematureLoadEnder is at AdjustRAW stage then the
            load will end if there are no records in any tables in RAW).
            </summary>
        </member>
        <member name="F:Rdmp.Core.DataLoad.Modules.Mutilators.PrematureLoadEndCondition.NoFilesInForLoading">
            <summary>
            Stop the load if there are no files in the ForLoading directory of the current load when the PrematureLoadEnder component is hit
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.PrematureLoadEnder">
            <summary>
            load component which can stop an ongoing load early if a given PrematureLoadEndCondition is met with a given ExitCodeType.
            
            <para>Conditionally ends the data load early if a given set of circumstances occurs e.g. you might choose to return LoadNotRequired if there are no records in RAW</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.PrimaryKeyCollisionResolverMutilation">
            <summary>
            Data load component which can delete records in an (unconstrained) RAW table to enforce uniqueness of the primary key field (as it is configured in LIVE).
            This lets you resolve non-exact duplication based on column order (e.g. if there is a collision where one has an later 'DataAge' field then use the later
            one and discard the earlier one.
            
             <para>This is a very dangerous operation which uses the primary key collision resolution order (Accessible through CatalogueManager by right clicking a
            TableInfo and choosing 'Configure Primary Key Collision Resolution') to delete records in a preferred order, fully eliminating primary key collisions.  
            It is a very good idea to not have this task until you are absolutely certain that your primary key is correct and that the duplicate records being deleted
            are the correct decisions e.g. delete an older record in a given load batch and not simply erasing vast swathes of data!.  The Data Load Engine will tell 
            you with a warning when records are deleted and how many.  If you notice a lot of deletion then try removing this component and manually inspecting the data 
            in the RAW database after the data load fails (due to unresolved primary key conflicts)</para>
            
            <para>This component requires that a collision resolution order has been configured on the TableInfo (See ConfigurePrimaryKeyCollisionResolution)</para>
            
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.QueryBuilders.BackfillSqlHelper">
            <summary>
            Helps generate sql queries for reverting/deleting STAGING based on records in LIVE during a backfill data load (See StagingBackfillMutilator).
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.Mutilators.QueryBuilders.BackfillSqlHelper.CreateSqlForJoinToTimePeriodicityTable(System.String,Rdmp.Core.CatalogueLibrary.Data.ITableInfo,System.String,FAnsi.Discovery.DiscoveredDatabase,System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.JoinInfo})">
            <summary>
            Composes the SQL which joins the supplied table back up or down to the TimePeriodicity table, so we can assign the rows an effective load date
            </summary>
            <param name="tableAlias"></param>
            <param name="tableInfo"></param>
            <param name="timePeriodTableAlias"></param>
            <param name="dbInfo"></param>
            <param name="joinPath"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.SafePrimaryKeyCollisionResolverMutilation">
            <summary>
            Attempts to resolves primary key collisions by ordering on a specific column and deleting rows which differ on this column
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.StagingBackfillMutilator">
            <summary>
            Deletes records in STAGING which are 'older' versions of records that currently exist in LIVE.  Normally RMDP supports a 'newer is better' policy in which
            all records loaded in a DLE run automatically replace/add to the LIVE table based on primary key (i.e. a newly loaded record with pk X will result in an 
            UPDATE of the values for that record to the new values in STAGING that are being loaded).
            
            <para>This component is designed to support loading periods of old data into a LIVE data table that has moved on (i.e. to backfill a dataset) without 
            overwritting newer versions of a record (with primary key x) with old.  For example it is 2011 and you have found a year of data you forgot to load back
            in 2009 but you expect that since 2009 there have been historical record updates for records originally generated in 2009 (you want to load all 2009 records
            from the historical batch except where there has been an update since).</para>
            
            <para>This is done by selecting a 'TimePeriodicity' field that identifies the 'dataset time' of the record (as opposed to the load time) e.g. 'date blood sample
             taken'.  STAGING records will be deleted where there are records in LIVE wich  have the same primary key but a newer TimePeriodicity date.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.Mutilators.StagingBackfillMutilator.GetLiveDatabaseInfo">
            <summary>
            Get the database credentials for the Live server, accessing them via the TimePeriodicityField ColumnInfo
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.Mutilators.StagingBackfillMutilator.ProcessPredecessors(Rdmp.Core.CatalogueLibrary.Data.TableInfo,System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.JoinInfo})">
            <summary>
            Ascends join tree from the TimePeriodicity table, processing tables at each step
            </summary>
            <param name="tiCurrent"></param>
            <param name="joinPathToTimeTable"></param>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.Mutilators.StagingBackfillMutilator.ProcessOldUpdatesInTable(Rdmp.Core.CatalogueLibrary.Data.TableInfo,System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.JoinInfo})">
            <summary>
            Descends to leaves of join tree, then processes tables on way back up
            </summary>
            <param name="tiCurrent"></param>
            <param name="joinPathToTimeTable"></param>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.Mutilators.StagingBackfillMutilator.ProcessTable(Rdmp.Core.CatalogueLibrary.Data.ITableInfo,System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.JoinInfo},System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.JoinInfo})">
            <summary>
            Deletes any rows in tiCurrent that are out-of-date (with respect to live) and childless, then updates remaining out-of-date rows with the values from staging.
            Out-of-date remaining rows will only be present if they have children which are to be inserted. Any other children will have been deleted in an earlier pass through the recursion (since it starts at the leaves and works upwards).
            </summary>
            <param name="tiCurrent"></param>
            <param name="joinPathToTimeTable">Chain of JoinInfos back to the TimePeriodicity table so we can join to it and recover the effective date of a particular row</param>
            <param name="childJoins"></param>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.Mutilators.StagingBackfillMutilator.GetCurrentOldEntriesSQL(Rdmp.Core.CatalogueLibrary.Data.ITableInfo,System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.JoinInfo})">
            <summary>
            This and GetLiveDataToUpdateStaging are ugly in that they just reflect modifications to the comparison CTE. Leaving for now as a more thorough refactoring may be required once the full test suite is available.
            </summary>
            <param name="tiCurrent"></param>
            <param name="joinPathToTimeTable"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Modules.Mutilators.StagingBackfillMutilator.GetLiveDataToUpdateStaging(Rdmp.Core.CatalogueLibrary.Data.ITableInfo,System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.JoinInfo})">
            <summary>
            This and GetCurrentOldEntriesSQL are ugly in that they just reflect modifications to the comparison CTE. Leaving for now as a more thorough refactoring may be required once the full test suite is available.
            </summary>
            <param name="tiCurrent"></param>
            <param name="joinPathToTimeTable"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Mutilators.TableVarcharMaxer">
            <summary>
            Widens columns on the specified table to be varchar(max).  This is useful for delaying truncation errors till later in the load.  For example if you
            apply a TableVarcharMaxer as a Mounting operation before loading data into it with an IAttacher you can have all the data loaded succesfully into RAW where
            it can be interrogated with SQL to find out what the truncated fields are and what to do about them.
            
            <para>Remember that RAW and STAGING are created based on the LIVE table schema (but that RAW has no column constraints like pks or not null fields).  This
            component lets you further relax the structure of RAW to have varchar(max) column datatypes.  The load will still crash when it comes to migration to 
            STAGING or merging with LIVE because the datatypes are not valid according to LIVE but you will have an easier time debugging than trying to look through
            a flat file for problematic values.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Modules.Web.WebFileDownloader">
            <summary>
            Data load component which downloads a file from a remote URL (e.g. http) into the ForLoading directory of the load.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Triggers.DiffDatabaseDataFetcher">
            <summary>
            Calculates the changes that occured during a given DLE execution (identified by the unique DataLoadRunID of the load).  This involves generating and running SELECT
            queries that merge _Archive and live tables data to produce 3 DataTables Inserts and Updates (2 tables - New and Replaced).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Triggers.Exceptions.IrreconcilableColumnDifferencesInArchiveException">
            <summary>
            Thrown when an _Archive table does not match the live table (See TriggerImplementer)
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Triggers.Exceptions.TriggerException">
            <summary>
            Exception describing a problem with a backup trigger <see cref="T:Rdmp.Core.DataLoad.Triggers.ITriggerImplementer"/> or a problem that prevents one being created etc.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Triggers.Exceptions.TriggerMissingException">
            <summary>
            Exception thrown when the DLE live table does not have the expected backup trigger that moves old (overwritten) records into the
            shadow archive table
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Triggers.Implementations.MicrosoftSQLTriggerImplementer">
            <summary>
            Creates an _Archive table to match a live table and a Database Trigger On Update which moves old versions of records to the _Archive table when the main table
            is UPDATEd.  An _Archive table is an exact match of columns as the live table (which must have primary keys) but also includes several audit fields (date it 
            was archived etc).  The _Archive table can be used to view the changes that occured during data loading (See DiffDatabaseDataFetcher) and/or generate a 
            'way back machine' view of the data at a given date in the past (See CreateViewOldVersionsTableValuedFunction method).
            
            <para>This class is super Microsoft Sql Server specific.  It is not suitable to create backup triggers on tables in which you expect high volitility (lots of frequent
            updates all the time).</para>
            
            <para>Also contains methods for confirming that a trigger exists on a given table, that the primary keys still match when it was created and the _Archive table hasn't
            got a different schema to the live table (e.g. if you made a change to the live table this would pick up that the _Archive wasn't updated).</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Triggers.Implementations.TriggerImplementer.CheckUpdateTriggerIsEnabledAndHasExpectedBody">
            <summary>
            Returns true if the trigger exists and the method body of the trigger matches the expected method body.  This exists to handle
            the situation where a trigger is created on a table then the schema of the live table or the archive table is altered subsequently.
            
            <para>The best way to implement this is to regenerate the trigger and compare it to the current code fetched from the ddl</para>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Triggers.Implementations.TriggerImplementerFactory">
            <summary>
            Handles the creation of the appropriate <see cref="T:Rdmp.Core.DataLoad.Triggers.ITriggerImplementer"/> for any given <see cref="T:FAnsi.DatabaseType"/>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Triggers.ITriggerImplementer">
            <summary>
            Handles the creation of _Archive tables and the trigger that populates them (on UPDATE) of the live data tables.  Also creates <see cref="T:Rdmp.Core.DataLoad.Triggers.SpecialFieldNames"/> fields
            in the live table to allow versioning of records created by the DLE.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Triggers.ITriggerImplementer.DropTrigger(System.String@,System.String@)">
            <summary>
            Deletes the backup trigger if any on the table the <see cref="T:Rdmp.Core.DataLoad.Triggers.ITriggerImplementer"/> is pointed at
            </summary>
            <param name="problemsDroppingTrigger"></param>
            <param name="thingsThatWorkedDroppingTrigger"></param>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Triggers.ITriggerImplementer.CreateTrigger(ReusableLibraryCode.Checks.ICheckNotifier,System.Int32)">
            <summary>
            Creates the backup trigger and associated _Archive table.  If there is already an _Archive table in place then only the trigger
            should be created
            </summary>
            <param name="notifier"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Triggers.ITriggerImplementer.GetTriggerStatus">
            <summary>
            Describes whether or not the table that the <see cref="T:Rdmp.Core.DataLoad.Triggers.ITriggerImplementer"/> is pointed at has an intact UPDATE trigger that populates
            a shadow _Archive table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Triggers.ITriggerImplementer.CheckUpdateTriggerIsEnabledAndHasExpectedBody">
            <summary>
            Confirms firstly that there is a trigger on the table (See <see cref="M:Rdmp.Core.DataLoad.Triggers.ITriggerImplementer.GetTriggerStatus"/>) Then looks at the trigger method body to confirm
            that the currently emplaced trigger matches the expected SQL if the trigger were to be created today.
            
            <para>This method helps reduce errors where the user updates the live table schema and does not also update the _Archive table.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Triggers.SpecialFieldNames">
            <summary>
            Container class for constant variables for the names of special columns required by the backup trigger (_Archive table and general DLE audit columns).
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataLoad.Triggers.TriggerChecks">
            <summary>
            Checks that the specified table has a backup trigger <see cref="T:Rdmp.Core.DataLoad.Triggers.ITriggerImplementer"/> on it.  Also inspects the _Archive table schema and compares it
            to the live schema to make sure they are compatible.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataLoad.Triggers.TriggerChecks.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.DatasetTimespanCalculator">
            <summary>
            Calculates the date range of data held in a dataset (Catalogue).  Optionally you can 'discardOutliers' this includes any dates in which there are
            1000 times less records than the non zero average month.  For example if you have 3 records in 01/01/2090 then they would be discarded if you had
             an average of 3000+ records per month (after ignoring months where there are no records).  
            
            <para>IMPORTANT: You must have run the DQE on the dataset before this class can be used and the results are based on the last DQE run on the dataset not 
            the live table</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataQualityEngine.DatasetTimespanCalculator.GetHumanReadableTimepsanIfKnownOf(Rdmp.Core.CatalogueLibrary.Data.Catalogue,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Data.ArchivalPeriodicityCount">
            <summary>
            Total number of records in any given month of a DQE evaluation which passed validation and the total number overall for that month. 
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Data.ColumnState">
            <summary>
            Runtime class for DQE used to record the number of records passing/failing validation/null for a given column in a dataset.  These counts are incremented
            during the DQE evaluation process then finally saved into the ColumnState table in DQE database.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Data.DQEGraphAnnotation">
            <summary>
            The DQE graphs in Dashboard show the states of datasets over time (every time the DQE is run - see Evaluation).  This table stores annotations that the user has added to specific
            evaluations.  For example if a dataset has a huge hole in it then the data analyst might add an arrow pointing at the hole saying 'Accidentally deleted this data, I'll replace it
            next Thursday'.  The creation date of the annotation as well as the text and the location on the graph are stored and rendered any time the user is reviewing that DQE graph.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Data.Evaluation">
            <summary>
            Root object for a DQE run including the time the DQE engine was run, the Catalogue being evaluated and all the results.  This class basically follows an 
            IMapsDirectlyToDatabaseTable/DatabaseEntity pattern except that it doesn't allow for modification/saving since a DQE run is immutable and only created after
            a succesful run.
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataQualityEngine.Data.Evaluation.#ctor(Rdmp.Core.Repositories.DQERepository,System.Data.Common.DbDataReader)">
            <summary>
            
            </summary>
            <param name="repository"></param>
            <param name="r"></param>
        </member>
        <member name="M:Rdmp.Core.DataQualityEngine.Data.Evaluation.#ctor(Rdmp.Core.Repositories.DQERepository,Rdmp.Core.CatalogueLibrary.Data.Catalogue)">
            <summary>
            Starts a new evaluation with the given transaction
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Data.PeriodicityState">
            <summary>
            Runtime class for DQE used to record the number of rows passing/failing validation/null overall.  This is calculated by validating every column in the row
            and selecting the worst validation failure Consequence (if any) for the row.
            
            <para>These counts are incremented during the DQE evaluation process then finally saved into the PeriodicityState table in DQE database.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Data.RowState">
            <summary>
            Class for inserting/retrieving records into the RowState table of the DQE database.  This table stores counts of the total number of rows (divided by
            PivotCategory - if any) passing, failing validation during a DQE run on a dataset.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Reports.CatalogueConstraintReport">
            <summary>
            Runs the DQE and populates Evaluation and sub tables with the results.  This includes counts of the number of rows / columns passing / failing validation
            nullness etc both overall and subdivided by month / pivot.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Reports.DQEStateOverDataLoadRunId">
            <summary>
            Records the total number of validation failures that occur for each column.  Results are calculated for each novel DataLoadRunId found.  The counts
            for a column will always add up to the row count even if there are multiple validation rules broken (The worst consequence only is counted).
            </summary>
        </member>
        <member name="M:Rdmp.Core.DataQualityEngine.Reports.DQEStateOverDataLoadRunId.CalculateFinalValues">
            <summary>
            Calculates the final counts for each Column based on the validation failures documented to date.  You can only call this method once and it
            must be called before committing to database.
            </summary>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Reports.IDataQualityReport">
            <summary>
            Shared interface for any DQE run implementation (currently only CatalogueConstraintReport).  Supports confirming that the report can be run on a given
            Catalogue and running it.
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Reports.LoadProgressSummaryReport">
            <summary>
            Generates two DataTable.  One containing the row counts (according to DQE) for every Catalogue in a LoadMetadata.  The second containing all cached fetch
            counts and counts of all files in the Caching directory for the CacheProgress (if any) of the LoadProgress passed into the contructor.  These tables are
            intended to assist the user in rapidly determining how much of a given dataset collection based on a cache fetch/load DLE job has currently been loaded 
            (according to the DQE).  See LoadProgressDiagram
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Reports.PeriodicityHelpers.PeriodicityCube">
            <summary>
            Records the number of records passing / failing validation with each consquence (See PeriodicityState).
            
            <para>This class handles the Consequence dimension (See PeriodicityCubesOverTime for the time aspect handling).</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.DataQualityEngine.Reports.PeriodicityHelpers.PeriodicityCubesOverTime">
            <summary>
            Accumulates counts for populating into the PeriodicityState table of the DQE.  This table contains row evaluation counts (passing / failing validation) and
            4 dimensions:
             Evaluation_ID - when in realtime the DQE was run (e.g. Evaluation run on Feb 2017)
             Year/Month - what in dataset time the result is for (e.g. biochemistry records relating to tests conducted during January 2013)
             Pivot Category - optional column value subdivision (e.g. Healthboard column is T or F)
             Row Evaluation - final dimension is one record per Consquence of failed validation (Wrong / Missing / Correct etc).
            
            <para>This class manages the time aspect as a Dictionary of year/month.  Other dimensions are managed by PeriodicityCube</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.DataLoadInfo">
            <summary>
            Root object for an ongoing logged activity e.g. 'Loading Biochemistry'.  Includes the package name (exe or class name that is primarily responsible
            for the activity), start time, description etc.  You must call CloseAndMarkComplete once your activity is completed (whether it has failed or suceeded).
            
            <para>You should maintain a reference to DataLoadInfo in order to create logs of Progress / Errors / and table load audits
            (TableLoadInfo) (create these via the LogManager).  The ID property can be used if you want to reference this audit record e.g. when loading a live table
            you can store the ID of the load batch it appeared in. </para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Logging.DataLoadInfo.#ctor(System.String,System.String,System.String,System.String,System.Boolean,FAnsi.Discovery.DiscoveredServer)">
            <summary>
            Marks the start of a new data load in the database.  Automatically populates StartTime and UserAccount from
            Environment.  Also creates a new ID in the database.
            </summary>
            <param name="packageName">The SSIS package or executable that started the data load</param>
            <param name="description">A description of what the data load is trying to achieve</param>
            <param name="isTest">If true then the database record will be marked as Test=1</param>
        </member>
        <member name="M:Rdmp.Core.Logging.DataLoadInfo.CloseAndMarkComplete">
            <summary>
            Marks that the data load ended
            </summary>
        </member>
        <member name="M:Rdmp.Core.Logging.DataLoadInfo.LogFatalError(System.String,System.String)">
            <summary>
            Terminates the current DataLoadInfo and records that it resulted in a fatal error
            </summary>
            <param name="errorSource">The component that generated the failure(in SSIS try System::SourceName)</param>
            <param name="errorDescription">A description of the error (in SSIS try System::ErrorDescription)</param>
        </member>
        <member name="T:Rdmp.Core.Logging.DataSource">
            <summary>
            A conceptual 'source' which contributed records to a table being loaded during a logged activity (See TableLoadInfo).  This can be as explicit
            as a flat file 'myfile.csv' or as isoteric as an sql query run on a server (e.g. during extraction we audit the extraction sql with one of these).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.IDataLoadInfo">
            <summary>
            See DataLoadInfo
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.ILogManager">
            <summary>
            See LogManager
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.ITableLoadInfo">
            <summary>
            See TableLoadInfo
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.Listeners.NLogListeners.NLogICheckNotifier">
            <summary>
            <see cref="T:ReusableLibraryCode.Checks.ICheckNotifier"/> that passes all events to an <see cref="T:NLog.LogManager"/>.  Optionally throws on Errors (after logging).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.Listeners.NLogListeners.NLogIDataLoadEventListener">
            <summary>
            <see cref="T:ReusableLibraryCode.Progress.IDataLoadEventListener"/> that passes all events to an <see cref="T:NLog.LogManager"/>.  Optionally throws on Errors (after logging).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.Listeners.NLogListeners.NLogListener">
            <summary>
            Base class for all RDMP Listeners (e.g. <see cref="T:ReusableLibraryCode.Checks.ICheckNotifier"/>) which handle events by writing to an NLog.LogManager
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.Listeners.OverrideSenderIDataLoadEventListener">
            <summary>
            Acts as wrapper for another <see cref="T:ReusableLibraryCode.Progress.IDataLoadEventListener"/> but changes all messages that flow through to appear to come from the same
            sender (string).  You can use this to help with distinguishing message dispatchers (senders) between discrete tasks / threads.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.Listeners.ToFileDataLoadEventListener">
            <summary>
            Writes log messages to file, mainly used by Automation Service to log progress to file.
            It will log "OnProgress" calls as "Trace", which may make the log file very large!
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.Listeners.ToLoggingDatabaseDataLoadEventListener">
            <summary>
            Handles transparently all the logging complexity by using the IDataLoadEventListener interface.  Use this interface if you want to log to the
            logging database events that might otherwise go elsewhere or the component/system you are dealing with already uses IDataLoadEventListeners
            </summary>
        </member>
        <member name="F:Rdmp.Core.Logging.Listeners.ToLoggingDatabaseDataLoadEventListener._wasAlreadyOpen">
            <summary>
            true if we were passed an IDataLoadInfo that was created by someone else (in which case we shouldn't just arbitrarily close it at any point).
            </summary>
        </member>
        <member name="P:Rdmp.Core.Logging.Listeners.ToLoggingDatabaseDataLoadEventListener.DataLoadInfo">
            <summary>
            The root logging object under which all events will be stored, will be null if logging has not started yet (first call to OnNotify/StartLogging).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.LoggingDatabaseChecker">
            <summary>
            Checks that a logging database is accessible and that the default system statuses and dataset names are present.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.LoggingTables">
            <summary>
            Enum indicating one of the logging tables in the logging relational database
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.LogManager">
            <summary>
            Entry point for the RDMP relational logging database.  This class requires to be pointed at an existing logging database with the correct schema (Defined 
            in HIC.Logging.Database - See DatabaseCreation.exe for how to do this). See Logging.cd for the full hierarchy of concepts.
            
            <para>You can both create new logging records and fetch old ones.  New logging objects are generally maintained for future use e.g. when you want to record
            that a new table is being loaded during a given load (DataLoadInfo) you must pass the load log object (DataLoadInfo).  Live logging objects generally
            must be closed to indicate that they are completed (succesfully or otherwise), if you do not close a logging object then the EndTime will be left
            blank and it will be unclear if a process blue screened or if it all went fine (other than the ongoing accumulation of log events, errors etc).</para>
            
            <para>Fetching old records is done based on ID, Task Name etc and is also handled by this class. The objects returned will be ArchivalDataLoadInfo objects
            which are immutable and include the full hierarchy of sub concepts (errors, progress messages, which tables were loaded with how many records etc - 
            See Logging.cd).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.Logging.LogManager.DataAccessPointIfAny">
            <summary>
            If the Server was set from a persistent database reference this property will store it e.g. a logging ExternalDatabaseServer
            </summary>
        </member>
        <member name="M:Rdmp.Core.Logging.LogManager.GetTable(Rdmp.Core.Logging.LoggingTables,Rdmp.Core.Logging.LogViewerFilter,System.Nullable{System.Int32},System.Boolean)">
            <summary>
            
            </summary>
            <param name="table"></param>
            <param name="filter"></param>
            <param name="topX"></param>
            <param name="sortDesc">True to sort descending (highest ID first).  False to sort ascending (lowest ID first)</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Logging.LogManager.GetArchivalDataLoadInfos(System.String,System.Nullable{System.Threading.CancellationToken},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Returns data load audit objects which describe runs of over arching task <paramref name="dataTask"/>
            </summary>
            <param name="dataTask"></param>
            <param name="token"></param>
            <param name="specificDataLoadRunIDOnly"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Logging.LogManager.CreateNewLoggingTask(System.Int32,System.String)">
            <summary>
            Creates a new data load task for the given dataset (datasetID which is the name of the dataset).  The loading task will be called the same as the dataset is called.
            </summary>
            <param name="id"></param>
            <param name="dataSetID"></param>
        </member>
        <member name="T:Rdmp.Core.Logging.LogViewerFilter">
            <summary>
            Decides which records to fetch from the hierarchical logging database including row filter for specific
            run, table loaded etc.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.PastEvents.ArchivalDataLoadInfo">
            <summary>
            Readonly historical version of DataLoadInfo.  The central hierarchical RDMP logging database records activites across all areas of the program in a central
            place.  You can process these records programatically via LogManager.  This class contains public properties for each of the sub concepts (Errors, Progress
            messages, Tables loaded etc).  See Logging.cd for more information
            </summary>
        </member>
        <member name="P:Rdmp.Core.Logging.PastEvents.ArchivalDataLoadInfo.TableLoadInfos">
            <summary>
            All tables loaded during the run
            </summary>
        </member>
        <member name="P:Rdmp.Core.Logging.PastEvents.ArchivalDataLoadInfo.Errors">
            <summary>
            All errors that occured during the run
            </summary>
        </member>
        <member name="P:Rdmp.Core.Logging.PastEvents.ArchivalDataLoadInfo.Progress">
            <summary>
            All progress messages recorded during the run
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.PastEvents.ArchivalDataSource">
            <summary>
            Readonly audit of a historical 'data source' (See HIC.Logging.DataSource) that contributed records to a table that was loaded in the last (See 
            ArchivalTableLoadInfo).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.PastEvents.ArchivalFatalError">
            <summary>
            Readonly audit of a historical error which resulted in the failure of the logged activity (which is also a past / readonly event).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.PastEvents.ArchivalProgressLog">
            <summary>
            Readonly audit of a historical logged event which was noteworthy during the logged activity (See ArchivalDataLoadInfo)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.PastEvents.ArchivalTableLoadInfo">
            <summary>
            Readonly audit of a table that was loaded as part of a historical data load (See HIC.Logging.ArchivalDataLoadInfo).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.PastEvents.IArchivalLoggingRecordOfPastEvent">
            <summary>
            Interface for all Logging messages/objects fetched out of the logging database (immutable PastEvents).  The RDMP logging database supports both logging 
            of new messages/objects e.g. TableLoadInfo and fetching archival history objects of old runs logged in the past ArchivalTableLoadInfo.  All archival 
            history objects are immutable (cannot be edited) and inherit from IArchivalLoggingRecordOfPastEvent
            </summary>
        </member>
        <member name="T:Rdmp.Core.Logging.TableLoadInfo">
            <summary>
            A 'table' that is being loaded as part of a logged activity (See DataLoadInfo).  While it is called a table you can actualy audit any endpoint for records
            e.g. a targetTable of 'bob.csv' would be absolutely fine.  As long as the count of inserts is useful and you want to preserve the information then go ahead
            and create a TableLoadInfo.
            
            <para>You can increment Inserts / Deletes etc as often as you want but do not decrease them.  When you are sure you have finished loading the target table
            (even if there were errors) you should call CloseAndArchive to write the final insert/update/delete count into the database.  After this is called you
            won't be able to change the counts any more.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Logging.TableLoadInfo.#ctor(Rdmp.Core.Logging.DataLoadInfo,System.String,System.String,Rdmp.Core.Logging.DataSource[],System.Int32)">
            <param name="suggestedRollbackCommand">Human readible text indicating how this load might be rolled back, may contain specific SQL or just general advice.</param>
        </member>
        <member name="P:Rdmp.Core.Logging.TableLoadInfo.Updates">
            <summary>
            Increases or Gets the number of Updated records, use += instead of trying to set a specific value.  Important:Make sure you increment with Affected Rows, not just UPDATE commands sent)
            </summary>
        </member>
        <member name="P:Rdmp.Core.Logging.TableLoadInfo.Deletes">
            <summary>
            Increases or Gets the number of Deleted records, use += instead of trying to set a specific value.  Important:Make sure you increment with Affected Rows, not just DELETE commands sent)
            </summary>
        </member>
        <member name="P:Rdmp.Core.Logging.TableLoadInfo.Inserts">
            <summary>
            Increases or Gets the number of Inserted records, use += instead of trying to set a specific value
            </summary>
        </member>
        <member name="P:Rdmp.Core.Logging.TableLoadInfo.DiscardedDuplicates">
            <summary>
            Increases or Gets the number of Discarded Duplicate records, use += instead of trying to set a specific value
            </summary>
        </member>
        <member name="P:Rdmp.Core.Logging.TableLoadInfo.ErrorRows">
            <summary>
            Gets the number of ErrorRows during this data run so far, this is automatically increased by the RowErrorLogging class
            </summary>
        </member>
        <member name="T:Rdmp.Core.MissingColumnInfoException">
            <summary>
            Thrown when an object which should be associated with a single <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> cannot be resolved to one (e.g. an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/> which
            has become unlinked with an underlying column).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.CatalogueChildProvider">
            <summary>
            Performance optimisation class and general super class in charge of recording and discovering all objects in the Catalogue database so they can be displayed in 
            RDMPCollectionUIs etc.  This includes issuing a single database query per Type fetching all objects (e.g. AllProcessTasks, AllLoadMetadatas etc) and then in evaluating
            and documenting the hierarchy in _childDictionary.  Every object that is not a root level object also has a DescendancyList which records the path of parents to that
            exact object.  Therefore you can easily identify 1. what the immediate children of any object are, 2. what the full path to any given object is.
            
            <para>The pattern is:
            1. Identify a root level object 
            2. Create a method overload AddChildren that takes the object
            3. Create a new HashSet containing all the child objects (regardless of mixed Type)
            4. Call AddToDictionaries with a new DescendancyList containing the parent object
            5. For each of the objects added that has children of it's own repeat the above (Except call DescendancyList.Add instead of creating a new one)</para>
             
            </summary>
        </member>
        <member name="M:Rdmp.Core.Providers.CatalogueChildProvider.AddPipelineUseCases(System.Collections.Generic.Dictionary{System.String,Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase})">
            <summary>
            Creates new <see cref="T:Rdmp.Core.Providers.Nodes.PipelineNodes.StandardPipelineUseCaseNode"/>s and fills it with all compatible Pipelines - do not call this method more than once
            </summary>
        </member>
        <member name="M:Rdmp.Core.Providers.CatalogueChildProvider.GetPluginChildren(System.Collections.Generic.HashSet{System.Object})">
            <summary>
            Asks all plugins to provide the child objects for every object we have found so far.  This method is recursive, call it with null the first time to use all objects.  It will then
            call itself with all the new objects that were sent back by the plugin (so that new objects found can still have children).
            </summary>
            <param name="objectsToAskAbout"></param>
        </member>
        <member name="T:Rdmp.Core.Providers.CatalogueProblemProvider">
            <summary>
            Identifies all problems with all objects found in the Catalogue database.  This only includes problems that are fast to detect at runtime.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Providers.CatalogueProblemProvider.RefreshProblems(Rdmp.Core.Providers.ICoreChildProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Providers.CatalogueProblemProvider.HasProblem(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Providers.CatalogueProblemProvider.DescribeProblem(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Providers.CatalogueProblemProvider.DescribeProblem(Rdmp.Core.Providers.Nodes.AllGovernanceNode)">
            <summary>
            Identifies problems with dataset governance (e.g. <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> which have expired <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod"/>)
            </summary>
            <param name="allGovernanceNode"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Providers.DataExportChildProvider">
            <summary>
            Finds the all the objects required for data export tree rendering including which objects are children of others 
            and the descendancy for each object etc.  This class inherits from CatalogueChildProvider because you cannot have
            one without the other and one Data Export database always maps to one (and only one) Catalogue database.
            </summary>
        </member>
        <member name="F:Rdmp.Core.Providers.DataExportChildProvider._cicAssociations">
            <summary>
            ID of all CohortIdentificationConfiguration which have an ProjectCohortIdentificationConfigurationAssociation declared on them (i.e. the CIC is used with one or more Projects)
            </summary>
        </member>
        <member name="F:Rdmp.Core.Providers.DataExportChildProvider.AllContainers">
            <summary>
            All AND/OR containers found during construction (in the data export database).  The Key is the ID of the container (for rapid random access)
            </summary>
        </member>
        <member name="P:Rdmp.Core.Providers.DataExportChildProvider.AllDeployedExtractionFilters">
            <summary>
            All data export filters that existed when this child provider was constructed
            </summary>
        </member>
        <member name="M:Rdmp.Core.Providers.DataExportChildProvider.GetAllExtractableColumns(Rdmp.Core.Repositories.IDataExportRepository)">
            <summary>
            Returns all <see cref="T:Rdmp.Core.DataExport.Data.ExtractableColumn"/> Injected with thier corresponding <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExtractionInformation"/>
            </summary>
            <param name="repository"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Providers.DataExportProblemProvider">
            <summary>
            Identifies all rapidly detectable problems with the configurations of Data Export items
            </summary>
        </member>
        <member name="M:Rdmp.Core.Providers.DataExportProblemProvider.RefreshProblems(Rdmp.Core.Providers.ICoreChildProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Providers.DataExportProblemProvider.HasProblem(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Providers.DataExportProblemProvider.DescribeProblem(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.Providers.DecryptionPrivateKeyNode">
            <summary>
            Tree node for showing the single Private Key location in TableInfoCollectionUI (See PasswordEncryptionKeyLocationUI)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.DescendancyList">
            <summary>
            Audit of parents for a given object in the CatalogueChildProvider hierarchy that is used to populate RDMPCollectionUIs.  Every object that is not a root level 
            object will have a DescendancyList.  Normally any DatabaseEntity (or node class) has only one DescendancyList (path to reach it) however you can flag BetterRouteExists
            on a DescendancyList to indicate that if another DescendancyList is found for the object then that one is to be considered 'better' and used instead.  For example
            AggregateConfigurations which are modelling a cohort apper both under their respective Catalogue and their CohortIdentificationConfiguration but sometimes one is an
            orphan (it's CohortIdentificationConfiguration has been deleted or it has been removed from it) in which case the only path is the 'less goood' one.
            
            <para>It is not allowed to have duplicate objects in Parents.  All objects and parents must have appropriate implements of GetHashCode.</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.Providers.DescendancyList.Parents">
            <summary>
            All objects that are above the described object in order from the root to the immediate parent.
            </summary>
        </member>
        <member name="P:Rdmp.Core.Providers.DescendancyList.NewBestRoute">
            <summary>
            Set to true to indicate that this route should be considered better than any you have seen before for the given object and it's children.  This will cause
            other colliding <see cref="T:Rdmp.Core.Providers.DescendancyList"/> paths for the same object to be marked BetterRouteExists
            </summary>
        </member>
        <member name="P:Rdmp.Core.Providers.DescendancyList.BetterRouteExists">
            <summary>
            Set to true to indicate that you might find a better DescendancyList for the given object and if so that other DescendancyList should be considered 'better'
            </summary>
        </member>
        <member name="M:Rdmp.Core.Providers.DescendancyList.#ctor(System.Object[])">
            <summary>
            Declares that an object has hierarchical <paramref name="parents"/> which should be in order from root to immediate parent
            </summary>
            <param name="parents"></param>
        </member>
        <member name="P:Rdmp.Core.Providers.DescendancyList.IsEmpty">
            <summary>
            True if the list is empty (i.e. there are no <see cref="F:Rdmp.Core.Providers.DescendancyList.Parents"/>)
            </summary>
        </member>
        <member name="M:Rdmp.Core.Providers.DescendancyList.Add(System.Object)">
            <summary>
            Returns a new instance of DescendancyList that includes the new parent appended to the end of parent hierarchy. You can only add to the end so 
            if you have Root=>Grandparent then the only thing you should add is Parent.
            </summary>
            <param name="anotherKnownParent"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Providers.DescendancyList.SetBetterRouteExists">
            <summary>
            Returns a new DescendancyList with BetterRouteExists set to true, this means the system will bear in mind it might see a better DescendancyList later on
            in which case it will use that better route instead
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Providers.DescendancyList.SetNewBestRoute">
            <summary>
            Returns a new DescendancyList with NewBestRoute set to true, this means the system will consider that this DescendancyList can override other colliding DescendancyList
            that already exist.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Providers.DescendancyList.Last">
            <summary>
            returns the last object in the chain, for example Root=>GrandParent=>Parent would return 'Parent'
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Providers.IChildProvider">
            <summary>
            Returns children for a given model object (any object in an RDMPCollectionUI).  This should be fast and your IChildProvider should pre load all the objects
            and then return them as needed when GetChildren is called.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Providers.IChildProvider.GetChildren(System.Object)">
            <summary>
            Returns all children that should hierarchically exist below the <paramref name="model"/> or null if none
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Providers.ICoreChildProvider">
            <summary>
            Extension of IChildProvider which also lists all the high level cached objects so that if you need to fetch objects from the database to calculate 
            things you don't expect to have been the result of an immediate user change you can access the cached object from one of these arrays instead.  For 
            example if you want to know whether you are within the PermissionWindow of your CacheProgress when picking an icon and you only have the PermissionWindow_ID
            property you can just look at the array AllPermissionWindows (especially since you might get lots of spam requests for the icon - you don't want to lookup
            the PermissionWindow from the database every time).
            </summary>
        </member>
        <member name="P:Rdmp.Core.Providers.ICoreChildProvider.GovernanceCoverage">
            <inheritdoc cref="M:Rdmp.Core.Repositories.Managers.IGovernanceManager.GetAllGovernedCataloguesForAllGovernancePeriods"/>
        </member>
        <member name="M:Rdmp.Core.Providers.ICoreChildProvider.GetMasqueradersOf(System.Object)">
            <summary>
            Returns all known objects who are masquerading as o
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Providers.IProblemProvider">
            <summary>
            Identifies problems with objects held in an ICoreChildProvider e.g. Projects missing cohorts, orphan ExtractionInformations etc.  This class
            differs from ICheckable etc because it is designed to identify and record a large number of problems very quickly among a large number of 
            objects and then later report about the problems e.g. when rendering a UI. 
            </summary>
        </member>
        <member name="M:Rdmp.Core.Providers.IProblemProvider.RefreshProblems(Rdmp.Core.Providers.ICoreChildProvider)">
            <summary>
            Finds all the problems with all relevant objects known about by the child provider (Stored results are returned through
            HasProblem and DescribeProblem.
            </summary>
            <param name="childProvider"></param>
        </member>
        <member name="M:Rdmp.Core.Providers.IProblemProvider.HasProblem(System.Object)">
            <summary>
            True if the supplied object has problems with it
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Providers.IProblemProvider.DescribeProblem(System.Object)">
            <summary>
            Returns the problem with object o or null if there are no problems
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AggregatesNode">
            <summary>
            Collection of all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> graphs for visualising data in the <see cref="P:Rdmp.Core.Providers.Nodes.AggregatesNode.Catalogue"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.Providers.Nodes.AggregatesNode.Catalogue">
            <summary>
            The <see cref="P:Rdmp.Core.Providers.Nodes.AggregatesNode.Catalogue"/> to which all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> belong
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AllANOTablesNode">
            <summary>
            Collection of all ANOTable objects.  These define how column level anonymisation happens in the data load engine
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AllCohortsNode">
            <summary>
            Collection of all saved cohort lists (See <see cref="T:Rdmp.Core.DataExport.Data.ExtractableCohort"/>).  These are divided by sources (<see cref="T:Rdmp.Core.DataExport.Data.ExternalCohortTable"/>)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AllConnectionStringKeywordsNode">
            <summary>
            Collection of all currently configured <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ConnectionStringKeyword"/>.  These allow you to use custom keywords in your
            connection strings (e.g. change Port).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AllDataAccessCredentialsNode">
            <summary>
            Collection of all encrypted <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials"/> used to access tables in your database.  This will be empty if you 
            connect with integrated security / windows authentication. 
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AllExternalServersNode">
            <summary>
            Collection of all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer"/> objects.  These are servers that RDMP knows about and can connect to.  These are
            distinct from the server attributes of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> and may not even be database servers (e.g. they could be FTP server or 
            a ticketing server etc).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AllGovernanceNode">
            <summary>
            The RDMP is designed to store sensitive clinical datasets and make them available in research ready (anonymous) form.  This usually requires governance approval from the data
            provider.  This node lets you create periods of governance for your datasets (See GovernancePeriodUI).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AllLoadMetadatasNode">
            <summary>
            Collection of all the Data Load Engine configurations (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata"/>) you have defined.  Each load populates one or more <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> dependant on the
            associated <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>s.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AllPermissionWindowsNode">
            <summary>
            Collection of all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.PermissionWindow"/> objects.  These are windows of time in which operations are permitted / forbidden.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AllRDMPRemotesNode">
            <summary>
            Collection of all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Remoting.RemoteRDMP"/>s you have configured.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AllServersNode">
            <summary>
            Dynamically created collection of 'servers' produced from all currently configured <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/>.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.AllStandardRegexesNode">
            <summary>
            Collection of all centrally defined <see cref="T:Rdmp.Core.CatalogueLibrary.Data.StandardRegex"/>.  These are documented regular expressions which
            can be shared and reused between components (e.g. PipelineComponents).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.ArbitraryFolderNode">
            <summary>
            Folder Node that can be added to TreeListViews.  You can only add one folder of each name because they inherit from <see cref="T:Rdmp.Core.Providers.Nodes.SingletonNode"/>.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.CatalogueItemsNode">
            <summary>
            Collection of all the virtual columns (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/>) in a dataset (<see cref="P:Rdmp.Core.Providers.Nodes.CatalogueItemsNode.Catalogue"/>)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.CohortNodes.AllFreeCohortIdentificationConfigurationsNode">
            <summary>
            Collection of all the cohort building queries (CohortIdentificationConfiguration) you have built which are not associated with
            a project yet.  These might be reusable template configurations (for cloning) or just cohort queries which have not been 
            executed/committed to a project yet.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.CohortNodes.AllProjectCohortIdentificationConfigurationsNode">
            <summary>
            Collection of all the cohort building queries (CohortIdentificationConfiguration) you have built which are associated with
            one or more a extraction projects.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.CohortNodes.QueryCacheUsedByCohortIdentificationNode">
            <summary>
            Indicates that a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> has a database in which to store temporary tables in that reflect the reuslts of subcomponents 
            of the full query.  This improves query performance and allows cross server / database type cohort generation.  
            
            <para>Cache invalidation automatically occurs when subcomponents are changed</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.CohortSetsNode">
            <summary>
            Collection of all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> in a <see cref="P:Rdmp.Core.Providers.Nodes.CohortSetsNode.Catalogue"/> that are involved in cohort creation (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/>).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.DataAccessCredentialUsageNode">
            <summary>
            Tree Node for documenting the allowed usage of a specific DataAccessCredentials (username / password) under a given DataAccessContext (loading, extracting etc).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.DocumentationNode">
            <summary>
            Container tree node for all the documentation bits of a Catalogue including SupportingDocuments and SupportingSQLTables 
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.ExtractionConfigurationsNode">
            <summary>
            Collection of all <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/> in a given <see cref="P:Rdmp.Core.Providers.Nodes.ExtractionConfigurationsNode.Project"/>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.ExtractionDirectoryNode">
            <summary>
            Location on disk in which linked project extracts are generated for a given <see cref="P:Rdmp.Core.Providers.Nodes.ExtractionDirectoryNode.Project"/> (assuming you are extracting to disk
            e.g. with an <see cref="T:Rdmp.Core.DataExport.ExtractionTime.ExtractionPipeline.Destinations.ExecuteDatasetExtractionFlatFileDestination"/>).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.FrozenExtractionConfigurationsNode">
            <summary>
            Collection of all previously extracted (and now readonly) <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/>s in a given <see cref="P:Rdmp.Core.Providers.Nodes.FrozenExtractionConfigurationsNode.Project"/>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.IdentifierDumpServerUsageNode">
            <summary>
            Identifies a database which is used to 'split off' identifiable data (columns) during a data load instead of loading it into the LIVE database (from which you
            execute data extractions).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.JoinableCollectionNode">
            <summary>
            Collection of queries which can be joined against when building cohorts (e.g. to find all hospital admissions within 6 
            months of a prescription for drug X).  See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.Joinables.JoinableCohortAggregateConfiguration"/>.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.LinkedCohortNode">
            <summary>
            The saved cohort (list of patient identifiers) which will be linked with the datasets in the associated <see cref="T:Rdmp.Core.DataExport.Data.ExtractionConfiguration"/>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.LoadMetadataNodes.AllCataloguesUsedByLoadMetadataNode">
            <summary>
            Collection of all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>s which are currently associated with a given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.LoadMetadata"/>.  This governs
            which tables are created in RAW=>STAGING=>LIVE.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.PackageContentNode">
            <summary>
            Collection of all datasets in a given <see cref="P:Rdmp.Core.Providers.Nodes.PackageContentNode.Package"/>.  This lets you define template sets of datasets which all get extracted together
            e.g. 'Core Datasets'.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.ParametersNode">
            <summary>
            Shows all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> declared in the given scope.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.PipelineNodes.AllPipelinesNode">
            <summary>
            Pipelines are sequences of tailorable components which achieve a given goal (e.g. load a cohort).  This node is a collection of all
            common use cases for pipelines.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.PipelineNodes.OtherPipelinesNode">
            <summary>
            Pipelines are sequences of tailorable components which achieve a given goal (e.g. load a cohort).  This node is a collection of all
            pipelines for which are not compatible with core RDMP use cases (these might be broken or designed for plugin code / custom goals - 
            e.g. loading imaging data).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.PipelineNodes.PipelineCompatibleWithUseCaseNode">
            <summary>
            This class is a wrapper for a <see cref="P:Rdmp.Core.Providers.Nodes.PipelineNodes.PipelineCompatibleWithUseCaseNode.Pipeline"/> that has been found to be compatible with a given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Pipelines.PipelineUseCase"/> (in terms of the source / 
            destination components and flow type etc).
            
            <para>It is <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Spontaneous.SpontaneousObject"/> only so it appears under Ctrl+F window... not a pattern we want to repeat.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.PipelineNodes.StandardPipelineUseCaseNode">
            <summary>
            Collection of all the Pipelines compatible with a given use case. 
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.PreLoadDiscardedColumnsNode">
            <summary>
            All virtual columns in this <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> which appear in the data load (RAW) but do not exist in the live database (or are diluted).  This enables
            anonymisation or dropping of columns during the data load (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataLoad.PreLoadDiscardedColumn"/>)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.ProjectCataloguesNode">
            <summary>
            Collection of all project specific datasets (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>s which can only be used with this <see cref="P:Rdmp.Core.Providers.Nodes.ProjectCataloguesNode.Project"/>).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.ProjectCohortNodes.ProjectCohortIdentificationConfigurationAssociationsNode">
            <summary>
            Collection of all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> (queries for identifying patient lists) which are associated 
            with a <see cref="P:Rdmp.Core.Providers.Nodes.ProjectCohortNodes.ProjectCohortIdentificationConfigurationAssociationsNode.Project"/>.  
            
            <para>A <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> can be associated with multiple Projects</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.ProjectCohortNodes.ProjectSavedCohortsNode">
            <summary>
            Collection of all saved cohort lists (<see cref="T:Rdmp.Core.DataExport.Data.ExtractableCohort"/>) which were saved against a <see cref="P:Rdmp.Core.Providers.Nodes.ProjectCohortNodes.ProjectSavedCohortsNode.Project"/>.  Cohorts are 
            associated with the <see cref="P:Rdmp.Core.Providers.Nodes.ProjectCohortNodes.ProjectSavedCohortsNode.Project"/> via the project number.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.SharingNodes.AllObjectExportsNode">
            <summary>
            Collection of ObjectExport records which document RDMP metadata objects which you have exported (ready for sharing with another RDMP user).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.SharingNodes.AllObjectImportsNode">
            <summary>
            Collection of ObjectImport records which document RDMP metadata objects which you have imported (from another RDMP instance).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.SharingNodes.AllObjectSharingNode">
            <summary>
            Collection of all ObjectExport and ObjectImport references (for sharing RDMP objects with other remote deployment instances of RDMP).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Providers.Nodes.UsedByProject.CohortSourceUsedByProjectNode">
            <summary>
            Collection of all cohort databases which contain cohorts that can be used in a given <see cref="T:Rdmp.Core.DataExport.Data.Project"/>
            </summary>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.AggregateBuilder">
            <summary>
            Assembles GROUP BY queries based on the specified IColumns, IContainers, IFilters etc.  There are three main types of query AggregateBuilder can create
            
            <para>1. Basic GROUP BY e.g. Select chi,count(chi) from prescribing where LEN(chi) = 10 group by chi HAVING count(chi)> 10</para>
            
            <para>2. Calendar Table GROUP BY.  This supports all of the features of 1. but also starts by using dynamic SQL to create a date range table to which the query is
            automatically Joined.  This means that you will not get gaps in days where there is no data.  To create one of these you must set AggregateContinuousDateAxis</para>
            
            <para>3. Dynamic PIVOT GROUP BY.  This supports all of the features of 2. (it must have an axis) but also generates a dynamic PIVOT column for each unique value found
            in the AggregateConfiguration.PivotDimension.  This is (normally) done by running a pre query which includes all the IFilters and IContainers etc so to return the
            unique values that will appear in the final query only.  Then the final query is run with a PIVOT command over the column values found.  Since data can be a mile 
            wide and full of punctuation etc there is an adjustment operation on the values to qualify them as valid column names.</para>
            
            <para>AggregateBuilder is cross database compatible.  This is achieved by assembling all the lines it thinks it needs for it's query and then passing off the exact 
            implementation into IAggregateHelper.BuildAggregate.  The implementation of the calendars/dynamic pivots vary wildly by database engine (See MySqlAggregateHelper vs
            MicrosoftSQLAggregateHelper).  </para>
            
            <para>All IAggregateHelper.BuildAggregate implementations must produce the same result tables for the same column/axis/pivot settings.  This is rigidly enforced by 
            AggregateDataBasedTests </para>
            
            <para>IMPORTANT: AggregateBuilder also powers the cohort identification system (See CohortQueryBuilderHelper) in which case the AggregateConfiguration will have
            only a single AggregateDimension (which must be the patient identifier column).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.SQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.LimitationSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.LabelWithComment">
            <summary>
            Text to add as an SQL comment before the SELECT section of the query e.g. "bob" would result in the text /*bob*/ appearing at the top of the SELECT
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.HavingSQL">
            <summary>
            Optional, SQL to apply a HAVING clause to the GROUP BY query generated
            
            <para>Do not include the word HAVING in the text since it will automatically be added</para>
            
            <para>Depending on <see cref="M:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions.ShouldBeEnabled(Rdmp.Core.QueryBuilding.Options.AggregateEditorSection,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)"/> this may not be supported for your <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/></para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.AggregateTopX">
            <summary>
            Optional, Limit the results returned.
            
            <para>Depending on <see cref="M:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions.ShouldBeEnabled(Rdmp.Core.QueryBuilding.Options.AggregateEditorSection,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)"/> this may not be supported for your <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/></para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.SelectColumns">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.TablesUsedInQuery">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.JoinsUsedInQuery">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.CustomLines">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.TopXCustomLine">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateBuilder.AddCustomLine(System.String,FAnsi.Discovery.QuerySyntax.QueryComponent)">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.Filters">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.RootFilterContainer">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.CheckSyntax">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.PrimaryExtractionTable">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.ParameterManager">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.SQLOutOfDate">
            <inheritdoc/>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.AggregateBuilder._queryLevelParameterProvider">
            <summary>
            Facilitates injection of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> from the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> at <see cref="F:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel.QueryLevel"/>
            with consideration for any overriding globals that might already exist
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.DoNotWriteOutParameters">
             <summary>
             True to skip writing any parameter declarations (which would normally appear at the top of the query).
            
             <para>This can be used to allow joining several queries together interspersed with INTERSECT / UNION etc without the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> declarations getting in the way </para>
             </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.AggregateBuilder._skipGroupByForThese">
            <summary>
            when adding columns you have the option of either including them in groupby (default) or omitting them from groupby.  If ommitted then the columns will be used to decide how to
            build the FROM statement (which tables to join etc) but not included in the SELECT and GROUP BY sections of the query
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateBuilder.#ctor(System.String,System.String,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,Rdmp.Core.CatalogueLibrary.Data.TableInfo[])">
            <inheritdoc cref="M:Rdmp.Core.QueryBuilding.AggregateBuilder.#ctor(System.String,System.String,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)" />
            <param name="forceJoinsToTheseTables">Tables you definetly want the query to join against in the FROM section (compatible <see cref="T:Rdmp.Core.CatalogueLibrary.Data.JoinInfo"/> must exist if there are multiple)</param>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateBuilder.DoNotWriteOutOrderBy">
            <summary>
            True to skip the ORDER BY section of the query
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateBuilder.#ctor(System.String,System.String,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Build a query based on the current <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>
            </summary>
            <param name="limitationSQL">See <see cref="P:Rdmp.Core.QueryBuilding.AggregateBuilder.LimitationSQL"/></param>
            <param name="countSQL">
            Intended purpose:The line of SELECT Sql that is an 'Aggregate Function' e.g. count(*).
            <para>Other purposes: You can use this to ram arbitrary lines of code into SELECT section of the query e.g. see CohortQueryBuilder </para>
            </param>
            <param name="aggregateConfigurationIfAny"><see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> containing columns, filters, parameters etc for the GROUP BY</param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateBuilder.AddColumn(Rdmp.Core.QueryBuilding.IColumn)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateBuilder.AddColumn(Rdmp.Core.QueryBuilding.IColumn,System.Boolean)">
            <summary>
            Overload lets you include columns for the purposes of FROM creation but not have them also appear in GROUP BY sections
            </summary>
            <param name="col"></param>
            <param name="includeAsGroupBy"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateBuilder.AddColumnRange(Rdmp.Core.QueryBuilding.IColumn[])">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateBuilder.AddColumnRange(Rdmp.Core.QueryBuilding.IColumn[],System.Boolean)">
            <inheritdoc/>
            <param name="includeAsGroupBy">false to add the columns only to the SELECT section of the query (and not GROUP BY)</param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateBuilder.SetPivotToDimensionID(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension)">
            <summary>
            Defines a PIVOT on the values in a given column.  This is only valid for <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> which are graphs
            <see cref="T:Rdmp.Core.QueryBuilding.Options.AggregateBuilderBasicOptions"/> which must also have an axis configured
            </summary>
            <param name="pivot"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateBuilder.RegenerateSQL">
            <summary>
            Populates _sql (SQL property) and resolves all parameters, filters containers etc.  Basically Finalizes this query builder 
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateBuilder.GetDistinctRequiredLookups">
            <summary>
            Throws <see cref="T:System.NotSupportedException"/> since <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> canot be part of an aggregate GROUP BY
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.AggregateCountColumn">
            <summary>
            The count(*) column in an AggregateConfiguration, this is used by AggregateBuilder.  This can be any aggregate function such as 'sum', 'avg' etc.
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.AggregateCountColumn.DefaultAliasName">
            <summary>
            The default alias for unamed count columns
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateCountColumn.#ctor(System.String)">
            <summary>
            Creates a new Aggregate Function (count / max etc) with the given line of SELECT SQL
            <para>Can include aliases e.g. count(*) as MyCount</para>
            </summary>
            <param name="sql"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateCountColumn.SetQuerySyntaxHelper(FAnsi.Discovery.QuerySyntax.IQuerySyntaxHelper,System.Boolean)">
            <summary>
            Initializes the <see cref="T:FAnsi.Discovery.QuerySyntax.IQuerySyntaxHelper"/> for the column and optionally ensures that it has an alias.  If no <see cref="P:Rdmp.Core.QueryBuilding.AggregateCountColumn.Alias"/> has
            been specified or was found in the current sql then <see cref="F:Rdmp.Core.QueryBuilding.AggregateCountColumn.DefaultAliasName"/> is set.
            </summary>
            <param name="syntaxHelper"></param>
            <param name="ensureAliasExists"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateCountColumn.GetRuntimeName">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateCountColumn.GetFullSelectLineStringForSavingIntoAnAggregate">
            <summary>
            Combines the <see cref="P:Rdmp.Core.QueryBuilding.AggregateCountColumn.SelectSQL"/> with the <see cref="P:Rdmp.Core.QueryBuilding.AggregateCountColumn.Alias"/> for use in SELECT Sql
            </summary>
            <returns></returns>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateCountColumn.ColumnInfo">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateCountColumn.Order">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateCountColumn.SelectSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateCountColumn.Alias">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateCountColumn.HashOnDataRelease">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateCountColumn.IsExtractionIdentifier">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.AggregateCountColumn.IsPrimaryKey">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.AggregateCountColumn.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.CohortQueryBuilder">
            <summary>
            Builds complex cohort identification queries by combining subqueries with SQL set operations (UNION / INTERSECT / EXCEPT).  Cohort identification
            sub queries fundamentally take the form of 'Select distinct patientId from TableX'.  All the complexity comes in the form of IFilters (WHERE Sql), 
            parameters, using cached query results, patient index tables etc.
            
            <para>User cohort identification queries are all create under a CohortIdentificationConfiguration which will have a single root CohortAggregateContainer.  A
            final count for the number of patients in the cohort can be determined by running the root CohortAggregateContainer.  The user will often want to run each
            sub query independently however to get counts for each dataset involved.  Sub queries are defined in AggregateConfigurations.</para>
            
            <para>In order to build complex multi table queries across multiple datasets with complex where/parameter/join logic with decent performance RDMP supports 
            caching.  Caching involves executing each sub query (AggregateConfiguration) and storing the resulting patient identifier list in an indexed table on
            the caching server (See CachedAggregateConfigurationResultsManager).  These cached queries are versioned by the SQL used to generate them (to avoid stale
            result lists).  Where available CohortQueryBuilder will use the cached result list instead of running the full query since it runs drastically faster.</para>
            
            <para>The SQL code for individual queries is created by CohortQueryBuilderHelper (using AggregateBuilder).</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.CohortQueryBuilder.DoNotWriteOutParameters">
            <summary>
            Tells the Builder not to write out parameter SQL, unlike AggregateBuilder this will not clear the ParameterManager it will just hide them from the SQL output
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.CohortQueryBuilder.IsEnabled(Rdmp.Core.CatalogueLibrary.Data.Cohort.IOrderable)">
            <summary>
            Objects are enabled if they do not support disabling (<see cref="T:MapsDirectlyToDatabaseTable.IDisableable"/>) or are <see cref="P:MapsDirectlyToDatabaseTable.IDisableable.IsDisabled"/> = false
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.CohortQueryBuilderHelper">
            <summary>
            Helper for CohortQueryBuilder which contains code for building individual cohort identification subqueries.  Subqueries are actually built by 
            AggregateBuilder but this class handles tab indentation, parameter renaming (where there are other subqueries with conflicting sql parameter names), 
            injecting globals etc.
            </summary>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.CohortSummaryQueryBuilder">
            <summary>
            Allows you to generate adjusted AggregateBuilders in which a basic AggregateBuilder from an AggregateConfiguration is adjusted to include an inception WHERE statement
            which restricts the results to only those patients who are in a cohort (the cohort is the list of private identifiers returned by the AggregateConfiguration passed
            into the constructor as the 'cohort' argument) 
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.CohortSummaryQueryBuilder.#ctor(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Read class description to see what the class does, use this constructor to specify an Aggregate graph and a cohort with which to restrict it.  The cohort
            aggregate must return a list of private identifiers.  The parameters must belong to the same Catalogue (dataset).
            </summary>
            <param name="summary">A basic aggregate that you want to restrict by cohort e.g. a pivot on drugs prescribed over time with an axis interval of year</param>
            <param name="cohort">A cohort aggregate that has a single AggregateDimension which must be an IsExtractionIdentifier and must follow the correct cohort aggregate naming conventions (See IsCohortIdentificationAggregate)</param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.CohortSummaryQueryBuilder.GetAdjustedAggregateBuilder(Rdmp.Core.QueryBuilding.CohortSummaryAdjustment,Rdmp.Core.CatalogueLibrary.Data.IFilter)">
            <summary>
            Functions in two modes 
            
            <para>WhereExtractionIdentifiersIn: 
            Returns a adjusted AggregateBuilder that is based on the summary AggregateConfiguration but which has an inception WHERE statement that restricts the IsExtractionIdentifier column
            by those values returned by the Cohort query.  In order that this query doesn't become super insane we require that the Cohort be cached so that it is just a simple single
            like IFilter e.g. conceptually: WHERE CHI IN (Select CHI from IndexedExtractionIdentifierList_AggregateConfiguration5)</para>
            
            <para>WhereRecordsIn
            Returns an adjusted AggregateBuilder that is based on the summary AggregateConfiguration but which has an root AND container which includes both the container tree of the summary
            and the cohort (resulting in a graphing of the RECORDS returned by the cohort set query instead of a master set of all those patients records - as above does).</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn">
            <summary>
            Allows you to convert a ColumnInfo into an IColumn (the column concept in query building).  IColumn has Alias and Order which do not exist in ColumnInfo 
            (which is a reference to an existing column on your database only).  The alias will be null and the Order will be -1 meaning that ColumnInfoToIColumn will
            by default appear above other IColumns in order.
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.#ctor(MapsDirectlyToDatabaseTable.MemoryRepository,Rdmp.Core.CatalogueLibrary.Data.ColumnInfo)">
            <summary>
            Allows the given <see cref="P:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.ColumnInfo"/> to act as an <see cref="T:Rdmp.Core.QueryBuilding.IColumn"/> giving it an Order and setting extraction flags (e.g. <see cref="P:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.HashOnDataRelease"/>)to sensible defaults.
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.GetRuntimeName">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.ColumnInfo">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.Order">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.SelectSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.Alias">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.HashOnDataRelease">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.IsExtractionIdentifier">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.IsPrimaryKey">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ColumnInfoToIColumn.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks the syntax of the column
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.ConstantParameter">
            <summary>
             Use this class to create standard parameters which you will always manually add in code to a QueryBuilder.  These are not editable
             by users and are not stored in a database.  They should be used for things such as cohortDefinitionID, projectID etc.
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ConstantParameter.#ctor(System.String,System.String,System.String,FAnsi.Discovery.QuerySyntax.IQuerySyntaxHelper)">
            <summary>
            Creates a new unchangeable always available parameter in a query being built.
            </summary>
            <param name="parameterSQL">The declaration sql e.g. DECLARE @bob as int</param>
            <param name="value">The value to set the paramater e.g. 1</param>
            <param name="comment">Some text to appear above the parameter, explaining its purpose</param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ConstantParameter.SaveToDatabase">
            <summary>
            Not supported for constant parameters
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ConstantParameter.ToString">
            <inheritdoc cref="P:Rdmp.Core.QueryBuilding.ConstantParameter.ParameterName"/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ConstantParameter.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks the syntax of the parameter (See <see cref="T:Rdmp.Core.QueryBuilding.SyntaxChecking.ParameterSyntaxChecker"/>)
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ConstantParameter.GetQuerySyntaxHelper">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ConstantParameter.ParameterName">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ConstantParameter.ParameterSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ConstantParameter.Value">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ConstantParameter.Comment">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ConstantParameter.GetOwnerIfAny">
            <summary>
            Returns null, <see cref="T:Rdmp.Core.QueryBuilding.ConstantParameter"/> are never owned by any objects
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ConstantParameter.Parse(System.String,FAnsi.Discovery.QuerySyntax.IQuerySyntaxHelper)">
            <summary>
            Attempts to parse the provided <paramref name="sql"/> text into a <see cref="T:Rdmp.Core.QueryBuilding.ConstantParameter"/>
            </summary>
            <param name="sql"></param>
            <param name="syntaxHelper"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.ExtractionQueryBuilder">
            <summary>
            Calculates the Extraction SQL for extracting a given ExtractDatasetCommand.  This is done by creating a normal QueryBuilder and then adding adjustment 
            components to it to link against the cohort, drop the private identifier column, add the release identifier column etc.
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ExtractionQueryBuilder.GetSQLCommandForFullExtractionSet(Rdmp.Core.DataExport.ExtractionTime.Commands.ExtractDatasetCommand,System.Collections.Generic.List{Rdmp.Core.QueryBuilding.ReleaseIdentifierSubstitution}@)">
            <summary>
            This produces the SQL that would retrieve the specified dataset columns including any JOINS 
            
            <para>It uses:
            QueryBuilder in the data CatalogueLibrary and then it adds some custom lines for linking to the cohort</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.IColumn">
            <summary>
            Interface for defining classes which store a single line of SELECT Sql for use in query building (See ISqlQueryBuilder).  This includes basic stuff like SelectSQL 
            and Alias but also logical things like Order (which column order it should appear in the select statement being built).
            
            <para>Note that many properties can be null including ColumnInfo and Alias etc.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.IColumn.ColumnInfo">
            <summary>
            Gets the underlying <see cref="P:Rdmp.Core.QueryBuilding.IColumn.ColumnInfo"/> behind this line of SELECT SQL.
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.IColumn.SelectSQL">
            <summary>
            The single line of SQL that should be executed in a SELECT statement built by an <see cref="T:Rdmp.Core.QueryBuilding.ISqlQueryBuilder"/>
            <para>This may just be the fully qualified column name verbatim or it could be a transform</para>
            <para>This does not include the <see cref="P:Rdmp.Core.QueryBuilding.IColumn.Alias"/> section of the SELECT line e.g. " AS MyTransform"</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.IColumn.Alias">
            <summary>
            The alias (if any) for the column when it is included in a SELECT statement.  This should not include the " AS " bit only the text that would come after.
            <para>Only use if the <see cref="P:Rdmp.Core.QueryBuilding.IColumn.SelectSQL"/> is a transform e.g. "UPPER([mydb]..[mytbl].[mycol])" </para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.IColumn.HashOnDataRelease">
            <summary>
            True if the <see cref="P:Rdmp.Core.QueryBuilding.IColumn.ColumnInfo"/> should be wrapped with a standard hashing algorithmn (e.g. MD5) when extracted to researchers in a data extract.
            <para>Hashing algorithmn must be defined in data export database</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.IColumn.IsExtractionIdentifier">
            <summary>
            Indicates whether this column holds patient identifiers which can be used for cohort creation and which must be substituted for anonymous release
            identifiers on data extraction (to a researcher).
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.IColumn.IsPrimaryKey">
            <summary>
            Indicates whether this column is the Primary Key (or part of a composite Primary Key) when extracted.  This flag is not copied / imputed from 
            <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo.IsPrimaryKey"/> because primary keys can often contain sensitive information (e.g. lab number) and
            you may have a transform or hash configured or your <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> may involve joining multiple <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> together.
            </summary>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.ISqlQueryBuilder">
            <summary>
            Shared interface for both the RDMP query builders (QueryBuilder and AggregateBuilder).  Query Building in RDMP consists of defining mono atomic comonents 
            ('I want this column',  'I want LimitationSQL: DISTINCT' etc) then the ISqlQueryBuilder turns it into SQL 
            (See namespace CatalogueLibraryTests.Integration.QueryBuildingTests.QueryBuilderTests).
            
            <para>The main purpose of this interface is to move common logic such as finding which TableInfos to join and resolving Parameter overriding into SqlQueryBuilderHelper </para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.SQL">
            <summary>
            Builds (if out of date) and returns the SQL query that reflects the currently selected columns, tables etc of the query builder.
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.SQLOutOfDate">
            <summary>
            True if changes have been made to the state of this class since you last fetched <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.SQL"/>.
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.LimitationSQL">
            <summary>
            Any SQL to inject between SELECT and the first column, e.g. "DISTINCT"
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.SelectColumns">
            <summary>
            Wrapper class for the columns you added to the query with <see cref="M:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.AddColumn(Rdmp.Core.QueryBuilding.IColumn)"/>).  After fetching the query (See <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.SQL"/>) this will be populated with 
            facts about the <see cref="T:Rdmp.Core.QueryBuilding.IColumn"/> including it's status in lookup joins etc 
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.TablesUsedInQuery">
            <summary>
            All tables identified during the query as being required to build the query (based on the <see cref="T:Rdmp.Core.QueryBuilding.IColumn"/>) and any forced joins etc.
            
            <para>Do not modify this manually</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.Filters">
            <summary>
            All filters found in the <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.RootFilterContainer"/> (recursively)
            <para>Do not modify this manually</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.JoinsUsedInQuery">
            <summary>
            List of all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.JoinInfo"/> found for joining the <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.TablesUsedInQuery"/> for building the query.
            <para>Do not modify this manually</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.RootFilterContainer">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IContainer"/> (AND / OR) that contains all the lines of WHERE SQL (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/>) including subcontainers.
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.CheckSyntax">
            <summary>
            True to check the syntax of columns, parameters etc.  This should result in SyntaxErrorException being thrown when generating the SQL if it is substantially malformed
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.PrimaryExtractionTable">
            <summary>
            The single <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> amongst <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.TablesUsedInQuery"/> that was <see cref="P:Rdmp.Core.CatalogueLibrary.Data.TableInfo.IsPrimaryExtractionTable"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.ParameterManager">
            <summary>
            Manages the addition of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> to the <see cref="T:Rdmp.Core.QueryBuilding.ISqlQueryBuilder"/> in a scoped way (globals, query level etc).
            
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.AddColumnRange(Rdmp.Core.QueryBuilding.IColumn[])">
            <summary>
            Adds the provided columns to the query as lines of SELECT SQL
            </summary>
            <param name="columnsToAdd"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.AddColumn(Rdmp.Core.QueryBuilding.IColumn)">
            <summary>
            Adds the column to the query as single line of SELECT SQL
            </summary>
            <param name="col"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.RegenerateSQL">
            <summary>
            Manually forces the query builder to rebuild the query.  This will update <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.TablesUsedInQuery"/>, <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.SelectColumns"/> etc.
            
            <para>This automatically happens if you make a change to the state of the class and call <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.SQL"/> property (if the change resulted in <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.SQLOutOfDate"/> becoming true).</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.GetDistinctRequiredLookups">
            <summary>
            Returns all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> classes found and used in the query.
            
            <para>This only happens if you have a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> configured and your query has both the code column and the description column in it's SELECT columns</para>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.CustomLines">
            <summary>
            List of all added CustomLines so far, use <see cref="M:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.AddCustomLine(System.String,FAnsi.Discovery.QuerySyntax.QueryComponent)"/> to add new ones.
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.AddCustomLine(System.String,FAnsi.Discovery.QuerySyntax.QueryComponent)">
            <summary>
            Add the provided text at the specified position in the query.  This will result in the query being rebuilt when you call <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.SQL"/>. 
             
            </summary>
            <param name="text">The SQL to inject</param>
            <param name="positionToInsert">The position in the query to inject it</param>
            <returns>The CustomLine that was created and added to the query </returns>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.TopXCustomLine">
            <summary>
            The line of SQL code and it's position in the query which results in result limiting (e.g. LIMIT X in MySql and TOP X in SqlServer)
            
            <para>Changing this manually is not recommended, specify it in the <see cref="T:Rdmp.Core.QueryBuilding.ISqlQueryBuilder"/> constructor instead</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.Options.AggregateBuilderBasicOptions">
            <summary>
            Describes what parts of the GROUP BY statement are allowed for <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> that are running in 'graph mode' 
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderBasicOptions.GetTitleTextPrefix(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderBasicOptions.GetAvailableSELECTColumns(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderBasicOptions.GetAvailableWHEREColumns(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderBasicOptions.ShouldBeEnabled(Rdmp.Core.QueryBuilding.Options.AggregateEditorSection,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderBasicOptions.GetAvailableJoinables(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderBasicOptions.GetAllParameters(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderBasicOptions.GetCountColumnRequirement(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.Options.AggregateBuilderCohortOptions">
            <summary>
            Describes what parts of the GROUP BY statement are allowed for <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> that are running as a 'cohort set' 
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderCohortOptions.#ctor(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter[])">
            <summary>
            Creates an <see cref="T:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions"/> for use with <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> which are <see cref="P:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration.IsCohortIdentificationAggregate"/>
             </summary>
            <param name="globals">Global parameters found in the scope of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> you intend to use</param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderCohortOptions.GetTitleTextPrefix(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderCohortOptions.GetAvailableSELECTColumns(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderCohortOptions.GetAvailableWHEREColumns(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderCohortOptions.ShouldBeEnabled(Rdmp.Core.QueryBuilding.Options.AggregateEditorSection,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderCohortOptions.GetAvailableJoinables(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderCohortOptions.GetAllParameters(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderCohortOptions.GetCountColumnRequirement(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.Options.AggregateBuilderOptionsFactory">
            <summary>
            Builds <see cref="T:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions"/> from the current state of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>s.
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.AggregateBuilderOptionsFactory.Create(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Creates an <see cref="T:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions"/> appropriate to the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>.  These options indicate whether
            it is functioning as a graph or cohort set and therefore which parts of the <see cref="T:Rdmp.Core.QueryBuilding.AggregateBuilder"/> are elligible to be modified.
            </summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions">
            <summary>
            Describes which parts of an <see cref="T:Rdmp.Core.QueryBuilding.AggregateBuilder"/> are compatible with a given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> under a given usage case (e.g. acting as an 
            aggregate graph).
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions.GetTitleTextPrefix(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Human readable description of the role the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> is playing e.g. as a graph, cohort set or patient index table
            </summary>
            <param name="aggregate"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions.GetAvailableSELECTColumns(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            All <see cref="T:Rdmp.Core.QueryBuilding.IColumn"/> which could be added as <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateDimension"/> to the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>
            </summary>
            <param name="aggregate"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions.GetAvailableWHEREColumns(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            All <see cref="T:Rdmp.Core.QueryBuilding.IColumn"/> which could be referenced in <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> SQL of the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/>
            <para>Primarily used for autocomplete etc</para>
            </summary>
            <param name="aggregate"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions.ShouldBeEnabled(Rdmp.Core.QueryBuilding.Options.AggregateEditorSection,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Indicates whether a given part of functionality in <see cref="T:Rdmp.Core.QueryBuilding.AggregateBuilder"/> is compatible with the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> given 
            it's current state and role it is playing e.g. as a graph, cohort set etc
            </summary>
            <param name="section">The functionality you want to know if is supported</param>
            <param name="aggregate"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions.GetAvailableJoinables(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> which could become <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateForcedJoin"/> and other compatible <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> that qualify as Patient Index Tables
            (if the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> is acting as a cohort set)/
            </summary>
            <param name="aggregate"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions.GetAllParameters(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Gets <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> declared by the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> combined with any that exist 
            at a global environment level.
            </summary>
            <param name="aggregate"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions.GetCountColumnRequirement(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Indicates whether or not there can be a count(*), max(x) etc column given the current configuration and role the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> is playing.
            </summary>
            <param name="aggregate"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.Options.CountColumnRequirement">
            <summary>
            Indicates whether or not a given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> (GROUP BY) can have a count(*), max(x) etc column given the 
            current configuration and role it is playing.
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Options.CountColumnRequirement.CannotHaveOne">
            <summary>
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> cannot have a count/max etc column.  
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Options.CountColumnRequirement.MustHaveOne">
            <summary>
            There must be at least one count/max column (and possibly more are allowed)
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Options.CountColumnRequirement.CanOptionallyHaveOne">
            <summary>
            count/max etc columns are optional
            </summary>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.Options.AggregateEditorSection">
            <summary>
            Area of functionality supported by <see cref="T:Rdmp.Core.QueryBuilding.AggregateBuilder"/> that may or may not be compatible with an <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> given
            the role it is playing e.g cohort set, graph etc (role is modelled by <see cref="T:Rdmp.Core.QueryBuilding.Options.IAggregateBuilderOptions"/>)
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Options.AggregateEditorSection.Extractable">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> is a graph which could be made available to researchers in researcher extracts
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Options.AggregateEditorSection.TOPX">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> supports <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IAggregateTopX"/>
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Options.AggregateEditorSection.PIVOT">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> supports pivoting on a columns values
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Options.AggregateEditorSection.AXIS">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration"/> supports GROUP BY a calendar table ensuring a continuous date/time dimension to records even with sparse
            data.  See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateContinuousDateAxis"/>
            </summary>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.Parameters.ParameterFoundAtLevel">
            <summary>
            Stores the fact that a ParameterManager found a particular ISqlParameter while evaluating all objects involved in a query being built (See ParameterManager for more
             information).
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.Parameters.ParameterFoundAtLevel.Parameter">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> that was found
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.Parameters.ParameterFoundAtLevel.Level">
            <summary>
            The <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel"/> that the <see cref="P:Rdmp.Core.QueryBuilding.Parameters.ParameterFoundAtLevel.Parameter"/> was found at during query building.  This allows parameters declared in individual <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> to
            be overridden by parameters declared at higher scopes
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterFoundAtLevel.#ctor(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter,Rdmp.Core.QueryBuilding.Parameters.ParameterLevel)">
            <summary>
            Defines that a given parameter was found at a given level during query building.
            </summary>
            <param name="parameter"></param>
            <param name="level"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterFoundAtLevel.ToString">
            <summary>
            Provides human readable description of the parameter and where it was found
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel">
            <summary>
            Describes the hierarchical level at which an ISqlParameter was found at by a ParameterManager.
            
            <para>Do not reorder these!</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel.TableInfo">
            <summary>
            lowest, these are table valued function default values
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel.QueryLevel">
            <summary>
            higher these are explicitly declared properties at the query level e.g. filters, aggregation level (e.g. in the WHERE statements of an AggregateConfiguration on extraction query )
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel.CompositeQueryLevel">
            <summary>
            These are done when joining multiple queries together in an super query (usually separated with set operations such as UNION, EXCEPT etc). See CohortQueryBuilder
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel.Global">
            <summary>
            highest, these are added to the QueryBuilder by the code and should always be preserved, e.g. CohortID is explicitly added by the data export manager.
            </summary>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.Parameters.ParameterManager">
            <summary>
            Handles the accumulation of Parameters in SQL queries ('DECLARE @bob as varchar(10); SET @bob = 'bob').  Because ISqlParameters can exist at many levels
            (e.g. IFilter vs AggregateConfiguration) ParameterManager has to consider what ParameterLevel it finds ISqlParameters at and whether ISqlParameters are 
            functionality identical or not.  For example if a CohortIdentificationConfiguration has two AggregateConfigurations each with an IFilter for healthboard 
            containing an ISqlParameter @hb.  If the declaration and value are the same then the ParameterManager can ignore one.  If the values are different then
            the ParameterManager needs to create renamed versions in memory (SpontaneouslyInventedSqlParameter) and update the IFilter.  However if there is an ISqlParameter
            @hb declared at the root (the CohortIdentificationConfiguration) then it will override both and be used instead.
            
            <para>See ParameterLevel for a description of the various levels ISqlParameters can be found at.</para>
            
            <para>ParameterManager has a ParameterManagerLifecycleState (State) which indicates whether it is still collecting new ISqlParameters or whether it has resolved them
            into a final representation.  </para>
            
            <para>You can merge multiple ParameterManagers together (like CohortQueryBuilder does) by calling ImportAndElevateResolvedParametersFromSubquery which will create the
            final CompositeQueryLevel. </para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.State">
            <summary>
            <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterManager"/> is a state driven object, it gathers all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> then resolves them into a final list.  This 
            property records which stage of that lifecycle it is at.
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.ParametersFoundSoFarInQueryGeneration">
            <summary>
            Collection of all the parameters found at each level so far
            <para>Do not modify this yourself</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Parameters.ParameterManager._memoryRepository">
            <summary>
            Repository for creating temporary aggregate parameters
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.#ctor(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter[])">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterManager"/> with the specified global parameters
            </summary>
            <param name="globals"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.AddParametersFor(System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.TableInfo})">
            <summary>
            Records parameters from the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> at the appropriate <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.AddParametersFor(Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <summary>
            Records parameters from the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> at the appropriate <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.AddParametersFor(System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.IFilter})">
            <summary>
            Records parameters from the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> at the appropriate <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.AddParametersFor(Rdmp.Core.CatalogueLibrary.Data.ICollectSqlParameters,Rdmp.Core.QueryBuilding.Parameters.ParameterLevel)">
            <summary>
            Records parameters from the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ICollectSqlParameters"/> at the specified <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.AddGlobalParameter(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter)">
            <summary>
            Adds a new global parameter which will overridde other parameters declared at lower <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel"/>
            
            <para>The <see cref="P:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.State"/> must be <see cref="F:Rdmp.Core.QueryBuilding.Parameters.ParameterManagerLifecycleState.AllowingGlobals"/> for this to be allowed</para>
            </summary>
            <param name="parameter"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.GetFinalResolvedParametersList">
            <summary>
            Resolves all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> found so far and merges/overrides as appropriate to accomodate identical side by side parameters and 
            global overriding ones etc.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.ClearNonGlobals">
            <summary>
            Removes all non global parameters from the <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterManager"/> and returns the <see cref="P:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.State"/> to allow new parameters
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.ImportAndElevateResolvedParametersFromSubquery(Rdmp.Core.QueryBuilding.Parameters.ParameterManager,System.Collections.Generic.Dictionary{System.String,System.String}@)">
            <summary>
            Imports all TableInfo level paramaters into a super set (with all TableInfo level paramaters from every manager you have imported).  Also imports all
            QueryLevel parameters but for these it will do renames where there are conflicting named parameters, you must 
            
            </summary>
            <param name="toImport"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.GetOverridenParameters">
            <summary>
            Returns all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> which would be overwritten (ignored) because of higher level parameters during <see cref="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.GetFinalResolvedParametersList"/>
            
            <para>Does not change the <see cref="P:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.State"/>of the <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterManager"/></para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.GetOverrideIfAnyFor(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter)">
            <summary>
            Returns the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> which would be overwritten (ignored) because of higher level parameters during <see cref="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.GetFinalResolvedParametersList"/>
            </summary>
            <param name="existing"></param>
            <returns>The overriding parameter or null if there are none</returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.RemoveParameter(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter)">
            <summary>
            Makes the <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterManager"/> forget about the given <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/>
            
            <para>This operation ignores <see cref="P:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.State"/> so you should not use the <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterManager"/> for code generation after calling this method</para>
            </summary>
            <param name="deleteable"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.Parameters.ParameterManager.GetLevelForParameter(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter)">
            <summary>
            Returns the <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterLevel"/> that the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/> was found at or null if has not been added to this <see cref="T:Rdmp.Core.QueryBuilding.Parameters.ParameterManager"/>
            </summary>
            <param name="parameter"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.Parameters.ParameterManagerLifecycleState">
            <summary>
            Describes the stage at which the ParameterManager has reached.  This starts on construction at which time you can set the Globals, once parameter discovery has
            started you cannot add more Globals because they are considered when deciding whether or not to add a given ISqlParameter found at a lower level (e.g. if you 
            have a global @hb then finding @hb on an IFilter can be ignored since there is the global defined).
            
            <para>Finalized occurs when you resolve the parameters collected into a single difinitive set (merging duplicates / overrides etc).</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Parameters.ParameterManagerLifecycleState.AllowingGlobals">
            <summary>
            More global parameters can be added
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Parameters.ParameterManagerLifecycleState.ParameterDiscovery">
            <summary>
            Parameter discovery has started, no more globals can be added
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.Parameters.ParameterManagerLifecycleState.Finalized">
            <summary>
            The final parameter list has been generated and no more parameters can be added
            </summary>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.PrimaryKeyCollisionResolver">
            <summary>
            The RDMP data load engine is designed to prevent duplicate data entering your live database.  This is achieved by requiring a primary key defined by the source
            data (i.e. not an autonum).  However it is expected that semantically correct primary keys will not be perfectly supplied in all cases by data providers, for example
            if 'TestLabCode' is the primary key on biochemistry but duplicates appear with unique values in 'DataAge' it would be reasonable to assume that newer 'DataAge' records
            replace older ones.  Therefore we might decide to keep the primary key as 'TestLabCode' and then discard duplicate records based on preserving the latest 'DataAge'.
            
            <para>This class handles creating the query that deletes duplicates based on the column preference order supplied (See ConfigurePrimaryKeyCollisionResolution). </para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.PrimaryKeyCollisionResolver.#ctor(Rdmp.Core.CatalogueLibrary.Data.ITableInfo)">
            <summary>
            Creates a new collision resolver using the primary keys and resolution order of the supplied <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/>
            </summary>
            <param name="tableInfo"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.PrimaryKeyCollisionResolver.GenerateSQL">
            <summary>
            Get the SQL to run to delete records colliding on primary key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.PrimaryKeyCollisionResolver.GenerateCollisionDetectionSQL">
            <summary>
            Generates the SQL that will be run to determine whether there are any record collisions on primary key (in RAW)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.PrimaryKeyCollisionResolver.GeneratePreviewSQL">
            <summary>
            Generates SQL to show which records would be deleted by primary key collision resolution.  This should be run manually by the data analyst if he is unsure about the 
            resolution order / current primary keys
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.PrimaryKeyCollisionResolver.GetNullSubstituteForComparisonsWithDataType(System.String,System.Boolean)">
            <summary>
            When using ORDER BY to resolve primary key collisions this will specify what substitution to use for null values (such that the ORDER BY works correctly).
            </summary>
            <param name="datatype">The Sql Server column datatype for the column you are substituting</param>
            <param name="min">true to substitute null values for the minimum value of the <paramref name="datatype"/>, false to substitute for the maximum</param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.QueryBuilder">
            <summary>
            This class maintains a list of user defined ExtractionInformation objects.  It can produce SQL which will try to 
            extract this set of ExtractionInformation objects only from the database.  This includes determining which ExtractionInformation
            are Lookups, which tables the various objects come from, figuring out whether they can be joined by using JoinInfo in the catalogue
            
            <para>It will throw when query SQL if it is not possible to join all the underlying tables or there are any other problems.</para>
            
            <para>You can ask it what is on line X or ask what line number has ExtractionInformation Y on it</para>
            
            <para>ExtractionInformation is sorted by column order prior to generating the SQL (i.e. not the order you add them to the query builder)</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.SQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.LimitationSQL">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.SelectColumns">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.TablesUsedInQuery">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.JoinsUsedInQuery">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.CustomLines">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.TopXCustomLine">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.ParameterManager">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.PrimaryExtractionTable">
            <summary>
            Optional field, this specifies where to start gargantuan joins such as when there are 3+ joins and multiple primary key tables e.g. in a star schema.
            If this is not set and there are too many JoinInfos defined in the Catalogue then the class will bomb out with the Exception 
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.RootFilterContainer">
            <summary>
            A container that contains all the subcontainers and filters to be assembled during the query (use a SpontaneouslyInventedFilterContainer if you want to inject your 
            own container tree at runtime rather than referencing a database entity)
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.CheckSyntax">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuilder.SetSalt(System.String)">
            <summary>
            Only use this if you want IColumns which are marked as requiring Hashing to be hashed.  Once you set this on a QueryEditor all fields so marked will be hashed using the
            specified salt
            </summary>
            <param name="salt">A 3 letter string indicating the desired SALT</param>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.Filters">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.TopX">
            <summary>
            Limits the number of returned rows to the supplied maximum or -1 if there is no maximum 
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuilder.SQLOutOfDate">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuilder.#ctor(System.String,System.String,Rdmp.Core.CatalogueLibrary.Data.TableInfo[])">
            <summary>
            Used to build extraction queries based on ExtractionInformation sets
            </summary>
            <param name="limitationSQL">Any text you want after SELECT to limit the results e.g. "DISTINCT" or "TOP 10"</param>
            <param name="hashingAlgorithm"></param>
            <param name="forceJoinsToTheseTables"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuilder.AddColumnRange(Rdmp.Core.QueryBuilding.IColumn[])">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuilder.AddColumn(Rdmp.Core.QueryBuilding.IColumn)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuilder.AddCustomLine(System.String,FAnsi.Discovery.QuerySyntax.QueryComponent)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuilder.RegenerateSQL">
            <summary>
            Updates .SQL Property, note that this is automatically called when you query .SQL anyway so you do not need to manually call it. 
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuilder.GetDistinctRequiredLookups">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuilder.GetParameterDeclarationSQL(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter)">
            <summary>
            Generates Sql to comment, declare and set the initial value for the supplied <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ISqlParameter"/>.
            </summary>
            <param name="sqlParameter"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.QueryBuildingException">
            <summary>
            Thrown when there is a problem with QueryBuilding e.g. being unable to find a compatible IJoin (JoinInfo) between two TableInfos required by a query (based on the columns
            chosen for SELECT).
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryBuildingException.ProblemObjects">
            <summary>
            List of objects thought to be responsible for the query generation failing
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuildingException.#ctor(System.String,System.Collections.Generic.IEnumerable{MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable},System.Exception)">
            <inheritdoc cref="M:Rdmp.Core.QueryBuilding.QueryBuildingException.#ctor(System.String)"/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuildingException.#ctor(System.String,System.Exception)">
            <inheritdoc cref="M:Rdmp.Core.QueryBuilding.QueryBuildingException.#ctor(System.String)"/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuildingException.#ctor(System.String)">
            <summary>
            Creates a new Exception for when there is a problem with QueryBuilding e.g. being unable to find a compatible IJoin (JoinInfo) between two TableInfos required by a query
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryBuildingException.#ctor(System.String,System.Object[])">
            <summary>
            Type unsafe overload of the IEnumerable'IMapsDirectlyToDatabaseTable' constructor, objects that are not of type IMapsDirectlyToDatabaseTable will be ignored, use if you are slopy coding and have objects of interface type which might be concrete IMapsDirectlyToDatabaseTable objects or might be spontaneous objects or nulls! - oh yeah that's what this constructor does
            </summary>
            <param name="message"></param>
            <param name="problemObjects"></param>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.QueryTimeColumn">
            <summary>
            The SELECT portion of QueryBuilder is built up via AddColumn which takes an IColumn.  Each IColumn is a single line of SELECT Sql which might be as
            simple as the name of a column but might be a method with an alias or even a count e.g. 'sum(distinct mycol) as Total'.  These IColumns are wrapped by
            QueryTimeColumn which is a wrapper for IColumn which is gradually populated with facts discovered during QueryBuilding such as whether it is from a Lookup 
            Table, whether it maps to an underlying ColumnInfo etc.  These facts are used later on by QueryBuilder to decide which tables/joins are needed in the FROM 
            section of the query etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryTimeColumn.IsIsolatedLookupDescription">
            <summary>
            The <see cref="P:Rdmp.Core.QueryBuilding.QueryTimeColumn.UnderlyingColumn"/> is from a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> and is a description column but there was no associated
            foreign key column found in the query.
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryTimeColumn.IsLookupForeignKey">
            <summary>
            The <see cref="P:Rdmp.Core.QueryBuilding.QueryTimeColumn.UnderlyingColumn"/> is NOT from a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> but it is a code column (foreign key) which could be linked to a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/>. 
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> will be included in the query if one or more description columns follow this column in the query
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryTimeColumn.IsLookupDescription">
            <summary>
            The <see cref="P:Rdmp.Core.QueryBuilding.QueryTimeColumn.UnderlyingColumn"/> is from a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> and is a description column and there WAS an associated foreign key column previously found in the query.
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryTimeColumn.LookupTableAlias">
            <summary>
            The alias given to the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> table this column belongs to (if any).  This allows you to have the same description column several times in the query e.g.
            SendingLocation, Description, ReleaseLocation, Description
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryTimeColumn.LookupTable">
            <summary>
            The <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> that this column is related in the context of the query being generated
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryTimeColumn.IColumn">
            <summary>
            The SELECT column definition including extraction options such as Order and HashOnDataRelease etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.QueryBuilding.QueryTimeColumn.UnderlyingColumn">
            <summary>
            The actual database model layer column.  The same <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ColumnInfo"/> can appear multiple times in the same query e.g. if extracting DateOfBirth and YearOfBirth where
            these are both transforms of the same underlying column.
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryTimeColumn.#ctor(Rdmp.Core.QueryBuilding.IColumn)">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.QueryBuilding.QueryTimeColumn"/> ready for annotation with facts as they are discovered during query building
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryTimeColumn.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryTimeColumn.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryTimeColumn.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryTimeColumn.SetLookupStatus(Rdmp.Core.QueryBuilding.QueryTimeColumn[],System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.TableInfo})">
            <summary>
            Computes and records the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> related facts about all the <see cref="T:Rdmp.Core.QueryBuilding.QueryTimeColumn"/> provided when building a query which requires the 
            supplied list of <paramref name="tablesUsedInQuery"/>.
            </summary>
            <param name="ColumnsInOrder"></param>
            <param name="tablesUsedInQuery"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryTimeColumn.GetSelectSQL(System.String,System.String,FAnsi.Discovery.QuerySyntax.IQuerySyntaxHelper)">
            <summary>
            Returns the line of SELECT Sql for this column that will appear in the final query
            </summary>
            <param name="hashingPattern"></param>
            <param name="salt"></param>
            <param name="syntaxHelper"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryTimeColumn.CheckSyntax">
            <summary>
            Runs checks on the <see cref="T:Rdmp.Core.QueryBuilding.IColumn"/> and translates any failures into <see cref="T:System.Data.SyntaxErrorException"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.QueryTimeColumn.IsLookupForeignKeyActuallyUsed(System.Collections.Generic.List{Rdmp.Core.QueryBuilding.QueryTimeColumn})">
            <summary>
            For a given column that <see cref="P:Rdmp.Core.QueryBuilding.QueryTimeColumn.IsLookupForeignKey"/> returns true if there is an associated column from the lookup (i.e. a description column). This
            should determine whether or not to link to the table in the FROM section of the query. 
            </summary>
            <param name="selectColumns"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.ReleaseIdentifierSubstitution">
            <summary>
            Records how (via SQL) replace the private patient identifier column (e.g. CHI) with the release identifier (e.g. swap [biochemistry]..[chi] for 
            [cohort]..[ReleaseId]).  Also includes the Join SQL string for linking the cohort table (which contains the ReleaseId e.g. [cohort]) with the dataset
            table (e.g. [biochemistry]). 
            
            <para>This class is an IColumn and is designed to be added as a new Column to a QueryBuilder as normal (See ExtractionQueryBuilder)</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.QueryBuilding.ReleaseIdentifierSubstitution.OriginalDatasetColumn">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper">
            <summary>
            Helps generate SELECT and GROUP By queries for ISqlQueryBuilders.  This includes all the shared functionality such as finding all IFilters, Lookups,
            which tables to JOIN on etc.  Also handles CustomLine injection which is where you inject arbitrary lines into the query at specific points (See CustomLine).
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.GetAllFiltersUsedInContainerTreeRecursively(Rdmp.Core.CatalogueLibrary.Data.IContainer)">
            <summary>
            Returns all IFilters that are in the root IContainer or any subcontainers
            </summary>
            <param name="currentContainer"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.FindLookups(Rdmp.Core.QueryBuilding.ISqlQueryBuilder)">
            <inheritdoc cref="M:Rdmp.Core.QueryBuilding.QueryTimeColumn.SetLookupStatus(Rdmp.Core.QueryBuilding.QueryTimeColumn[],System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.TableInfo})"/>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.FindRequiredJoins(Rdmp.Core.QueryBuilding.ISqlQueryBuilder)">
            <summary>
            Must be called only after the ISqlQueryBuilder.TablesUsedInQuery has been set (see GetTablesUsedInQuery).  This method will resolve how 
            the various tables can be linked together.  Throws QueryBuildingException if it is not possible to join the tables with any known 
            JoinInfos / Lookup knowledge
            </summary>
            <param name="qb"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.GetDistinctRequiredLookups(Rdmp.Core.QueryBuilding.ISqlQueryBuilder)">
            <summary>
            Returns all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> linked to for the FROM section of the query
            </summary>
            <param name="qb"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.GetTablesUsedInQuery(Rdmp.Core.QueryBuilding.ISqlQueryBuilder,Rdmp.Core.CatalogueLibrary.Data.TableInfo@,Rdmp.Core.CatalogueLibrary.Data.TableInfo[])">
            <summary>
            Make sure you have set your Filters and SelectColumns properties before calling this method so that it can find table dependencies
            </summary>
            <param name="qb"></param>
            <param name="primaryExtractionTable"></param>
            <param name="forceJoinsToTheseTables"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.GetFROMSQL(Rdmp.Core.QueryBuilding.ISqlQueryBuilder)">
            <summary>
            Generates the FROM sql including joins for all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> required by the <see cref="T:Rdmp.Core.QueryBuilding.ISqlQueryBuilder"/>.  <see cref="T:Rdmp.Core.CatalogueLibrary.Data.JoinInfo"/> must exist for 
            this process to work 
            </summary>
            <param name="qb"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.AddCustomLine(Rdmp.Core.QueryBuilding.ISqlQueryBuilder,System.String,FAnsi.Discovery.QuerySyntax.QueryComponent)">
            <summary>
            Add a custom line of code into the query at the specified position.  This will be maintained throughout the lifespan of the object such that if
            you add other columns etc then your code will still be included at the appropriate position.
            </summary>
            <param name="builder"></param>
            <param name="text"></param>
            <param name="positionToInsert"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.GetWHERESQL(Rdmp.Core.QueryBuilding.ISqlQueryBuilder)">
            <summary>
            Generates the WHERE section of the query for the <see cref="T:Rdmp.Core.QueryBuilding.ISqlQueryBuilder"/> based on recursively processing the <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.RootFilterContainer"/>
            </summary>
            <param name="qb"></param>
            <returns>WHERE block or empty string if there are no <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IContainer"/></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.IsEnabled(Rdmp.Core.CatalogueLibrary.Data.IContainer)">
            <summary>
            Containers are enabled if they do not support disabling (<see cref="T:MapsDirectlyToDatabaseTable.IDisableable"/>) or are <see cref="P:MapsDirectlyToDatabaseTable.IDisableable.IsDisabled"/> = false
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.IsEnabled(Rdmp.Core.CatalogueLibrary.Data.IFilter)">
            <summary>
            Filters are enabled if they do not support disabling (<see cref="T:MapsDirectlyToDatabaseTable.IDisableable"/>) or are <see cref="P:MapsDirectlyToDatabaseTable.IDisableable.IsDisabled"/> = false
            </summary>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.GetSyntaxHelper(System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.TableInfo})">
            <summary>
            Returns the unique database server type <see cref="T:FAnsi.Discovery.QuerySyntax.IQuerySyntaxHelper"/> by evaluating the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> used in the query.
            <para>Throws <see cref="T:Rdmp.Core.QueryBuilding.QueryBuildingException"/> if the tables are from mixed server types (e.g. MySql mixed with Oracle)</para> 
            </summary>
            <param name="tablesUsedInQuery"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.HandleTopX(Rdmp.Core.QueryBuilding.ISqlQueryBuilder,FAnsi.Discovery.QuerySyntax.IQuerySyntaxHelper,System.Int32)">
            <summary>
            Applies <paramref name="topX"/> to the <see cref="T:Rdmp.Core.QueryBuilding.ISqlQueryBuilder"/> as a <see cref="T:FAnsi.Discovery.QuerySyntax.CustomLine"/> based on the database engine syntax e.g. LIMIT vs TOP
            and puts in in the correct location in the query (<see cref="T:FAnsi.Discovery.QuerySyntax.QueryComponent"/>)
            </summary>
            <param name="queryBuilder"></param>
            <param name="syntaxHelper"></param>
            <param name="topX"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.ClearTopX(Rdmp.Core.QueryBuilding.ISqlQueryBuilder)">
            <summary>
            Removes the SELECT TOP X logic from the supplied <see cref="T:Rdmp.Core.QueryBuilding.ISqlQueryBuilder"/>
            </summary>
            <param name="queryBuilder"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SqlQueryBuilderHelper.GetCustomLinesSQLForStage(Rdmp.Core.QueryBuilding.ISqlQueryBuilder,FAnsi.Discovery.QuerySyntax.QueryComponent)">
            <summary>
            Returns all <see cref="T:FAnsi.Discovery.QuerySyntax.CustomLine"/> declared in <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.CustomLines"/> for the given stage but also adds some new ones to ensure valid syntax (for example
            adding the word WHERE/AND depending on whether there is an existing <see cref="P:Rdmp.Core.QueryBuilding.ISqlQueryBuilder.RootFilterContainer"/>.
            </summary>
            <param name="queryBuilder"></param>
            <param name="stage"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.SyntaxChecking.ColumnSyntaxChecker">
            <summary>
            Checks whether an IColumn has an alias and if so whether it is wrapped and whether it contains invalid characters or whitespace
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SyntaxChecking.ColumnSyntaxChecker.#ctor(Rdmp.Core.QueryBuilding.IColumn)">
            <summary>
            Prepares the checker to check the IColumn supplied
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SyntaxChecking.ColumnSyntaxChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks to see if there is an alias and if there is whether it is wrapped. If it is not wrapped and there are invalid characters or whitespace in the alias this causes a SyntaxErrorException to be thrown.
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.SyntaxChecking.FilterSyntaxChecker">
            <summary>
            Checks bracket parity of where SQL of IFilter and syntax validity of parameters which are char based 
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SyntaxChecking.FilterSyntaxChecker.#ctor(Rdmp.Core.CatalogueLibrary.Data.IFilter)">
            <summary>
            Prepares the checker to check the IFilter supplied
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SyntaxChecking.FilterSyntaxChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks to see if the WhereSQL contains a closing bracket for every opening bracket (see ParityCheckCharacterPairs for more detail) and also checks the syntax validity of each parameter if it is char based (see CheckSyntax for more detail)
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.SyntaxChecking.ParameterSyntaxChecker">
            <summary>
            Checks syntax validity of ISqlParameter
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SyntaxChecking.ParameterSyntaxChecker.#ctor(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter)">
            <summary>
            Prepares the checker to check the ISqlParameter supplied
            </summary>
            <param name="parameter"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SyntaxChecking.ParameterSyntaxChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks to see if the syntax of char based parameters is valid (see CheckSyntax for more details)
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.QueryBuilding.SyntaxChecking.SyntaxChecker">
            <summary>
            Base class for all Checkers which check the Sql Syntax of an object e.g. an IFilter's WhereSQL
            </summary>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SyntaxChecking.SyntaxChecker.ParityCheckCharacterPairs(System.Char[],System.Char[],System.String)">
            <summary>
            Checks to see if there is a closing bracket for every opening bracket (or any other characters that come in open/close pairs.  Throws SyntaxErrorException if there
            is a mismatch in the number of opening/closing of any of the character pairs passed into the method.
            </summary>
            <param name="openingCharacters">An array of opening characters which start a condition e.g. '['</param>
            <param name="closingCharacters">An array of closing characters which must be in the same order (semantically) and size as openingCharacters e.g. if open array element 0 is '[' then closing array element 0 must be ']' </param>
            <param name="sql">The string of text to check for equal numbers of opening/closing characters in</param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SyntaxChecking.SyntaxChecker.CheckSyntax(Rdmp.Core.CatalogueLibrary.Data.ISqlParameter)">
            <summary>
            Checks to ensure char based parameters contains a value, are not longer than the expected length and contain either single quotes or an @ symbol before performing bracket parity checks
            </summary>
            <param name="parameter"></param>
        </member>
        <member name="M:Rdmp.Core.QueryBuilding.SyntaxChecking.SyntaxChecker.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Override in child classes to check the currently configured Sql of the object
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="T:Rdmp.Core.QueryCaching.Aggregation.Arguments.CacheCommitExtractableAggregate">
             <summary>
             Request to cache an AggregateConfiguration that results in a DataTable suitable for producing a useful graph (e.g. 'number of records per year in 
             Biochemistry by healthboard').  Should not contain patient identifiers.
             
             <para>Serves as an input to CachedAggregateConfigurationResultsManager.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.QueryCaching.Aggregation.Arguments.CacheCommitIdentifierList">
            <summary>
            Request to cache an AggregateConfiguration that is a cohort identifier list subquery from a CohortIdentificationConfiguration (it is a query that 
            identifies patients fitting certain criteria e.g. 'patients with HBA1c biochemistry results > 50').  
            
            <para>Serves as an input to CachedAggregateConfigurationResultsManager.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.QueryCaching.Aggregation.Arguments.CacheCommitJoinableInceptionQuery">
             <summary>
             Request to cache an AggregateConfiguration that is a 'patient index table' (See JoinableCohortAggregateConfiguration).  This will include patient 
             identifier and some useful columns (e.g. 'prescription dates for methadone by patient id').  The resulting cached DataTable will be joined against
             patient identifier lists to answer questions such as 'who has been hospitalised (SMR01) within 6 months of a prescription for methadone'.
             
             <para>When doing such a join on two large datasets you can end up with a query that will never complete without intermediate caching.</para>
             
             <para>Serves as an input to CachedAggregateConfigurationResultsManager.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.QueryCaching.Aggregation.CachedAggregateConfigurationResultsManager">
            <summary>
            Handles the caching and versioning of AggregateConfigurations in a QueryCaching database (QueryCaching.Database.csproj).  Query caching is the process
            of storing the SQL query and resulting DataTable from running an Aggregate Configuration SQL query (Usually built by an AggregateBuilder).  
            
            <para>Caching is vital for large CohortIdentificationConfigurations which feature many complicated subqueries with WHERE conditions and even Patient Index 
            Tables (See JoinableCohortAggregateConfiguration).  The only way some of these queries can finish in a sensible time frame (i.e. minutes instead of days) 
            is to execute each subquery (AggregateConfiguration) and cache the resulting identifier lists with primary key indexes.  The 
            CohortIdentificationConfiguration can then be built into a query that uses the cached results (See CohortQueryBuilder).</para>
            
            <para>In order to ensure the cache is never stale the exact SQL query is stored in a table (CachedAggregateConfigurationResults) so that if the user changes
            the AggregateConfiguration the cached DataTable is discarded (until the user executes and caches the new version).</para>
            
            <para> CachedAggregateConfigurationResultsManager can cache any CacheCommitArguments (includes not just patient identifier lists but also aggregate graphs and
            patient index tables).</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.BitmapWithDescription">
            <summary>
            Describes an Aggregate Graph or Heatmap etc with optional description/headers
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.DatabaseAccessPrivileges.AccessRightsReportPrerequisites">
            <summary>
            Hacky string container class that holds a single variable: the script needed to run on a Microsoft Sql Server to support WordAccessRightsByUser and 
            WordAccessRightsByDatabase classes.  This SQL creates a database called Audit and a stored proceedure that longitudinally snapshots database access
            permissions (not something Sql Server handles normally) so that you have a record of who had access to what and when. 
            </summary>
        </member>
        <member name="F:Rdmp.Core.Reports.DatabaseAccessPrivileges.AccessRightsReportPrerequisites.SQL">
            <summary>
            Sql to create the Audit database in an Sql Server (allows longitudinal tracking of what users have access to what tables/databases).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.DatabaseAccessPrivileges.WordAccessRightsByDatabase">
            <summary>
            Generates a historic report of which user accounts have access to which databases by database (requires AccessRightsReportPrerequisites to have been run on 
            your database server an for the snapshotting stored proceedure to have been called at least once)
            </summary>
        </member>
        <member name="M:Rdmp.Core.Reports.DatabaseAccessPrivileges.WordAccessRightsByDatabase.#ctor(FAnsi.Discovery.DiscoveredDatabase)">
            <summary>
            Prepares to generate a report based on the Audit recorded in the supplied Audit database <paramref name="dbInfo"/> <see cref="T:Rdmp.Core.Reports.DatabaseAccessPrivileges.AccessRightsReportPrerequisites"/>
            </summary>
            <param name="dbInfo">The Audit database</param>
        </member>
        <member name="M:Rdmp.Core.Reports.DatabaseAccessPrivileges.WordAccessRightsByDatabase.GenerateWordFile">
            <summary>
            Creates a new word document in a temp folder which contains aggregate data about which users have access to which databases.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.DatabaseAccessPrivileges.WordAccessRightsByUser">
            <summary>
            Generates a historic report of which user accounts have access to which databases by user (requires AccessRightsReportPrerequisites to have been run on 
            your database server an for the snapshotting stored proceedure to have been called at least once)
            </summary>
        </member>
        <member name="M:Rdmp.Core.Reports.DatabaseAccessPrivileges.WordAccessRightsByUser.#ctor(FAnsi.Discovery.DiscoveredDatabase,System.Boolean)">
            <summary>
            Prepares to generate a report based on the Audit recorded in the supplied Audit database <paramref name="dbInfo"/> <see cref="T:Rdmp.Core.Reports.DatabaseAccessPrivileges.AccessRightsReportPrerequisites"/>
            </summary>
            <param name="dbInfo">The Audit database</param>
            <param name="currentUsersOnly">True to only show users who still exist, False to also include deleted users</param>
        </member>
        <member name="M:Rdmp.Core.Reports.DatabaseAccessPrivileges.WordAccessRightsByUser.GenerateWordFile">
            <summary>
            Creates a new word document in a temp folder which contains aggregate data about which users have access to which databases.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.DatabaseSizeReport">
            <summary>
            Calculates the size of all the databases on an server, the rowcounts of all talbes as well as summarising key value pair descriptors of the server (version etc).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.DitaCatalogueExtractor">
            <summary>
            Generates an extract of all the Catalogues and CatalogueItems in your Catalogue database in .dita format.  Dita is apparently all the rage when it comes to metadata
            sharing.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Reports.DitaCatalogueExtractor.#ctor(Rdmp.Core.Repositories.ICatalogueRepository,System.IO.DirectoryInfo)">
            <summary>
            Prepares class to convert all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> stored in the <paramref name="repository"/> into .dita files containing dataset/column descriptions.
            </summary>
            <param name="repository"></param>
            <param name="folderToCreateIn"></param>
        </member>
        <member name="M:Rdmp.Core.Reports.DitaCatalogueExtractor.Extract(ReusableLibraryCode.Progress.IDataLoadEventListener)">
            <summary>
            Generates the dita files and logs progress / errors to the <paramref name="listener"/>
            </summary>
            <param name="listener"></param>
        </member>
        <member name="M:Rdmp.Core.Reports.DitaCatalogueExtractor.Check(ReusableLibraryCode.Checks.ICheckNotifier)">
            <summary>
            Checks whether the dita file generation is likely to work e.g. that all datasets have unique acronymns etc
            </summary>
            <param name="notifier"></param>
        </member>
        <member name="M:Rdmp.Core.Reports.DitaCatalogueExtractor.GetAcronymSuggestionFromCatalogueName(System.String)">
            <summary>
            Suggests an appropriate short acryonymn based on the supplied full <paramref name="name"/> e.g. BIO for Biochemistry
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Reports.DocumentationReportFormsAndControls">
            <summary>
            Extracts comments from SourceCodeForSelfAwareness.zip for the requested Types which are made available in the public property Summaries.  This ensures that you always
            have the latest documentation available at runtime and that descriptions match the codebase 100%.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.DocumentationReportFormsAndControlsOfficeBit">
            <summary>
            Turns the comment summaries extracted from SourceCodeForSelfAwareness.zip by DocumentationReportFormsAndControls into a user readable Microsoft Word file.  This
            includes writing out the headers and images of the controls.  Note RequestTypeImagesHandler delegate is used to generate the actual interface images.  This is done
            normally by launching the UI control and programatically screencapturing it (See DocumentationReportFormsAndControlsUI)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.DocumentationReportMapsDirectlyToDatabase">
            <summary>
            Extracts comments from SourceCodeForSelfAwareness.zip for all IMapsDirectlyToDatabaseTable object Types (all things that the user can store in the Catalogue/Data Export
            repository - e.g. Catalogues, TableInfos etc).  This ensures that the help is always up-to-date and matches the source code 100%.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.DocumentationReportMapsDirectlyToDatabaseOfficeBit">
            <summary>
            Turns the IMapsDirectlyToDatabaseTable class descriptions generated by DocumentationReportMapsDirectlyToDatabase into a user readable Microsoft Word Docx file 
            containing comments, object type name and corresponding icon within RDMP.  This allows the user to see what a Project is and the icon what an ExtractionConfiguration
            is etc and for those descriptions/icons to always match 100% the live/installed version of RDMP.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.DocXHelper">
            <summary>
            Base class for all reports which generate Microsoft DocX files.  Note that the DocX library is used to create the .docx file so it doesn't actually require Microsoft
            Office to be installed on the machine using the class but in order to open the resulting files the user will need something compatible with .docx.
            
            <para>Also contains all the helper methods for simplifying (even further) the awesome DocX API for adding paragraphs/pictures/tables.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition">
            <summary>
            Class describing the RDMP exposed attributes defined in Dublin Core metadata format.
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition.Title">
            <summary>
            A name given to the resource. See http://www.dublincore.org/documents/dces/
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition.Alternative">
            <summary>
            Dublin Core property see http://www.dublincore.org/documents/dces/
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition.Subject">
            <summary>
            Dublin Core property see http://www.dublincore.org/documents/dces/
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition.Description">
            <summary>
            Dublin Core property see http://www.dublincore.org/documents/dces/
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition.Publisher">
            <summary>
            Dublin Core property see http://www.dublincore.org/documents/dces/
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition.IsPartOf">
            <summary>
            Dublin Core property see http://www.dublincore.org/documents/dces/
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition.Identifier">
            <summary>
            Dublin Core property see http://www.dublincore.org/documents/dces/
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition.Modified">
            <summary>
            Dublin Core property see http://www.dublincore.org/documents/dces/
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition.Format">
            <summary>
            Dublin Core property see http://www.dublincore.org/documents/dces/
            </summary>
        </member>
        <member name="M:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition.WriteXml(System.IO.Stream)">
            <summary>
            Writes the defintion in the format listed in http://dublincore.org/documents/dc-xml-guidelines/
            </summary>
            <param name="to"></param>
        </member>
        <member name="M:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition.LoadFrom(System.Xml.Linq.XElement)">
            <summary>
            Parses elements such as title, subject, description etc out of a metadata tag expected to follow the Dublin Core Xml guidlines ( http://dublincore.org/documents/dc-xml-guidelines/)
            </summary>
            <param name="element"></param>
        </member>
        <member name="T:Rdmp.Core.Reports.DublinCore.DublinCoreTranslater">
            <summary>
            Handles updating / extracting data from RDMP objects using the interchange object DublinCoreDefinition
            </summary>
        </member>
        <member name="M:Rdmp.Core.Reports.DublinCore.DublinCoreTranslater.Fill``1(``0,Rdmp.Core.Reports.DublinCore.DublinCoreDefinition)">
            <summary>
            Populates the given <paramref name="toFill"/> with the descriptions stored in <paramref name="fillWith"/>.   This will overwrite previous values. 
            
            <para>Not all object types T are supported</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="toFill"></param>
            <param name="fillWith"></param>
        </member>
        <member name="M:Rdmp.Core.Reports.DublinCore.DublinCoreTranslater.GenerateFrom``1(``0)">
            <summary>
            Generates a <see cref="T:Rdmp.Core.Reports.DublinCore.DublinCoreDefinition"/> for the provided <paramref name="generateFrom"/> by reading specific fields out of the object
            and translating them to dublin core metadata fields.
            
            <para>Not all object types T are supported</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="generateFrom"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Reports.ExtractionTime.WordDataReleaseFileGenerator">
            <summary>
            Generates a Microsoft Word DocX file containing information about all the datasets extracted (and released) as part of a Data Release.  This includes
            row counts and unique patient counts as well as the number of patients in the original cohort (not all patients will appear in all datasets).  Also
            included are the tickets for the project, the cohort ID number etc
            </summary>
        </member>
        <member name="M:Rdmp.Core.Reports.ExtractionTime.WordDataReleaseFileGenerator.GetFirstProCHIPrefix">
            <summary>
            Returns the first 3 digits of the first release identifier in the cohort (this is very hic specific).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Reports.GovernanceReport">
            <summary>
            Processes all GovernancePeriod and Catalogues into a CSV report about which datasets are covered by which governance periods, which periods have expired (and there
            is no corresponding follow on GovernancePeriod) and which Catalogues are not covered by any governance.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Reports.GovernanceReport.OutputGovernanceList(System.Collections.Generic.Dictionary{Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod,Rdmp.Core.CatalogueLibrary.Data.ICatalogue[]},System.Text.StringBuilder,System.Boolean)">
            <summary>
            Pass false for active or true for expired
            </summary>
            <param name="govs"></param>
            <param name="expired"></param>
        </member>
        <member name="T:Rdmp.Core.Reports.IDetermineDatasetTimespan">
            <summary>
            A class that can determine the actual dataset span of a given catalogue e.g. one strategy might be to have the user enter manually the start and end date.  A better
            strategy would be to consult the latest Data Quality Engine results to see what the realistic start/end dates are (e.g. discarding outliers / future dates etc)
            </summary>
        </member>
        <member name="M:Rdmp.Core.Reports.IDetermineDatasetTimespan.GetHumanReadableTimepsanIfKnownOf(Rdmp.Core.CatalogueLibrary.Data.Catalogue,System.Boolean)">
            <summary>
            Summarises the range of data in the tables that underly the <paramref name="catalogue"/> if known (e.g. based on the last recorded DQE results).
            </summary>
            <param name="catalogue"></param>
            <param name="discardOutliers">True to attempt to throw out outlier rows when determining the dataset timespan</param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Reports.RequestCatalogueImagesHandler">
            <summary>
            Describes a method that generates images for a <seealso cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> e.g. aggregate graphs
            </summary>
            <param name="catalogue"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Reports.MetadataReport">
            <summary>
            Generates a high level summary Microsoft Word DocX file of one or more Catalogues.  This includes the rowcount, distinct patient count, description and descriptions
            of extractable columns as well as an Appendix of Lookups.  In addition any IsExtractable AggregateConfiguration graphs will be run and screen captured and added to 
            the report (including heatmap if a dynamic pivot is included in the graph).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Reports.MetadataReportArgs">
            <summary>
            Arguments for the <see cref="T:Rdmp.Core.Reports.MetadataReport"/> class which generates a descriptive human readable report about what columns are extracted from the dataset and the 
            data in the underlying tables.
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.MetadataReportArgs.Catalogues">
            <summary>
            Which datasets to run the metadata report on (all selected Catalogues will appear in the same output file).
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.MetadataReportArgs.Timeout">
            <summary>
            The length of time to allow queries (e.g. distinct rowcount / graphs) to run for before giving up
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.MetadataReportArgs.IncludeRowCounts">
            <summary>
            True to generate counts of number of rows in the table under  in the table under the <see cref="P:Rdmp.Core.Reports.MetadataReportArgs.Catalogues"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.MetadataReportArgs.IncludeDistinctIdentifierCounts">
            <summary>
            True to generate a count of the distinct values in the <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.IsExtractionIdentifier"/> column (if any) in the table under the <see cref="P:Rdmp.Core.Reports.MetadataReportArgs.Catalogues"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.MetadataReportArgs.SkipImages">
            <summary>
            True to skip generating any images / graphs etc
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.MetadataReportArgs.TimespanCalculator">
            <summary>
            The class responsible for figuring out the span of time covered by data in the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/>.  This might include throwing out outliers etc.  It may be
            based on the last DQE run on the dataset (therefore could be out of date). 
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.MetadataReportArgs.IncludeDeprecatedItems">
            <summary>
            True to output data about <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/> which are marked <see cref="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.Deprecated"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.MetadataReportArgs.IncludeInternalItems">
            <summary>
            True to output data about <see cref="T:Rdmp.Core.CatalogueLibrary.Data.CatalogueItem"/> which are marked <see cref="F:Rdmp.Core.CatalogueLibrary.Data.ExtractionCategory.Internal"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.Reports.MetadataReportArgs.MaxLookupRows">
            <summary>
            When outputting <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> tables this is the maximum number of rows that will be written from the lookup table.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.CatalogueRepository">
            <inheritdoc cref="T:Rdmp.Core.Repositories.ICatalogueRepository"/>
        </member>
        <member name="P:Rdmp.Core.Repositories.CatalogueRepository.AggregateForcedJoinManager">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.Repositories.CatalogueRepository.GovernanceManager">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.Repositories.CatalogueRepository.TableInfoCredentialsManager">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.Repositories.CatalogueRepository.JoinManager">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.Repositories.CatalogueRepository.MEF">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.Repositories.CatalogueRepository.CommentStore">
            <inheritdoc/>
        </member>
        <member name="P:Rdmp.Core.Repositories.CatalogueRepository.CohortContainerManager">
            <inheritdoc/>
        </member>
        <member name="F:Rdmp.Core.Repositories.CatalogueRepository.SuppressHelpLoading">
            <summary>
            By default CatalogueRepository will execute DocumentationReportMapsDirectlyToDatabase which will load all the Types and find documentation in the source code for 
            them obviously this affects test performance so set this to true if you want it to skip this process.  Note where this is turned on, it's in the static constructor
            of DatabaseTests which means if you stick a static constructor in your test you can override it if you need access to the help text somehow in your test
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.CatalogueRepository.FilterManager">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.CatalogueRepository.#ctor(System.Data.Common.DbConnectionStringBuilder)">
            <summary>
            Sets up an <see cref="T:MapsDirectlyToDatabaseTable.IRepository"/> which connects to the database <paramref name="catalogueConnectionString"/> to fetch/create <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/> objects.
            </summary>
            <param name="catalogueConnectionString"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.CatalogueRepository.GetDefaultLogManager">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.CatalogueRepository.GetAllParametersForParentTable(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.CatalogueRepository.GetTicketingSystem">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.CatalogueRepository.GetReferencesTo``1(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Returns all objects of Type T which reference the supplied object <paramref name="o"/>
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Repositories.Construction.ObjectConstructor">
            <summary>
            Simplifies identifying and invoking ConstructorInfos on Types (reflection).  This includes identifying a suitable Constructor on a class Type based on the
            provided parameters and invoking it.  Also implicitly supports hypotheticals e.g. 'heres a TableInfo, construct class X with the TableInfo paramter or if 
            it has a blank constructor that's fine too or if it takes ITableInfo that's fine too... just use whatever works'.  If there are multiple matching constructors
            it will attempt to find the 'best' (See InvokeBestConstructor for implementation).
            
            <para>If there are no compatible constructors you will get an ObjectLacksCompatibleConstructorException.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Construction.ObjectConstructor.Construct(System.Type)">
            <summary>
            Constructs a new instance of Type t using the blank constructor
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Construction.ObjectConstructor.Construct(System.Type,Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator,System.Boolean)">
            <summary>
            Constructs a new instance of Type t using the default constructor or one that takes an IRDMPPlatformRepositoryServiceLocator (or any derrived class)
            </summary>
            <param name="t"></param>
            <param name="serviceLocator"></param>
            <param name="allowBlank"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Construction.ObjectConstructor.Construct(System.Type,Rdmp.Core.Repositories.ICatalogueRepository,System.Boolean)">
            <summary>
            Constructs a new instance of Type t using the default constructor or one that takes an ICatalogueRepository (or any derrived class)
            </summary>
            <param name="t"></param>
            <param name="catalogueRepository"></param>
            <param name="allowBlank"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Construction.ObjectConstructor.ConstructIMapsDirectlyToDatabaseObject``1(System.Type,``0,System.Data.Common.DbDataReader)">
            <summary>
            Constructs a new instance of Type objectType by invoking the constructor MyClass(IRepository x, DbDataReader r) (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/>).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="objectType"></param>
            <param name="repositoryOfTypeT"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Construction.ObjectConstructor.Construct``1(System.Type,``0,System.Boolean)">
            <summary>
            Constructs an instance of object of Type 'typeToConstruct' which should have a compatible constructor taking an object or interface compatible with T
            or a blank constructor (optionally)
            </summary>
            <typeparam name="T">The parameter type expected to be in the constructor</typeparam>
            <param name="typeToConstruct">The type to construct an instance of</param>
            <param name="constructorParameter1">a value to feed into the compatible constructor found for Type typeToConstruct in order to produce an instance</param>
            <param name="allowBlank">true to allow calling the blank constructor if no matching constructor is found that takes a T</param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Construction.ObjectConstructor.GetConstructors``2(System.Type)">
            <summary>
            Returns all constructors defined for class 'type' that are compatible with the parameters T and T2
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Construction.ObjectConstructor.GetConstructors(System.Type,System.Boolean,System.Boolean,System.Object[])">
            <summary>
            Returns all constructors defined for class 'type' which are compatible with any set or subset of the provided parameters.  The return value is a dictionary
            of all compatible constructors with the objects needed to invoke them.
            </summary>
            <param name="type"></param>
            <param name="parameterObjects"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Construction.ObjectConstructor.GetBestObjectForPopulating(System.Type,System.Object[])">
            <summary>
            Returns the best object from parameterObjects for populating an argument of the provided Type.  This is done by looking for an exact Type match first
            then if none of those exist, it will look for a single object assignable to the parameter type.  If at any point there is two or more matching parameterObjects
            then an <seealso cref="T:Rdmp.Core.Repositories.Construction.ObjectLacksCompatibleConstructorException"/> will be thrown.
            
            <para>If there are no objects provided that match any of the provided parameterObjects then null gets returned.</para>
            </summary>
            <param name="parameterType"></param>
            <param name="parameterObjects"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Construction.ObjectConstructor.HasBlankConstructor(System.Type)">
            <summary>
            Returns true if the Type has a blank constructor
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Construction.ObjectConstructor.ConstructIfPossible(System.Type,System.Object[])">
            <summary>
            Attempts to construct an instance of Type typeToConstruct using the provided constructorValues.  This must match on parameter number but ignores order
            so if you pass new Obj1(),new Obj2() it could invoke either MyClass(Obj1 a,Obj2 b) or MyClass(Obj2 a, Obj1 b).  
            <para>Throws <see cref="T:Rdmp.Core.Repositories.Construction.ObjectLacksCompatibleConstructorException"/> if there are multiple constructors that match the constructorValues</para>
            
            <para>Does not invoke the default constructor unless you leave constructorValues blank</para>
            <para>returns null if no compatible constructor is found</para>
            </summary>
            <param name="typeToConstruct"></param>
            <param name="constructorValues"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Repositories.Construction.ObjectLacksCompatibleConstructorException">
            <summary>
            Exception thrown when ObjectConstructor is unable to find any ConstructorInfos that are compatible with the provided parameters
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Construction.ObjectLacksCompatibleConstructorException.#ctor(System.String)">
            <summary>
            Creates a new exception describing that a Type the user requested does not have any constructors that match the signature requested
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:Rdmp.Core.Repositories.DataExportRepository">
            <summary>
            Pointer to the Data Export Repository database in which all DatabaseEntities declared in DataExportLibrary.dll are stored.  Ever DatabaseEntity class must exist in a
            Microsoft Sql Server Database (See DatabaseEntity) and each object is compatible only with a specific type of TableRepository (i.e. the database that contains the
            table matching their name).  CatalogueLibrary.dll objects in CatalogueRepository, DataExportLibrary.dll objects in DataExportRepository, DataQualityEngine.dll objects
            in DQERepository etc.
            
            <para>This class allows you to fetch objects and should be passed into constructors of classes you want to construct in the Data Export database.  This includes extraction
            Projects, ExtractionConfigurations, ExtractableCohorts etc.</para>
            
            <para>Data Export databases are only valid when you have a CatalogueRepository database too and are always paired to a specific CatalogueRepository database (i.e. there are
            IDs in the data export database that specifically map to objects in the Catalogue database).  You can use the CatalogueRepository property to fetch/create objects
            in the paired Catalogue database.</para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.DataExportRepository.CatalogueRepository">
            <summary>
            The paired Catalogue database which contains non extract metadata (i.e. datasets, aggregates, data loads etc).  Some objects in this database
            contain references to objects in the CatalogueRepository.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.DQERepository">
            <summary>
            Pointer to the Data Qualilty Engine Repository database in which all DatabaseEntities declared in DataQualityEngine.dll are stored.  Ever DatabaseEntity class must exist in a
            Microsoft Sql Server Database (See DatabaseEntity) and each object is compatible only with a specific type of TableRepository (i.e. the database that contains the
            table matching their name).  CatalogueLibrary.dll objects in CatalogueRepository, DataExportLibrary.dll objects in DataExportRepository, DataQualityEngine.dll objects
            in DQERepository etc.
            
            <para>This class allows you to fetch objects and should be passed into constructors of classes you want to construct in the Data Quality database.</para>
            
            <para>Data Qualilty Engine databases are only valid when you have a CatalogueRepository database too and are always paired to a specific CatalogueRepository database (i.e. 
            there are IDs in the dqe database that specifically map to objects in the Catalogue database).  You can use the CatalogueRepository property to fetch/create objects
            in the paired Catalogue database.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.ICatalogueRepository">
            <summary>
            Pointer to the Catalogue Repository database in which all DatabaseEntities declared in CatalogueLibrary.dll are stored.  Ever DatabaseEntity class must exist in a
            Microsoft Sql Server Database (See DatabaseEntity) and each object is compatible only with a specific type of TableRepository (i.e. the database that contains the
            table matching their name).  CatalogueLibrary.dll objects in CatalogueRepository, DataExportLibrary.dll objects in DataExportRepository, DataQualityEngine.dll objects
            in DQERepository etc.
            
            <para>This class allows you to fetch objects and should be passed into constructors of classes you want to construct in the Catalogue database.  </para>
            
            <para>It also includes helper properties for setting up relationships and controling records in the non DatabaseEntity tables in the database e.g. <see cref="P:Rdmp.Core.Repositories.ICatalogueRepository.AggregateForcedJoinManager"/></para>
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.ICatalogueRepository.AggregateForcedJoinManager">
            <summary>
            Allows creation/discover/deletion of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateForcedJoin"/> objects
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.ICatalogueRepository.TableInfoCredentialsManager">
            <summary>
            Allows linking/unlinking <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials"/> to <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.ICatalogueRepository.JoinManager">
            <summary>
            Allows creation/discover of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.JoinInfo"/> objects which describe how to join two <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> together in SQL
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.ICatalogueRepository.MEF">
            <summary>
            Supports creation of objects using Reflection and discovery of Types based on Managed Extensibility Framework Export attributes.
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.ICatalogueRepository.CommentStore">
            <summary>
            Stores class comments discovered at startup using NuDoq
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.ICatalogueRepository.CohortContainerManager">
            <summary>
            Manages information about what set containers / subcontainers exist under a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/>
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.ICatalogueRepository.EncryptionManager">
            <summary>
            Handles encrypting/decrypting strings with private/public key encryption
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.ICatalogueRepository.ObscureDependencyFinder">
            <summary>
            Handles forbidding deleting stuff / cascading deletes into other objects
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.ICatalogueRepository.FilterManager">
            <summary>
            Manager for AND/OR WHERE containers and filters
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.ICatalogueRepository.PluginManager">
            <summary>
            Manager for identifying current active <see cref="N:Plugin"/>s
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.ICatalogueRepository.GetDefaultLogManager">
            <summary>
            Returns a new <see cref="T:Rdmp.Core.Logging.LogManager"/> that audits in the default logging server specified by <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Defaults.ServerDefaults"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.ICatalogueRepository.GetAllParametersForParentTable(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Returns all sql parameters declared in the immediate scope of the <paramref name="parent"/> (does not include parameters that are declared at a lower scope).
            
            <para>To determine which parent types are supported see <see cref="M:Rdmp.Core.CatalogueLibrary.Data.Cohort.AnyTableSqlParameter.IsSupportedType(System.Type)"/></para>
            </summary>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.ICatalogueRepository.GetTicketingSystem">
            <summary>
            Returns the persistence object which describes which <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/> should be consulted when making governance decisions (e.g. according to
            ticketing system, can I release this dataset?).  Returns null if no ticketing system has been configured.
            
            <para>Use <see cref="T:Rdmp.Core.Ticketing.TicketingSystemFactory"/> to instantiate an <see cref="T:Rdmp.Core.Ticketing.ITicketingSystem"/> instance</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.ICatalogueRepository.IsLookupTable(Rdmp.Core.CatalogueLibrary.Data.ITableInfo)">
            <summary>
            True if the <paramref name="tableInfo"/> has <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Lookup"/> relationships declared which make it a linkable lookup table in queries.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.ICatalogueRepository.GetAllCataloguesUsing(Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <summary>
            Returns all Catalogues which have any CatalogueItems which are associated with any of the ColumnInfos of this TableInfo.  If this is a lookup table then expect to get back 
            a whole bunch of catalogues.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.ICatalogueRepository.GetAllDatabases``1">
            <summary>
            Returns all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer"/> which were created by the patcher specified.  The patcher must have a blank constructor
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Repositories.ICatalogueRepositoryServiceLocator">
            <summary>
            Interface for a class which can find the CatalogueRepository database connection string
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.IDataExportRepository">
            <summary>
            See DataExportRepository
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.IDataExportRepository.FilterManager">
            <summary>
            Manager for AND/OR WHERE containers and filters
            </summary>
        </member>
        <member name="P:Rdmp.Core.Repositories.IDataExportRepository.ObscureDependencyFinder">
            <summary>
            Handles forbidding deleting stuff / cascading deletes into other objects
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.IDataExportRepositoryServiceLocator">
            <summary>
            Interface for a class which can find the DataExportRepository database connection string
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator">
            <summary>
            A class which can find the location (connection strings) of the of Catalogue and Data Export databases.  This might come from a user settings file or from a 
            config file or whatever (depending on how you implement this interface).
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.IRDMPPlatformRepositoryServiceLocator.GetArbitraryDatabaseObject(System.String,System.String,System.Int32)">
            <summary>
            Cross repository method equivallent to GetObjectByID mostly used in persistence recovery (when you startup RDMP after closing it down before).  It is better
            to use the specific repository methods on the CatalogueRepository / DataExportRepository.
            </summary>
            <param name="repositoryTypeName"></param>
            <param name="databaseObjectTypeName"></param>
            <param name="objectID"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.CommentStoreWithKeywords">
            <summary>
            Subclass of <see cref="T:ReusableLibraryCode.Comments.CommentStore"/> which also loads <see cref="!:Resources.KeywordHelp"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.DataExportFilterManager.GetSubContainers(Rdmp.Core.CatalogueLibrary.Data.IContainer)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.DataExportFilterManager.GetFilters(Rdmp.Core.CatalogueLibrary.Data.IContainer)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.DataExportFilterManager.AddSubContainer(Rdmp.Core.CatalogueLibrary.Data.IContainer,Rdmp.Core.CatalogueLibrary.Data.IContainer)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.DataExportFilterManager.MakeIntoAnOrphan(Rdmp.Core.CatalogueLibrary.Data.IContainer)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.DataExportProperty">
            <summary>
            List of all Keys that can be stored in the <see cref="T:Rdmp.Core.Repositories.Managers.IDataExportPropertyManager"/> table of the data export database
            </summary>
        </member>
        <member name="F:Rdmp.Core.Repositories.Managers.DataExportProperty.HashingAlgorithmPattern">
            <summary>
            What to do in order to produce a 'Hash' when a column is marked <see cref="P:Rdmp.Core.CatalogueLibrary.Data.ConcreteColumn.HashOnDataRelease"/>
            </summary>
        </member>
        <member name="F:Rdmp.Core.Repositories.Managers.DataExportProperty.ReleaseDocumentDisclaimer">
            <summary>
            What text to write into the release document when releasing datasets
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.DataExportPropertyManager">
            <summary>
            String based properties that are configured once per Data Export Database.  This includes how to implement Hashing and any text to appear in the Release 
            Document that is provided to researchers (and anything else we might want to configure globally for extraction in future).
            
            <para>Values are stored in the ConfigurationProperties table in the Data Export Database.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.DataExportPropertyManager.#ctor(System.Boolean,Rdmp.Core.Repositories.DataExportRepository)">
            <summary>
            Creates a new instance ready to read values out of the <paramref name="repository"/> database
            </summary>
            <param name="allowCaching"></param>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.DataExportPropertyManager.GetValue(System.String)">
            <summary>
            Returns the currently persisted value for the given key (See <see cref="T:Rdmp.Core.Repositories.Managers.DataExportProperty"/>)
            </summary>
            <param name="property"></param>
             <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.DataExportPropertyManager.GetValue(Rdmp.Core.Repositories.Managers.DataExportProperty)">
            <inheritdoc cref="M:Rdmp.Core.Repositories.Managers.DataExportPropertyManager.GetValue(System.String)"/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.DataExportPropertyManager.SetValue(Rdmp.Core.Repositories.Managers.DataExportProperty,System.String)">
            <summary>
            Stores a new <paramref name="value"/> for the given <see cref="!:property"/> (and saves to the database)
            </summary>
            <param name="property"></param>
            <param name="value"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.DataExportPropertyManager.DeleteValue(System.String)">
            <summary>
            Deletes the currently stored value of the given <paramref name="property"/>
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.ExtractableDataSetPackageManager">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ExtractableDataSetPackageManager.#ctor(Rdmp.Core.Repositories.DataExportRepository)">
            <summary>
            Creates a new <see cref="T:Rdmp.Core.Repositories.Managers.ExtractableDataSetPackageManager"/> which can read the contents of <see cref="T:Rdmp.Core.DataExport.Data.ExtractableDataSetPackage"/>s i.e.
            which datasets are part of which packages (many to many relationship).
            
            <para>The contents of packages are fetched during construction only and are not sensitive to remote changes during thereafter (e.g. by other users)</para>
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ExtractableDataSetPackageManager.GetAllDataSets(Rdmp.Core.CatalogueLibrary.Data.IExtractableDataSetPackage,Rdmp.Core.DataExport.Data.IExtractableDataSet[])">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ExtractableDataSetPackageManager.AddDataSetToPackage(Rdmp.Core.CatalogueLibrary.Data.IExtractableDataSetPackage,Rdmp.Core.DataExport.Data.IExtractableDataSet)">
             <summary>
             Adds the given <paramref name="dataSet"/> to the <paramref name="package"/> and updates the cached package contents 
             in memory.  
             
             <para>This change is immediately written to the database</para>
            
              <para>Throws ArgumentException if the <paramref name="dataSet"/> is already part of the package</para>
             </summary>
             <param name="package"></param>
             <param name="dataSet"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ExtractableDataSetPackageManager.RemoveDataSetFromPackage(Rdmp.Core.CatalogueLibrary.Data.IExtractableDataSetPackage,Rdmp.Core.DataExport.Data.IExtractableDataSet)">
             <summary>
             Removes the given <paramref name="dataSet"/> from the <paramref name="package"/> and updates the cached package contents 
             in memory.  
             
             <para>This change is immediately written to the database</para>
            
              <para>Throws ArgumentException if the <paramref name="dataSet"/> is not part of the package</para>
             </summary>
             <param name="package"></param>
             <param name="dataSet"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.GovernanceManager.GetAllGovernedCataloguesForAllGovernancePeriods">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.HighPerformance.CohortContainerManagerFromChildProvider">
            <summary>
            Performance class that builds the hierarchy of CohortIdentificationConfiguration children.  This includes containers (CohortAggregateContainer) and subcontainers
            and thier contained cohort sets ( AggregateConfiguration).  This is done in memory by fetching all the relevant relationship records with two queries and then
            sorting out the already fetched objects in CatalogueChildProvider into the relevant hierarchy.
            
            <para>This allows you to use GetSubContainers and GetAggregateConfigurations in bulk without having to use the method on IContainer directly (which goes back to the database).</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.HighPerformance.CohortContainerManagerFromChildProvider.GetChildren(Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer)">
            <summary>
            Returns cached answers without running database queries 
            </summary>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.HighPerformance.DataExportFilterManagerFromChildProvider">
            <summary>
            Provides a memory based efficient (in terms of the number of database queries sent) way of finding all containers and subcontainers and filters in the entire DataExportManager
            database at once rather than using the methods on IContainer and IFilter which send individual database queries for relevant subcontainers etc.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.HighPerformance.DataExportFilterManagerFromChildProvider.#ctor(Rdmp.Core.Repositories.DataExportRepository,Rdmp.Core.Providers.DataExportChildProvider)">
            <summary>
            Fetches all containers and filters out of the <paramref name="repository"/> and sets the class up to provide
            fast access to them.
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.HighPerformance.DataExportFilterManagerFromChildProvider.GetSubContainers(Rdmp.Core.CatalogueLibrary.Data.IContainer)">
            <summary>
            Returns all subcontainers found in the <paramref name="parent"/> (results are returned from the cache created during class construction)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.HighPerformance.FilterManagerFromChildProvider">
            <summary>
            Provides a memory based efficient (in terms of the number of database queries sent) way of finding all Catalogue filters and parameters as well as those used in
            AggregateConfigurations 
            
            </summary>
        </member>
        <member name="F:Rdmp.Core.Repositories.Managers.HighPerformance.FilterManagerFromChildProvider._subcontainers">
            <summary>
            Where ID key is the ID of the parent and the Value List is all the subcontainers.  If there is no key there are no subcontainers.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.ICohortContainerManager">
            <summary>
            Manages information about what set containers / subcontainers exist under a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ICohortContainerManager.GetParent(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            If the AggregateConfiguration is set up as a cohort identification set in a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortIdentificationConfiguration"/> then this method will return the set container
            (e.g. UNION / INTERSECT / EXCEPT) that it is in.  Returns null if it is not in a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ICohortContainerManager.GetParent(Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer)">
            <summary>
            Gets the parent container of the current container (if it is not a root / orphan container)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ICohortContainerManager.Add(Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,System.Int32)">
            <summary>
            Makes the configuration a member of the given container with the given <paramref name="order"/> relative to other things (if any) in the container.
            </summary>
            <param name="parent"></param>
            <param name="child"></param>
            <param name="order"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ICohortContainerManager.Remove(Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer,Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            Removes the <paramref name="child"/> configuration from the given container (to which it must belong already)
            </summary>
            <param name="parent"></param>
            <param name="child"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ICohortContainerManager.GetOrderIfExistsFor(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration)">
            <summary>
            If the configuration is part of any aggregate container anywhere this method will return the order within that container
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ICohortContainerManager.GetChildren(Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer)">
            <summary>
            Gets all the subcontainers of the current container (if any)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ICohortContainerManager.Remove(Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer,Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer)">
            <summary>
            Removes the given <paramref name="child"/> container from it's host parent container
            </summary>
            <param name="parent"></param>
            <param name="child"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ICohortContainerManager.SetOrder(Rdmp.Core.CatalogueLibrary.Data.Aggregation.AggregateConfiguration,System.Int32)">
            <summary>
            Reorders the <paramref name="child"/> to appear in the new location within it's parent container (relative to other things in the container).
            </summary>
            <param name="child"></param>
            <param name="newOrder"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ICohortContainerManager.Add(Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer,Rdmp.Core.CatalogueLibrary.Data.Cohort.CohortAggregateContainer)">
            <summary>
            Adds the given <paramref name="child"/> to the <paramref name="parent"/> container.
            </summary>
            <param name="parent"></param>
            <param name="child"></param>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.IDataExportPropertyManager">
            <summary>
            Handles persistence of <see cref="T:Rdmp.Core.Repositories.Managers.DataExportProperty"/> settings (e.g. what is the hashing algorithmn)
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.IDataExportPropertyManager.GetValue(Rdmp.Core.Repositories.Managers.DataExportProperty)">
            <summary>
            Returns the currently saved value for the given <paramref name="property"/> or null if it's not been set yet
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.IDataExportPropertyManager.SetValue(Rdmp.Core.Repositories.Managers.DataExportProperty,System.String)">
            <summary>
            Stores a new <paramref name="value"/> for the given <see cref="!:property"/> (and saves to the database)
            </summary>
            <param name="property"></param>
            <param name="value"></param>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.IEncryptionManager">
            <summary>
            Handles persisting encryption certificate for public/private key encryption.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.IEncryptionManager.GetEncrypter">
            <summary>
            Enables encryption/decryption of strings using a custom RSA key stored in a secure location on disk
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.IExtractableDataSetPackageManager">
            <summary>
            Helper class for listing, adding and removing <see cref="T:Rdmp.Core.DataExport.Data.IExtractableDataSet"/> from <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IExtractableDataSetPackage"/>s
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.IExtractableDataSetPackageManager.GetAllDataSets(Rdmp.Core.CatalogueLibrary.Data.IExtractableDataSetPackage,Rdmp.Core.DataExport.Data.IExtractableDataSet[])">
            <summary>
            Returns the subset of <paramref name="allDataSets"/> which are part of the <paramref name="package"/>.
            </summary>
            <param name="package"></param>
            <param name="allDataSets"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.IExtractableDataSetPackageManager.AddDataSetToPackage(Rdmp.Core.CatalogueLibrary.Data.IExtractableDataSetPackage,Rdmp.Core.DataExport.Data.IExtractableDataSet)">
            <summary>
            Adds the given <paramref name="dataSet"/> to the <paramref name="package"/>
            </summary>
            <param name="package"></param>
            <param name="dataSet"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.IExtractableDataSetPackageManager.RemoveDataSetFromPackage(Rdmp.Core.CatalogueLibrary.Data.IExtractableDataSetPackage,Rdmp.Core.DataExport.Data.IExtractableDataSet)">
            <summary>
            Removes the given <paramref name="dataSet"/> from the <paramref name="package"/> and updates the cached package contents 
            in memory.
            </summary>
            <param name="package"></param>
            <param name="dataSet"></param>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.IFilterManager">
            <summary>
            Subcomponent of <see cref="T:Rdmp.Core.Repositories.ICatalogueRepository"/> which manages persisting / editting which 
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IFilter"/> belong in which <see cref="T:Rdmp.Core.CatalogueLibrary.Data.IContainer"/> etc.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.IGovernanceManager">
            <summary>
            Subcomponent of <see cref="T:Rdmp.Core.Repositories.ICatalogueRepository"/> which manages persisting / editting which 
            <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ICatalogue"/> datasets are governed by which <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod"/> (many to many relationship)
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.IGovernanceManager.GetAllGovernedCataloguesForAllGovernancePeriods">
            <summary>
            Returns the IDs of all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Governance.GovernancePeriod"/> with the corresponding set of <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Catalogue"/> IDs which are covered by the governance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.IJoinManager">
            <summary>
            Subcomponent of <see cref="T:Rdmp.Core.Repositories.ICatalogueRepository"/> which manages the objects which describe how to
            link two <see cref="T:Rdmp.Core.CatalogueLibrary.Data.ITableInfo"/> using joins on column sets between the two tables.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.IPluginManager">
            <summary>
            Handles high level management of all the loaded <see cref="N:Plugin"/> in the <see cref="T:Rdmp.Core.Repositories.ICatalogueRepository"/>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.ITableInfoCredentialsManager">
            <summary>
            Models the relationship between <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> and the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials"/> (if any) that can be used to reach them.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ITableInfoCredentialsManager.CreateLinkBetween(Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials,Rdmp.Core.CatalogueLibrary.Data.TableInfo,ReusableLibraryCode.DataAccess.DataAccessContext)">
            <summary>
            Declares that the given <paramref name="tableInfo"/> can be accessed using the <paramref name="credentials"/> (username / encrypted password) under the 
            usage <paramref name="context"/> 
            </summary>
            <param name="credentials"></param>
            <param name="tableInfo"></param>
            <param name="context"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ITableInfoCredentialsManager.BreakLinkBetween(Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials,Rdmp.Core.CatalogueLibrary.Data.TableInfo,ReusableLibraryCode.DataAccess.DataAccessContext)">
            <summary>
            Removes the right to use passed <paramref name="credentials"/> to access the <paramref name="tableInfo"/> under the <paramref name="context"/>
            </summary>
            <param name="credentials"></param>
            <param name="tableInfo"></param>
            <param name="context"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ITableInfoCredentialsManager.BreakAllLinksBetween(Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials,Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <summary>
            Removes all rights to use the passed <paramref name="credentials"/> to access the <paramref name="tableInfo"/>
            </summary>
            <param name="credentials"></param>
            <param name="tableInfo"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ITableInfoCredentialsManager.GetCredentialsIfExistsFor(Rdmp.Core.CatalogueLibrary.Data.TableInfo,ReusableLibraryCode.DataAccess.DataAccessContext)">
            <summary>
             Answers the question, "what is the best credential (if any) to use under the given context"
            
            <para>Tries to find a DataAccessCredentials for the supplied TableInfo.  For example you are trying to find a username/pasword to use with the TableInfo when performing
            a DataLoad, this method will first return any explicit usage allowances (if there is a credential liscenced for use during DataLoad) if no such credentials exist 
            it will then check for a credential which is liscenced for Any usage (can be used for data load, data export etc) and return that else it will return null</para>
            </summary>
            <param name="tableInfo"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ITableInfoCredentialsManager.GetCredentialsIfExistsFor(Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <summary>
            Fetches all <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials"/> (username and encrypted password) that can be used to access the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> under any
            <see cref="T:ReusableLibraryCode.DataAccess.DataAccessContext"/>)
            </summary>
            <param name="tableInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ITableInfoCredentialsManager.GetAllCredentialUsagesBy(Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials[],Rdmp.Core.CatalogueLibrary.Data.TableInfo[])">
            <summary>
            Returns all credential usage permissions for the given set of <paramref name="allTableInfos"/> and <paramref name="allCredentials"/>
            </summary>
            <param name="allCredentials"></param>
            <param name="allTableInfos"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ITableInfoCredentialsManager.GetAllTablesUsingCredentials(Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials)">
            <summary>
            Returns all the <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> that are allowed to use the given <paramref name="credentials"/>
            </summary>
            <param name="credentials"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.ITableInfoCredentialsManager.GetCredentialByUsernameAndPasswordIfExists(System.String,System.String)">
            <summary>
            Returns the existing <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials"/> if any which match the unencrypted <paramref name="username"/> and <paramref name="password"/> combination.  Throws
            if there are more than 1 
            </summary>
            <param name="username"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.JoinManager">
            <summary>
            Handles creation, discovery and deletion of JoinInfos.  JoinInfos are not IMapsDirectlyToDatabaseTable classes because they are mostly just a m-m relationship
            table between ColumnInfos (with join direction / collation).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.PasswordEncryptionKeyLocation">
            <summary>
            The file system location of the RSA private decryption key used to decrypt passwords stored in RDMP database.  There can only ever be one PasswordEncryptionKeyLocation
            and this is used by all SimpleStringValueEncryption.  This means that passwords can be securely held in the RDMP database so long as suitable windows account management
            takes place (only providing access to the key file location to users who should be able to use the passwords).
            
            <para>See PasswordEncryptionKeyLocationUI for more information.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.PasswordEncryptionKeyLocation.#ctor(Rdmp.Core.Repositories.CatalogueRepository)">
            <summary>
            Prepares to retrieve/create the key file for the given platform database
            </summary>
            <param name="catalogueRepository"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.PasswordEncryptionKeyLocation.GetKeyFileLocation">
            <summary>
            Gets the physical file path to the currently configured RSA private key for encrypting/decrypting passwords or null if no
            custom keyfile has been created yet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.PasswordEncryptionKeyLocation.OpenKeyFile">
            <summary>
            Connects to the private key location and returns the encryption/decryption parameters stored in it
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.PasswordEncryptionKeyLocation.CreateNewKeyFile(System.String)">
            <summary>
            Creates a new private RSA encryption key certificate at the given location and sets the catalogue repository to use it for encrypting passwords.
            This will make any existing serialized passwords iretrievable unless you restore and reset the original key file location. 
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.PasswordEncryptionKeyLocation.ChangeLocation(System.String)">
            <summary>
            Changes the location of the RSA private key file to a physical location on disk (which must exist)
            </summary>
            <param name="newLocation"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.PasswordEncryptionKeyLocation.DeleteKey">
            <summary>
            Deletes the location of the RSA private key file from the platform database (does not delete the physical
            file).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.PluginManager">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.Repositories.Managers.TableInfoCredentialsManager">
            <summary>
            Allows you to create and destroy usage relationships between TableInfos and DataAccessCredentials (under context X).  For example you might have a DataAccessCredentials 
            called 'RoutineLoaderAccount' and give tables A,B and C permission to use it under DataAccessContext.DataLoad then have a seperate DataAccessCredentials called 
            'ReadonlyUserAccount' and give tables A,B,C and D permission to use it under DataAccessContext.Any
            
            <para></para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.TableInfoCredentialsManager.#ctor(Rdmp.Core.Repositories.CatalogueRepository)">
            <summary>
            Creates a new helper class instance for writting/deleting credential usages for <see cref="T:Rdmp.Core.CatalogueLibrary.Data.TableInfo"/> objects in the <paramref name="repository"/>
            </summary>
            <param name="repository"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.TableInfoCredentialsManager.CreateLinkBetween(Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials,Rdmp.Core.CatalogueLibrary.Data.TableInfo,ReusableLibraryCode.DataAccess.DataAccessContext)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.TableInfoCredentialsManager.BreakLinkBetween(Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials,Rdmp.Core.CatalogueLibrary.Data.TableInfo,ReusableLibraryCode.DataAccess.DataAccessContext)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.TableInfoCredentialsManager.BreakAllLinksBetween(Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials,Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.TableInfoCredentialsManager.GetCredentialsIfExistsFor(Rdmp.Core.CatalogueLibrary.Data.TableInfo,ReusableLibraryCode.DataAccess.DataAccessContext)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.TableInfoCredentialsManager.GetCredentialsIfExistsFor(Rdmp.Core.CatalogueLibrary.Data.TableInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.TableInfoCredentialsManager.GetAllCredentialUsagesBy(Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials[],Rdmp.Core.CatalogueLibrary.Data.TableInfo[])">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.TableInfoCredentialsManager.GetAllTablesUsingCredentials(Rdmp.Core.CatalogueLibrary.Data.DataAccessCredentials)">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.TableInfoCredentialsManager.GetLinksFromReader(System.Data.Common.DbDataReader)">
            <summary>
            Helper that returns 1-M results (where there is only one originating TableInfo, if there are more than 1 table info in your SQL query you will get key collisions)
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.Managers.TableInfoCredentialsManager.GetCredentialByUsernameAndPasswordIfExists(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.Repositories.MEF">
            <summary>
            MEF stands for Managed Extensibility Framework which is a Microsoft library for building Extensions (Plugins) into programs.  It involves decoarting classes as
            [Export] or [InheritedExport] and defining contracts, importing constructors, paramters etc.  RDMP makes use of MEF in a limited fashion, it processes all 
            Exported classes into a SafeDirectoryCatalog (a collection of MEF AssemblyCatalogs/AggregateCatalog).
            
            <para>This class provides support for downloading Plugins out of the Catalogue Database, identifying Exports and building the SafeDirectoryCatalog.  It also includes
            methods for creating instances of the exported Types.  Because MEF only gets you so far it also has some generally helpful reflection based methods such as 
            GetAllTypesFromAllKnownAssemblies.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.MEF.AddTypeToCatalogForTesting(System.Type)">
            <summary>
            Makes the given Type appear as a MEF exported class.  Can be used to test your types without 
            building and committing an actual <see cref="N:Plugin"/>
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Rdmp.Core.Repositories.MEF.GetMEFNameForType(System.Type)">
            <summary>
            Turns the legit C# name:
            DataLoadEngine.DataFlowPipeline.IDataFlowSource`1[[System.Data.DataTable, System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]
            
            <para>Into a freaky MEF name:
            DataLoadEngine.DataFlowPipeline.IDataFlowSource(System.Data.DataTable)</para>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.MEF.GetCSharpNameForType(System.Type)">
            <summary>
            
            <para>Turns the legit C# name: 
            DataLoadEngine.DataFlowPipeline.IDataFlowSource`1[[System.Data.DataTable, System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]</para>
            
            <para>Into a proper C# code:
            IDataFlowSource&lt;DataTable&gt;</para>
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.MEF.GetGenericTypes(System.Type,System.Type)">
            <summary>
            Returns all MEF exported classes decorated with the specified generic export e.g. [Export(typeof(IDataFlowComponent&lt;DataTable&gt;))]
            </summary>
            <param name="genericType"></param>
            <param name="typeOfT"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.MEF.FactoryCreateA``1(System.String)">
            <summary>
            Creates an instance of the named class whcih must have a blank constructor
            
            <para>IMPORTANT: this will create classes from the MEF Exports ONLY i.e. not any loaded type but has to be an explicitly labled Export of a LoadModuleAssembly</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="toCreate"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.MEF.FactoryCreateA``2(System.String,``1)">
            <summary>
            Creates an instance of the named class with a single constructor parameter
            
            <para>IMPORTANT: this will create classes from the MEF Exports ONLY i.e. not any loaded type but has to be an explicitly labled Export of a LoadModuleAssembly</para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="subTypeToCreate"></param>
            <param name="ctorParam1"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Repositories.MEF.GetAllTypesFromAllKnownAssemblies(System.Collections.Generic.List{System.Exception}@)">
            <summary>
            Lists every single Type in the current AppDomain (every assembly that is currently loaded) regardless of whether it is a MEF Export or not.
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Repositories.MemoryCatalogueRepository">
            <summary>
            Memory only implementation of <see cref="T:Rdmp.Core.Repositories.ICatalogueRepository"/> in which all objects are created in 
            dictionaries and arrays in memory instead of the database.
            </summary>
        </member>
        <member name="F:Rdmp.Core.Repositories.MemoryCatalogueRepository._credentialsDictionary">
            <summary>
            records which credentials can be used to access the table under which contexts
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.MemoryDataExportRepository">
            <summary>
            Memory only implementation of <see cref="T:Rdmp.Core.Repositories.IDataExportRepository"/>.  Also implements <see cref="T:Rdmp.Core.Repositories.ICatalogueRepository"/>.  All objects are created in 
            dictionaries and arrays in memory instead of the database.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Repositories.RepositoryProvider">
            <summary>
            Use when you have an already initialized set of repositories and only want to fetch objects from the catalogue/data export repositories
            </summary>
        </member>
        <member name="M:Rdmp.Core.Repositories.RepositoryProvider.#ctor(Rdmp.Core.Repositories.IDataExportRepository)">
            <summary>
            Use when you have an already initialized set of repositories.  Sets up the class to fetch objects from the Catalogue/Data export databases only.
            
            <para>If possible consider using LinkedRepositoryProvider or Startup (these support plugin repositories, DQE repository etc)</para>
            
            </summary>
            <param name="dataExportRepository"></param>
        </member>
        <member name="T:Rdmp.Core.Sharing.Dependency.Gathering.GatheredObject">
             <summary>
             The described Object is only tenously related to the original object and you shouldn't worry too much if during refactoring you don't find any references. 
             An example of this would be all Filters in a Catalogue where a single ColumnInfo is being renamed.  Any filter in the catalogue could contain a reference to
             the ColumnInfo but most won't.
            
             <para>Describes an RDMP object that is related to another e.g. a ColumnInfo can have 0+ CatalogueItems associated with it.  This differs from IHasDependencies by the fact that
             it is a more constrained set rather than just spider webbing out everywhere.</para>
             </summary>
        </member>
        <member name="P:Rdmp.Core.Sharing.Dependency.Gathering.GatheredObject.IsReleased">
            <summary>
            True if the gathered object is a data export object (e.g. it is an ExtractableColumn or DeployedExtractionFilter) and it is part of a frozen (released)
            ExtractionConfiguration 
            </summary>
        </member>
        <member name="M:Rdmp.Core.Sharing.Dependency.Gathering.GatheredObject.ToShareDefinition(Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager,System.Collections.Generic.List{Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition})">
            <summary>
            Creates a sharing export (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport"/>) for the current <see cref="P:Rdmp.Core.Sharing.Dependency.Gathering.GatheredObject.Object"/> and then serializes it as a <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/>.  
            This includes mapping any [<see cref="T:MapsDirectlyToDatabaseTable.Attributes.RelationshipAttribute"/>] properties on the <see cref="P:Rdmp.Core.Sharing.Dependency.Gathering.GatheredObject.Object"/> to the relevant Share Guid (which must
            exist in branchParents).
            
            <para>ToShareDefinitionWithChildren if you want a full list of shares for the whole tree</para>
            </summary>
            <param name="shareManager"></param>
            <param name="branchParents"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Sharing.Dependency.Gathering.GatheredObject.ToShareDefinitionWithChildren(Rdmp.Core.CatalogueLibrary.Data.ImportExport.ShareManager)">
            <summary>
            Creates sharing exports (<see cref="T:Rdmp.Core.CatalogueLibrary.Data.ImportExport.ObjectExport"/>) for the current <see cref="P:Rdmp.Core.Sharing.Dependency.Gathering.GatheredObject.Object"/> and all <see cref="P:Rdmp.Core.Sharing.Dependency.Gathering.GatheredObject.Children"/> and 
            then serializes them as <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Serialization.ShareDefinition"/>
            </summary>
            <param name="shareManager"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Sharing.Dependency.Gathering.Gatherer">
            <summary>
            Gathers dependencies of a given object in a more advanced/selective way than simply using methods of IHasDependencies
            </summary>
        </member>
        <member name="M:Rdmp.Core.Sharing.Dependency.Gathering.Gatherer.CanGatherDependencies(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)">
            <summary>
            Invokes the relevant overload if it exists. 
            <seealso cref="M:Rdmp.Core.Sharing.Dependency.Gathering.Gatherer.CanGatherDependencies(MapsDirectlyToDatabaseTable.IMapsDirectlyToDatabaseTable)"/>
            </summary>
            <param name="databaseEntity"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Sharing.Dependency.Gathering.Gatherer.GatherDependencies(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo)">
            <summary>
            Gathers dependencies of ColumnInfo, this includes all [Sql] properties on any object in data export / catalogue databases
            which references the fully qualified name of the ColumnInfo as well as it's immediate network friends that should share it's
            runtime name e.g. CatalogueItem and ExtractionInformation.
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Sharing.Dependency.ObjectSharingObscureDependencyFinder">
            <summary>
            Handles preventing deletion of shareable references to existing classes e.g. if a Catalogue is shared (has an entry in ObjectExport table) then you
            cannot delete it.  Also handles cascading deletes of imported classes e.g. if a Catalogue was imported from somewhere else (has an entry in ObjectImport) and
            then you delete it the ObjectImport reference will also be deleted.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Sharing.Dependency.SharedPluginImporter">
            <summary>
            Facilitiates importing plugins from a remote contributor and creating the local copies of the Plugin dlls in the local CatalogueRepository database.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Sharing.Refactoring.Exceptions.RefactoringException">
            <summary>
            Thrown when there is a problem performing renaming refactoring on an SQL string (e.g. SelectSQL / WhereSQL etc)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Sharing.Refactoring.SelectSQLRefactorer">
            <summary>
            Handles making changes to SelectSQL properties that revolve around changing which underlying table/column drives the SQL.  For example when a user
            renames a TableInfo and wants to refactor the changes into all the ColumnInfos that underly it and all the ExtractionInformations that come from
            those ColumnInfos and then all the CohortIdentificationConfigurations, AggregateConfigurations etc etc.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Sharing.Refactoring.SelectSQLRefactorer.RefactorTableName(Rdmp.Core.QueryBuilding.IColumn,FAnsi.Naming.IHasFullyQualifiedNameToo,System.String)">
            <summary>
            Replaces all references to the given table with the new table name in a columns SelectSQL.  This will also save the column.  Ensure
            that new tableName is in fact fully qualified e.g. '[db]..[tbl]'
            </summary>
            <param name="column"></param>
            <param name="tableName"></param>
            <param name="newFullySpecifiedTableName"></param>
        </member>
        <member name="M:Rdmp.Core.Sharing.Refactoring.SelectSQLRefactorer.RefactorTableName(Rdmp.Core.CatalogueLibrary.Data.ColumnInfo,FAnsi.Naming.IHasFullyQualifiedNameToo,System.String)">
            <summary>
            Replaces all references to the given table with the new table name in a ColumnInfo.  This will also save the column.    Ensure
            that new tableName is in fact fully qualified e.g. '[db]..[tbl]'
            </summary>
            <param name="column"></param>
            <param name="tableName"></param>
            <param name="newFullySpecifiedTableName"></param>
        </member>
        <member name="M:Rdmp.Core.Sharing.Refactoring.SelectSQLRefactorer.RefactorColumnName(Rdmp.Core.QueryBuilding.IColumn,FAnsi.Naming.IHasFullyQualifiedNameToo,System.String,System.Boolean)">
            <summary>
            Replaces all references to the given table with the new table name in a columns SelectSQL.  This will also save the column.  Ensure
            that newFullySpecifiedColumnName is in fact fully qualified too e.g. [mydb]..[mytable].[mycol]
            </summary>
            <param name="column"></param>
            <param name="columnName"></param>
            <param name="newFullySpecifiedColumnName"></param>
            <param name="strict">Determines behaviour when column SelectSQL does not contain a reference to columnName.  True will throw a RefactoringException, false will return without making any changes</param>
        </member>
        <member name="M:Rdmp.Core.Sharing.Refactoring.SelectSQLRefactorer.IsRefactorable(Rdmp.Core.QueryBuilding.IColumn)">
            <summary>
            Determines whether the SelectSQL of the specified IColumn includes fully specified refactorable references.  If the SelectSQL is properly
            formed then the underlying column should appear fully specified at least once in the SelectSQL e.g. UPPER([db]..[tbl].[col])
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Sharing.Refactoring.SelectSQLRefactorer.GetReasonNotRefactorable(Rdmp.Core.QueryBuilding.IColumn)">
            <summary>
            Determines whether the SelectSQL of the specified IColumn includes fully specified refactorable references.  Returns the reason why
            the IColumn is not IsRefactorable (or null if it is).
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Sharing.Transmission.RemotePushingService">
            <summary>
            Serializes collections of RDMP objects into BINARY Json and streams to a RemoteRDMP endpoint.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.Events.MEFFileDownloadProgressEventArgs">
            <summary>
            EventArgs for MEF downloading during Startup.cs
            
            <para>Records whether the file was succesfully downloaded and the number of dlls saved so far.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.Events.PlatformDatabaseFoundEventArgs">
            <summary>
            Event Args for when the .Database assembly (e.g. CatalogueLibrary.Database) managed database is located during Startup.cs
            
            <para>Includes the evaluated status of the database (does it need patching etc) and the Assemblies responsible for managing the database
            (The DatabaseAssembly and the HostAssembly - which contains the object definitions).</para>
            
            <para>It is important that all platform Databases exactly match the runtime libraries for managing saving/loading objects therefore if the Status is 
            RequiresPatching it is imperative that you patch the database and restart the application (happens automatically with StartupUI).</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.Events.PluginPatcherFoundEventArgs">
            <summary>
            EventArgs for finding Plugin IPatchers during Startup.cs
            
            <para>IPatchers identify databases that are managed by a .Database assembly and as such need to be patched/updated when the host assembly is updated.  For 
            plugins this is done by declaring a IPluginPatcher and listing the host/database assemblies but there can be Type loading errors or other Exceptions 
            around locating databases that must be patched, this event system supports reporting those.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.IPluginRepositoryFinder">
            <summary>
            Plugin databases can have an IRepository for interacting with them (the easiest way to implement this is to inherit from TableRepository).  However
            in order to construct the IRepository you likely need a connection string which might be stored in the catalogue database (e.g. as an 
            ExternalDatabaseServer).  
            
            <para>Plugin authors should inherit from PluginRepositoryFinder and return a suitable TableRepository for saving/loading objects into the database at runtime.</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Startup.IPluginRepositoryFinder.GetRepositoryIfAny">
            <summary>
            Returns an instance capable of loading and saving objects into the database.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Startup.IPluginRepositoryFinder.GetRepositoryType">
            <summary>
            Returns the Type of object returned by <see cref="M:Rdmp.Core.Startup.IPluginRepositoryFinder.GetRepositoryIfAny"/>.  This is used before constructing an actual instance to decide whether or not a given
            unknown object reference should be resolved by your <see cref="T:MapsDirectlyToDatabaseTable.IRepository"/> or somebody elses (See <see cref="T:Rdmp.Core.CatalogueLibrary.Data.Referencing.IReferenceOtherObject"/>).  
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Startup.LinkedRepositoryProvider">
            <summary>
            Records the location of the Catalogue and DataExport databases in which RDMP stores all configuration information (what datasets there are, what extraction
            projects there are, what IFilters are available etc - literally everything, just look at who inherits from IMapsDirectlyToDatabaseTable!).
            
            <para>See also UserSettingsRepositoryFinder</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Startup.LinkedRepositoryProvider.ConfigureObscureDependencies">
            <summary>
            Call once if the <see cref="T:Rdmp.Core.Repositories.CatalogueRepository"/> and <see cref="T:Rdmp.Core.Repositories.DataExportRepository"/> are new (not existing already).  This will populate the
            <see cref="P:MapsDirectlyToDatabaseTable.TableRepository.ObscureDependencyFinder"/> with appropriate cross database runtime constraints.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.PluginManagement.PluginAnalyser">
            <summary>
            Evaluates a single Plugin that is committed in the current Catalogue database (and downloaded into the MEF folder - PluginDirectory).  All the files
            (.dlls) which make up the plugin (LoadModuleAssembly) are evaluated and a PluginAnalyserReport is produced for each.
            
            <para>Used for debug purposes to identify unloadable dlls in a plugin or breaking API changes in different versions of loaded dlls.  Decompiles all methods
            in all MEF exportable Types using Mono.Reflection to ensure that even though the Type can be loaded that the methods themselves can also be linked up
            correctly (enumerating Instructions identifies any breaking changes in the API even when they don't result in unloadable Type errors).</para>
            
            <para>See PluginManagementForm for a friendly UI for this class.  </para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.PluginManagement.PluginAnalyserProgressEventArgs">
            <summary>
            Records the progress made in evaluating a dll in PluginAnalyser
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.PluginManagement.PluginAnalyserReport">
            <summary>
            Describes all the MEF exports in the current dll (LoadModuleAssembly) which is part of a Plugin.  Each MEF exposed Type has a PluginPart created for it
            which documents the methods / API compatibility issues (See PluginPart).
            
            <para>Overall the dll is given a PluginAssemblyStatus indicating whether it was loadable and whether the Types declared resolved correctly and were loaded into
            the AppDomain.</para>
            
            <para>If a given dll is unloadable it won't have any PluginParts but should have a BadAssemblyException</para>
            
            <para>All dlls are evaluated even when they are bundled with the plugin as dependencies of other dlls and do not contain any MEF classes themselves.  For example
            if you have a plugin for managing DICOM images you might have a third party dll for interacting with DICOM files as part of the Plugin.  This would also 
            have a PluginAnalyserReport which should indicate Health status and no PluginParts (assuming it has not MEF exports).</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.PluginManagement.PluginDependency">
            <summary>
            A method declared on a MEF exportable class in a dll that is part of a Plugin being analysed in a PluginAnalyser.  Contains a list of all
            the Instructions that could be identified using Mono.Reflection.Instruction.  If a method had code that was loadable but could not be resolved 
            at runtime it means there has been a breaking API change since the plugin was last compiled (e.g. the RDMP has been updated).  You can see this
            if the Exception property has been populated.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.PluginManagement.PluginPart">
            <summary>
            Describes a Type declared in a dll (LoadModuleAssembly) that is part of a Plugin downloaded into the MEF directory and being analysed by a PluginAnalyser.
            Includes the MEF ComposablePartDefinition, Type and a list of all the decompiled methods on the class (PluginDependency). 
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.PluginManagement.PluginProcessor">
            <summary>
            Commits a .zip file containing dlls, pdbs and source code that constitutes an RDMP Plugin (Use PluginPackager.Packager to package up a .sln into such a
            zip file) into the given Catalogue Database.  
            
            <para>All plugins are saved in binary format in the LoadModuleAssembly table of your Catalogue database and downloaded at Startup time into the MEF folder
            where they are loaded into the app domain.  Through this method every user gets the same version of the currently installed plugins and the database
            acts as the distributor of binaries.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.PluginRepository">
            <summary>
            Repository for constructing/saving/deleting <see cref="T:Rdmp.Core.CatalogueLibrary.Data.DatabaseEntity"/> objects that are are stored in your plugin database.
            The assembly containing your <see cref="T:Rdmp.Core.Startup.PluginRepository"/> must be the same assembly that contains the class definitions.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Startup.PluginRepository.#ctor(Rdmp.Core.CatalogueLibrary.Data.ExternalDatabaseServer,MapsDirectlyToDatabaseTable.IObscureDependencyFinder)">
            <summary>
            Sets up the repository for reading and writing objects out of the given <paramref name="externalDatabaseServer"/>.  
            </summary>
            <param name="externalDatabaseServer">The database to connect to</param>
            <param name="dependencyFinder">Optional class that can forbid deleting objects because you have dependencies on them in your database (e.g. if your custom object has a field Catalogue_ID)</param>
        </member>
        <member name="T:Rdmp.Core.Startup.PluginRepositoryFinder">
            <summary>
            MEF discoverable version of IPluginRepositoryFinder
            </summary>
        </member>
        <member name="M:Rdmp.Core.Startup.PluginRepositoryFinder.GetRepositoryIfAny">
            <inheritdoc/>
        </member>
        <member name="M:Rdmp.Core.Startup.PluginRepositoryFinder.GetRepositoryType">
            <inheritdoc/>
        </member>
        <member name="T:Rdmp.Core.Startup.SourceCodeNotFoundException">
            <summary>
            Thrown if the "SourceCodeForSelfAwareness.zip" file is not present where it is expected.  RDMP bundles it's source code in a flattened zip file called 
            "SourceCodeForSelfAwareness.zip" in order to generate dynamic help and display helper information about stack traces (see ExceptionViewerStackTraceWithHyperlinks) 
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.Startup">
            <summary>
            Locates main databases (Catalogue / Data Export - called Tier1 databases) and satellite databases (DQE, Logging etc - called Tier2 
            databases) and plugin databases (Called Tier3).
            
            <para>Identifies which databases need to be patched.</para>
            
            <para>Loads MEF assemblies and identifies assembly incompatibilities / Type Load errors.</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Startup.UserSettingsRepositoryFinder">
            <summary>
            Records connection strings to the Catalogue and DataExport databases (See LinkedRepositoryProvider) in the user settings file for the current
            user.
            
            <para>Use properties CatalogueRepository and DataExportRepository for interacting with objects saved in those databases (and to create new ones).</para>
            </summary>
        </member>
        <member name="T:Rdmp.Core.Ticketing.ITicketingSystem">
            <summary>
            How RDMP interacts with an (optional) ticketing sytem such as Jira, Fogbugz etc.  RDMP allows you to control governance via your ticketing system and
            to associate ticket identifiers with project extracts, catalogues, issues etc.  By implementing this interface for your ticketing system you can prevent
            data releases unless a ticket is in a given state etc.
            
            <para>IMPORTANT: you must have a constructor that takes a single parameter of Type TicketingSystemConstructorParameters</para>
            </summary>
        </member>
        <member name="M:Rdmp.Core.Ticketing.ITicketingSystem.IsValidTicketName(System.String)">
            <summary>
            Called when the user enters a string he thinks is a valid ticket.  You should respond quickly (e.g. by Regex pattern matching not database query
            - unless that is trivially fast) to tell him whether the string is valid as a ticket.
            </summary>
            <param name="ticketName"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Ticketing.ITicketingSystem.NavigateToTicket(System.String)">
            <summary>
            Occurs when the user has a ticket associated with an object and clicks Go To button.  This method should fire up a browser at the specified
            ticket so it is visible to the user.
            </summary>
            <param name="ticketName"></param>
        </member>
        <member name="M:Rdmp.Core.Ticketing.ITicketingSystem.GetDataReleaseabilityOfTicket(System.String,System.String,System.String,System.String@,System.Exception@)">
            <summary>
            Called when the user (or RDMP) attempts to perform a release of an extracted project dataset.  You can pass back a state based on the tickets (which
            might be null) to indicate whether the ticketing system thinks the release should go ahead.  This empowers your ticketing system to control governance
            of when a release is allowed or not.  If you don't want this functionality just return Releasable.
            </summary>
            <param name="masterTicket"></param>
            <param name="requestTicket"></param>
            <param name="releaseTicket"></param>
            <param name="reason"></param>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="T:Rdmp.Core.Ticketing.TicketingSystemConstructorParameters">
            <summary>
            All implementations of ITicketingSystem will be given this parameter as a constructor argument.  It includes the RDMP configured credentials for
            the ticketing system.  Credentials.Password is encrypted, use GetDecryptedPassword() if you want to use the Credentials property (this method can
            fail if the user does not have access to the password decryption key (see PasswordEncryptionKeyLocationUI). 
            </summary>
        </member>
        <member name="T:Rdmp.Core.Ticketing.TicketingSystemFactory">
            <summary>
            RDMP can have a single ITicketingSystem configured (optional).  This factory creates the ITicketingSystem instance based on the 
            TicketingSystemConfiguration the uer has set up
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.IConstraint">
            <summary>
            Base interface for all validation rules (and accompanying failure Consqeuences)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Primary.Alpha">
            <summary>
            Field can contain only the letters A-Z with no spaces or other symbols.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Primary.AlphaNumeric">
            <summary>
            Field can contain only letters and numbers (but no spaces or symbols)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Primary.Chi">
            <summary>
            Field must contain a chi number, this is a 10 digit number in which the first 6 digits are the patients date of birth and the last 2 digits are
            a gender digit and a checksum.  Validation will fail if the checksum is invalid or the value does not match the pattern.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Validation.Constraints.Primary.Chi.GetCHICheckDigit(System.String)">
            <summary>
            Does the CHI check digit calculation
            </summary>
            <param name="sCHI"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Validation.Constraints.Primary.Chi.GetSex(System.String)">
            <summary>
            Return the sex indicated by the supplied CHI
            </summary>
            <param name="chi"></param>
            <returns>1 for male and 0 for female</returns>
        </member>
        <member name="M:Rdmp.Core.Validation.Constraints.Primary.Chi.IsValidChiNumber(System.String,System.String@)">
            <summary>
            Check the validity of the supplied CHI
            </summary>
            <param name="strChi"></param>
            <returns>true if the CHI is valid, false otherwise</returns>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Primary.Date">
            <summary>
            A Constraint specifying that the date must be a valid, delimited EU format date. e.g. 25-09-67 or 25-9-1967.
            As such, the leftmost digits are assumed to be the DAY value and the rightmost digits, the YEAR value.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Validation.Constraints.Primary.Date.Validate(System.Object)">
            <summary>
            Validate a string representation of a UK (ONLY) date of the format d[d]/m[m]/yy[yy].
            The standard C# DateTime.Parse() method is used, which accepts alternative separators such as '.' and '-'.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Primary.IPrimaryConstraint">
            <summary>
            Each column can have a single PrimaryConstraint, this is usually related to the datatype (either exact e.g. DateTime or semantic e.g. NHS number).
            Validation of a PrimaryConstraint involves ensuring that the value is of the correct pattern/type as the concept.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Secondary.Bound">
            <summary>
            Values (if present) in a column must be within a certain range.  This can include referencing another column.  For example you could specify that
            Date of Birth must have an Inclusive Upper bound of Date of Death.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Secondary.BoundDate">
            <summary>
            Values (if present) in a column must be within a certain range of dates.  This can include referencing another column.  For example you could specify that
             Date of Birth must have an Inclusive Upper bound of Date of Death.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Secondary.BoundDouble">
            <summary>
            Values (if present) in a column must be within a certain range of numeric values.  This can include referencing another column.  For example you could
            specify that the column 'AverageResult' must have an Inclusive Upper bound of the column 'MaxResult'.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Secondary.ISecondaryConstraint">
            <summary>
            Each column can have as many SecondaryConstraints as you want.  Each SecondaryConstraint is a general rule about the data that the column is allowed to
            contain.  This can include Regexes, NotNull requirements etc.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Validation.Constraints.Secondary.ISecondaryConstraint.Validate(System.Object,System.Object[],System.String[])">
            <summary>
            Inherit this method to perform validation operations unique to your Class.  Column value could be DateTime, string or numerical.  Part of validation is 
            ensuring it is of the appropriate type.  otherColumns can be used for example in the case that you intend to predict something such as Gender from Title.
            If your validation fails you should return a ValidationFailure.
            </summary>
            <param name="value"></param>
            <param name="otherColumns"></param>
            <param name="otherColumnNames"></param>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Secondary.NotNull">
            <summary>
            Values must appear in this column, if there are nulls (or whitespace) then the validation will fail.  While this kind of thing is trivially easy to implement
            at database level you might decided that (especially for unimportant columns) you are happy to load missing data rather than crash the data load.  That
            is why this constraint exists. 
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Secondary.Predictor.ChiSexPredictor">
            <summary>
            Validation rule that checks that the second from last digit in a CHI matches the patient gender.  CHI numbers second last digit should be even for
            females and odd for males.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Secondary.Predictor.Prediction">
            <summary>
            Validation rule in which two columns are dependent on one another for validation according to a given PredictionRule.  For example the CHI number contains
            a gender digit, validation passes if the digit matches the selected gender column (See ChiSexPredictor).
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Secondary.Predictor.ValuePredictsOtherValueNullness">
            <summary>
            Validation rule for use with a Prediction Constraint.  Indicates that the 'nullness' of the columns must match (i.e. if one is null the other must be too)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Secondary.ReferentialIntegrityConstraint">
            <summary>
            Specifies that values in the column must (or must not - see InvertLogic) appear in another column.  This lets you have a database table which contains a
            whitelist (or blacklist) of expected values.  This is particularly useful if you want to create a Lookup table but you don't want to create a constraint
            at database level because you expect dirty data and don't want to crash the data load.
            </summary>
        </member>
        <member name="M:Rdmp.Core.Validation.Constraints.Secondary.ReferentialIntegrityConstraint.#ctor">
            <summary>
            Only for XmlSerializer, do not use otherwise
            </summary>
        </member>
        <member name="M:Rdmp.Core.Validation.Constraints.Secondary.ReferentialIntegrityConstraint.Validate(System.Object,System.Object[],System.String[])">
            <summary>
            The first call to this will load all values from the validation column, which may take an appreciable amount of time for large datasets (such as when validating against CHI).
            </summary>
            <param name="value"></param>
            <param name="otherColumns"></param>
            <param name="otherColumnNames"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Validation.Constraints.Secondary.ReferentialIntegrityConstraint.GetUniqueValues">
            <summary>
            Loads the entire (distinct) contents of the validation column into a hashset. This operation will take some time for very large datasets, e.g. validating against CHI, so be careful when calling.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Secondary.RegularExpression">
            <summary>
            Values being validated are expected to pass the Regex pattern
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Constraints.Secondary.StandardRegexConstraint">
            <summary>
            Values being validated are expected to pass the Regex pattern.  The pattern itself is a reference to a StandardRegex which is a central curated definition
            pattern in the Catalogue database.  This allows you to have multiple columns/validation rules in multiple datasets share the same regex without having to
            create copies (and allows you to update the definition in one place).
            </summary>
        </member>
        <member name="M:Rdmp.Core.Validation.Constraints.Secondary.StandardRegexConstraint.#ctor">
            <summary>
            Only for XmlSerializer, do not use otherwise
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Dependency.Exceptions.ValidationXmlDependencyException">
            <summary>
            Thrown when you attempt to delete an object which is referenced in a Catalogues ValidatorXML
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Dependency.Suspect">
            <summary>
            Regex pattern for finding references in ValidatorXML without having to deserialize it.  This is used to identify rules which reference columns and ensure
            that they cannot be deleted (See ValidationXMLObscureDependencyFinder)
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Dependency.ValidationXMLObscureDependencyFinder">
            <summary>
            Prevents deleting objects which are referenced in the ValidatorXML of Catalogues.  This is done by processing the ValidatorXML as a string for speed
            rather than deserializing every ValidationXml.
            </summary>
        </member>
        <member name="F:Rdmp.Core.Validation.Dependency.ValidationXMLObscureDependencyFinder.TheUsualSuspects">
            <summary>
            This is a list of regex patterns for identifying xml serialized classes that implement IMapsDirectlyToDatabaseTable in Xml strings
            It is used to detect when you are trying to delete an object which has hidden references to it in important serialized bits of 
            text (e.g. Catalogue.ValidationXML).
            </summary>
        </member>
        <member name="F:Rdmp.Core.Validation.Dependency.ValidationXMLObscureDependencyFinder.BlackList">
            <summary>
            Catalogues whose ValidationXML doesn't resolve properly
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.ItemValidator">
            <summary>
            An ItemValidator is created for each item in the target object (row) you want to validate.
            Each ItemValidator has a single PrimaryConstraint and zero or more SecondaryConstraint(s).
            </summary>
        </member>
        <member name="M:Rdmp.Core.Validation.ItemValidator.SaveToXml(System.Boolean)">
            <summary>
            Persist the current ItemValidator instance to a string containing XML.
            </summary>
            <returns>a String</returns>
        </member>
        <member name="T:Rdmp.Core.Validation.ValidationFailure">
            <summary>
            A custom Validation exception, thrown when user-specified validation has failed in some way.
            </summary>
        </member>
        <member name="T:Rdmp.Core.Validation.Validator">
            <summary>
            The Validator is the main entry point into this API. A client would typically create a Validator instance and then
            add a number of ItemValidators to it.  Alternatively you can use the static method LoadFromXml.  Ensure you set 
            LocatorForXMLDeserialization.
            
            <para>Generally, there are two phases of interaction with a Validator:</para>
            
            <para>1. Design Time
            During this phase, the client will instantiate and set up a Validator. The Check() method can be called to check for 
            any type incompatibilities prior to running the actual Validate() method.</para>
            
            <para>2. Run Time
            The Validation(o) method is called, applying the previously set up validation rules to the supplied domain object (o).</para>
            
            <para>Note: As of this writing the Dictionary-based method is under active development, whereas the Object-based method
            is not adequately developed or tested . PLEASE USE THE DICTIONARY method FOR NOW!</para>
            </summary>
        </member>
        <member name="F:Rdmp.Core.Validation.Validator.LocatorForXMLDeserialization">
            <summary>
            Validation rules can reference objects e.g. StandardRegex.  This static property indicates where to get the available instances available 
            for selection (the Catalogue database).
            </summary>
        </member>
        <member name="M:Rdmp.Core.Validation.Validator.AddItemValidator(Rdmp.Core.Validation.ItemValidator,System.String,System.Type)">
            <summary>
            Adds an ItemValidator to the Validator, specifying the target property (in the object to be validated) and
            the type that we expect this property to have. The type is used later in the Check() method. See below..
            </summary>
            <param name="itemValidator"></param>
            <param name="targetProperty"></param>
            <param name="expectedType"></param>
        </member>
        <member name="M:Rdmp.Core.Validation.Validator.GetItemValidator(System.String)">
            <summary>
            Returns the ItemValidator associated with the given key.
            </summary>
            <param name="key"></param>
            <returns>An Itemvalidator reference, or null if no match found for the supplied key</returns>
        </member>
        <member name="M:Rdmp.Core.Validation.Validator.RemoveItemValidator(System.String)">
            <summary>
            Removes a given (key) ItemValidator from the collection.
            </summary>
            <param name="key"></param>
            <returns>true if the removal succeeded, false otherwise</returns>
        </member>
        <member name="M:Rdmp.Core.Validation.Validator.Validate(System.Object)">
            <summary>
            Validate against the supplied domain object, which takes the form of a generic object.
            </summary>
            <param name="domainObject"></param>
        </member>
        <member name="M:Rdmp.Core.Validation.Validator.ValidateVerboseAdditive(System.Object,Rdmp.Core.Validation.VerboseValidationResults,System.Nullable{Rdmp.Core.Validation.Constraints.Consequence}@)">
            <summary>
            Validate against the supplied domain object, which takes the form of a generic object with Properties matching TargetProperty or an SqlDataReader or a DataTable
            </summary>
            <param name="domainObject"></param>
            /// <param name="currentResults">It is expected that Validate is called multiple times (once per row) therefore you can store the Result of the last one and pass it back into the method the next time you call it in order to maintain a running total</param>
        </member>
        <member name="M:Rdmp.Core.Validation.Validator.Validate(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Validate against the suppled domain object, which takes the form of a Dictionary.
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:Rdmp.Core.Validation.Validator.LoadFromXml(System.String)">
            <summary>
            Instatiate a Validator from a (previously saved) XML string.
            </summary>
            <param name="xml"></param>
            <returns>a Validator</returns>
        </member>
        <member name="M:Rdmp.Core.Validation.Validator.SaveToXml(System.Boolean)">
            <summary>
            Persist the current Validator instance to a string containing XML.
            </summary>
            <returns>a String</returns>
        </member>
        <member name="M:Rdmp.Core.Validation.Validator.CreateRegularExpression(System.String)">
            <summary>
            This Factory method returns a new RegularExpression instance.
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Validation.Validator.GetPrimaryConstraintNames">
            <summary>
            Returns an arryay of available PrimaryConstraint names.
            Provides support for client applications who may need to display a list for selection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rdmp.Core.Validation.Validator.CreateConstraint(System.String,Rdmp.Core.Validation.Constraints.Consequence)">
            <summary>
            This Factory method returns a Constraint corresponding to the supplied constraint name.
            The name must match the corresponding class name. Matching is case-insensitive.
            An ArgumentException is thrown if a matching constraint cannot be found.
            </summary>
            <param name="name"></param>
            <returns>A Constraint</returns>
        </member>
        <member name="T:Rdmp.Core.Validation.VerboseValidationResults">
            <summary>
            Storage class for recording the number of rows failing validation with each Consequence subdivided by Column.
            </summary>
        </member>
        <member name="P:Rdmp.Core.Validation.VerboseValidationResults.DictionaryOfFailure">
            <summary>
            Dictionary of column names (Key), Value is a Dictionary of each of the potential consequences
            and a count of the number of cells that failed validation with that Consequence (for that Column - Key)
            
            <para>e.g. DictionaryOfFailure["Forename"][Consequence.Missing] is a count of the number of cells which are missing
            (not there where they were expected) in column Forename</para>
            
            </summary>
        </member>
        <member name="P:Rdmp.Core.Validation.VerboseValidationResults.ReasonsRowsInvalidated">
            <summary>
            Every time a row is Invalidated (this List get's the reason for Invalidation added to it)
            </summary>
        </member>
        <member name="P:Rdmp.Core.Validation.VerboseValidationResults.CountOfRowsInvalidated">
            <summary>
            A count of the rows Invalidated due to dodgy data - failed Validations with Consequence.InvalidatesRow
            </summary>
        </member>
    </members>
</doc>
